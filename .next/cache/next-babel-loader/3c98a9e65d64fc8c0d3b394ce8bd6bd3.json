{"ast":null,"code":"import _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { FocusZone, FocusZoneDirection } from '../../FocusZone';\nimport { BaseComponent, classNamesFunction, divProperties, elementContains, focusFirstChild, getNativeProps } from '../../Utilities';\nimport { KeytipManager } from '../../utilities/keytips/KeytipManager';\nvar getClassNames = classNamesFunction();\n\nvar OverflowSetBase =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(OverflowSetBase, _super);\n\n  function OverflowSetBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._focusZone = React.createRef();\n    _this._persistedKeytips = {};\n    _this._keytipManager = KeytipManager.getInstance();\n    _this._divContainer = React.createRef();\n\n    _this._onRenderItems = function (items) {\n      return items.map(function (item, i) {\n        var wrapperDivProps = {\n          className: _this._classNames.item\n        };\n        return React.createElement(\"div\", tslib_1.__assign({\n          key: item.key\n        }, wrapperDivProps), _this.props.onRenderItem(item));\n      });\n    };\n\n    _this._onRenderOverflowButtonWrapper = function (items) {\n      var wrapperDivProps = {\n        className: _this._classNames.overflowButton\n      };\n      var overflowKeytipSequences = _this.props.keytipSequences;\n      var newOverflowItems = [];\n\n      if (overflowKeytipSequences) {\n        items.forEach(function (overflowItem) {\n          var keytip = overflowItem.keytipProps;\n\n          if (keytip) {\n            // Create persisted keytip\n            var persistedKeytip = {\n              content: keytip.content,\n              keySequences: keytip.keySequences,\n              disabled: keytip.disabled || !!(overflowItem.disabled || overflowItem.isDisabled),\n              hasDynamicChildren: keytip.hasDynamicChildren,\n              hasMenu: keytip.hasMenu\n            };\n\n            if (keytip.hasDynamicChildren || _this._getSubMenuForItem(overflowItem)) {\n              // If the keytip has a submenu or children nodes, change onExecute to persistedKeytipExecute\n              persistedKeytip.onExecute = _this._keytipManager.menuExecute.bind(_this._keytipManager, overflowKeytipSequences, overflowItem.keytipProps.keySequences);\n            } else {\n              // If the keytip doesn't have a submenu, just execute the original function\n              persistedKeytip.onExecute = keytip.onExecute;\n            } // Add this persisted keytip to our internal list, use a temporary uniqueID (its content)\n            // uniqueID will get updated on register\n\n\n            _this._persistedKeytips[persistedKeytip.content] = persistedKeytip; // Add the overflow sequence to this item\n\n            var newOverflowItem = tslib_1.__assign({}, overflowItem, {\n              keytipProps: tslib_1.__assign({}, keytip, {\n                overflowSetSequence: overflowKeytipSequences\n              })\n            });\n\n            newOverflowItems.push(newOverflowItem);\n          } else {\n            // Nothing to change, add overflowItem to list\n            newOverflowItems.push(overflowItem);\n          }\n        });\n      } else {\n        newOverflowItems = items;\n      }\n\n      return React.createElement(\"div\", tslib_1.__assign({}, wrapperDivProps), _this.props.onRenderOverflowButton(newOverflowItems));\n    };\n\n    if (props.doNotContainWithinFocusZone) {\n      _this._warnMutuallyExclusive({\n        doNotContainWithinFocusZone: 'focusZoneProps'\n      });\n    }\n\n    return _this;\n  }\n\n  OverflowSetBase.prototype.render = function () {\n    var _a = this.props,\n        items = _a.items,\n        overflowItems = _a.overflowItems,\n        className = _a.className,\n        focusZoneProps = _a.focusZoneProps,\n        styles = _a.styles,\n        vertical = _a.vertical,\n        role = _a.role,\n        doNotContainWithinFocusZone = _a.doNotContainWithinFocusZone;\n    this._classNames = getClassNames(styles, {\n      className: className,\n      vertical: vertical\n    });\n    var Tag;\n    var uniqueComponentProps;\n\n    if (doNotContainWithinFocusZone) {\n      Tag = 'div';\n      uniqueComponentProps = tslib_1.__assign({}, getNativeProps(this.props, divProperties), {\n        ref: this._divContainer\n      });\n    } else {\n      Tag = FocusZone;\n      uniqueComponentProps = tslib_1.__assign({}, getNativeProps(this.props, divProperties), focusZoneProps, {\n        componentRef: this._focusZone,\n        direction: vertical ? FocusZoneDirection.vertical : FocusZoneDirection.horizontal\n      });\n    }\n\n    return React.createElement(Tag, tslib_1.__assign({}, uniqueComponentProps, {\n      className: this._classNames.root,\n      role: role\n    }), items && this._onRenderItems(items), overflowItems && overflowItems.length > 0 && this._onRenderOverflowButtonWrapper(overflowItems));\n  };\n  /**\n   * Sets focus to the first tabbable item in the OverflowSet.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element,\n   * even if focus is already in theOverflowSet\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n\n\n  OverflowSetBase.prototype.focus = function (forceIntoFirstElement) {\n    var focusSucceeded = false;\n\n    if (this.props.doNotContainWithinFocusZone) {\n      if (this._divContainer.current) {\n        focusSucceeded = focusFirstChild(this._divContainer.current);\n      }\n    } else if (this._focusZone.current) {\n      focusSucceeded = this._focusZone.current.focus(forceIntoFirstElement);\n    }\n\n    return focusSucceeded;\n  };\n  /**\n   * Sets focus to a specific child element within the OverflowSet.\n   * @param childElement - The child element within the zone to focus.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n\n\n  OverflowSetBase.prototype.focusElement = function (childElement) {\n    var focusSucceeded = false;\n\n    if (!childElement) {\n      return false;\n    }\n\n    if (this.props.doNotContainWithinFocusZone) {\n      if (this._divContainer.current && elementContains(this._divContainer.current, childElement)) {\n        childElement.focus();\n        focusSucceeded = document.activeElement === childElement;\n      }\n    } else if (this._focusZone.current) {\n      focusSucceeded = this._focusZone.current.focusElement(childElement);\n    }\n\n    return focusSucceeded;\n  }; // Add keytip register/unregister handlers to lifecycle functions to correctly manage persisted keytips\n\n\n  OverflowSetBase.prototype.componentDidMount = function () {\n    this._registerPersistedKeytips();\n  };\n\n  OverflowSetBase.prototype.componentWillUnmount = function () {\n    this._unregisterPersistedKeytips();\n  }; // tslint:disable-next-line function-name\n\n\n  OverflowSetBase.prototype.UNSAFE_componentWillUpdate = function () {\n    this._unregisterPersistedKeytips();\n  };\n\n  OverflowSetBase.prototype.componentDidUpdate = function () {\n    this._registerPersistedKeytips();\n  };\n\n  OverflowSetBase.prototype._registerPersistedKeytips = function () {\n    var _this = this;\n\n    _Object$keys(this._persistedKeytips).forEach(function (key) {\n      var keytip = _this._persistedKeytips[key];\n\n      var uniqueID = _this._keytipManager.register(keytip, true); // Update map\n\n\n      _this._persistedKeytips[uniqueID] = keytip;\n      delete _this._persistedKeytips[key];\n    });\n  };\n\n  OverflowSetBase.prototype._unregisterPersistedKeytips = function () {\n    var _this = this; // Delete all persisted keytips saved\n\n\n    _Object$keys(this._persistedKeytips).forEach(function (uniqueID) {\n      _this._keytipManager.unregister(_this._persistedKeytips[uniqueID], uniqueID, true);\n    });\n\n    this._persistedKeytips = {};\n  };\n  /**\n   * Gets the subMenu for an overflow item\n   * Checks if itemSubMenuProvider has been defined, if not defaults to subMenuProps\n   */\n\n\n  OverflowSetBase.prototype._getSubMenuForItem = function (item) {\n    if (this.props.itemSubMenuProvider) {\n      return this.props.itemSubMenuProvider(item);\n    }\n\n    if (item.subMenuProps) {\n      return item.subMenuProps.items;\n    }\n\n    return undefined;\n  };\n\n  OverflowSetBase.defaultProps = {\n    vertical: false,\n    role: 'menubar'\n  };\n  return OverflowSetBase;\n}(BaseComponent);\n\nexport { OverflowSetBase };","map":{"version":3,"sources":["components/OverflowSet/OverflowSet.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nimport { FocusZone, FocusZoneDirection, IFocusZone } from '../../FocusZone';\nimport { IKeytipProps } from '../../Keytip';\nimport { BaseComponent, classNamesFunction, divProperties, elementContains, focusFirstChild, getNativeProps } from '../../Utilities';\nimport { IProcessedStyleSet } from '../../Styling';\nimport { KeytipManager } from '../../utilities/keytips/KeytipManager';\nimport { IOverflowSet, IOverflowSetItemProps, IOverflowSetProps, IOverflowSetStyles, IOverflowSetStyleProps } from './OverflowSet.types';\n\nconst getClassNames = classNamesFunction<IOverflowSetStyleProps, IOverflowSetStyles>();\n\nexport class OverflowSetBase extends BaseComponent<IOverflowSetProps, {}> implements IOverflowSet {\n  public static defaultProps: Pick<IOverflowSetProps, 'vertical' | 'role'> = {\n    vertical: false,\n    role: 'menubar'\n  };\n\n  private _focusZone = React.createRef<IFocusZone>();\n  private _persistedKeytips: { [uniqueID: string]: IKeytipProps } = {};\n  private _keytipManager: KeytipManager = KeytipManager.getInstance();\n  private _divContainer = React.createRef<HTMLDivElement>();\n  private _classNames: IProcessedStyleSet<IOverflowSetStyles>;\n\n  constructor(props: IOverflowSetProps) {\n    super(props);\n\n    if (props.doNotContainWithinFocusZone) {\n      this._warnMutuallyExclusive({\n        doNotContainWithinFocusZone: 'focusZoneProps'\n      });\n    }\n  }\n\n  public render(): JSX.Element {\n    const { items, overflowItems, className, focusZoneProps, styles, vertical, role, doNotContainWithinFocusZone } = this.props;\n\n    this._classNames = getClassNames(styles, { className, vertical });\n\n    let Tag;\n    let uniqueComponentProps;\n\n    if (doNotContainWithinFocusZone) {\n      Tag = 'div';\n      uniqueComponentProps = {\n        ...getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties),\n        ref: this._divContainer\n      };\n    } else {\n      Tag = FocusZone;\n      uniqueComponentProps = {\n        ...getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties),\n        ...focusZoneProps,\n        componentRef: this._focusZone,\n        direction: vertical ? FocusZoneDirection.vertical : FocusZoneDirection.horizontal\n      };\n    }\n\n    return (\n      <Tag {...uniqueComponentProps} className={this._classNames.root} role={role}>\n        {items && this._onRenderItems(items)}\n        {overflowItems && overflowItems.length > 0 && this._onRenderOverflowButtonWrapper(overflowItems)}\n      </Tag>\n    );\n  }\n\n  /**\n   * Sets focus to the first tabbable item in the OverflowSet.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element,\n   * even if focus is already in theOverflowSet\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focus(forceIntoFirstElement?: boolean): boolean {\n    let focusSucceeded = false;\n\n    if (this.props.doNotContainWithinFocusZone) {\n      if (this._divContainer.current) {\n        focusSucceeded = focusFirstChild(this._divContainer.current);\n      }\n    } else if (this._focusZone.current) {\n      focusSucceeded = this._focusZone.current.focus(forceIntoFirstElement);\n    }\n\n    return focusSucceeded;\n  }\n\n  /**\n   * Sets focus to a specific child element within the OverflowSet.\n   * @param childElement - The child element within the zone to focus.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focusElement(childElement?: HTMLElement): boolean {\n    let focusSucceeded = false;\n\n    if (!childElement) {\n      return false;\n    }\n\n    if (this.props.doNotContainWithinFocusZone) {\n      if (this._divContainer.current && elementContains(this._divContainer.current, childElement)) {\n        childElement.focus();\n        focusSucceeded = document.activeElement === childElement;\n      }\n    } else if (this._focusZone.current) {\n      focusSucceeded = this._focusZone.current.focusElement(childElement);\n    }\n\n    return focusSucceeded;\n  }\n\n  // Add keytip register/unregister handlers to lifecycle functions to correctly manage persisted keytips\n  public componentDidMount() {\n    this._registerPersistedKeytips();\n  }\n\n  public componentWillUnmount() {\n    this._unregisterPersistedKeytips();\n  }\n\n  // tslint:disable-next-line function-name\n  public UNSAFE_componentWillUpdate() {\n    this._unregisterPersistedKeytips();\n  }\n\n  public componentDidUpdate() {\n    this._registerPersistedKeytips();\n  }\n\n  private _registerPersistedKeytips() {\n    Object.keys(this._persistedKeytips).forEach((key: string) => {\n      const keytip = this._persistedKeytips[key];\n      const uniqueID = this._keytipManager.register(keytip, true);\n      // Update map\n      this._persistedKeytips[uniqueID] = keytip;\n      delete this._persistedKeytips[key];\n    });\n  }\n\n  private _unregisterPersistedKeytips() {\n    // Delete all persisted keytips saved\n    Object.keys(this._persistedKeytips).forEach((uniqueID: string) => {\n      this._keytipManager.unregister(this._persistedKeytips[uniqueID], uniqueID, true);\n    });\n    this._persistedKeytips = {};\n  }\n\n  private _onRenderItems = (items: IOverflowSetItemProps[]): JSX.Element[] => {\n    return items.map((item, i) => {\n      const wrapperDivProps: React.HTMLProps<HTMLDivElement> = {\n        className: this._classNames.item\n      };\n      return (\n        <div key={item.key} {...wrapperDivProps}>\n          {this.props.onRenderItem(item)}\n        </div>\n      );\n    });\n  };\n\n  private _onRenderOverflowButtonWrapper = (items: any[]): JSX.Element => {\n    const wrapperDivProps: React.HTMLProps<HTMLDivElement> = {\n      className: this._classNames.overflowButton\n    };\n\n    const overflowKeytipSequences = this.props.keytipSequences;\n    let newOverflowItems: any[] = [];\n\n    if (overflowKeytipSequences) {\n      items.forEach(overflowItem => {\n        const keytip = (overflowItem as IOverflowSetItemProps).keytipProps;\n        if (keytip) {\n          // Create persisted keytip\n          const persistedKeytip: IKeytipProps = {\n            content: keytip.content,\n            keySequences: keytip.keySequences,\n            disabled: keytip.disabled || !!(overflowItem.disabled || overflowItem.isDisabled),\n            hasDynamicChildren: keytip.hasDynamicChildren,\n            hasMenu: keytip.hasMenu\n          };\n\n          if (keytip.hasDynamicChildren || this._getSubMenuForItem(overflowItem)) {\n            // If the keytip has a submenu or children nodes, change onExecute to persistedKeytipExecute\n            persistedKeytip.onExecute = this._keytipManager.menuExecute.bind(\n              this._keytipManager,\n              overflowKeytipSequences,\n              overflowItem.keytipProps.keySequences\n            );\n          } else {\n            // If the keytip doesn't have a submenu, just execute the original function\n            persistedKeytip.onExecute = keytip.onExecute;\n          }\n\n          // Add this persisted keytip to our internal list, use a temporary uniqueID (its content)\n          // uniqueID will get updated on register\n          this._persistedKeytips[persistedKeytip.content] = persistedKeytip;\n\n          // Add the overflow sequence to this item\n          const newOverflowItem = {\n            ...overflowItem,\n            keytipProps: {\n              ...keytip,\n              overflowSetSequence: overflowKeytipSequences\n            }\n          };\n          newOverflowItems.push(newOverflowItem);\n        } else {\n          // Nothing to change, add overflowItem to list\n          newOverflowItems.push(overflowItem);\n        }\n      });\n    } else {\n      newOverflowItems = items;\n    }\n    return <div {...wrapperDivProps}>{this.props.onRenderOverflowButton(newOverflowItems)}</div>;\n  };\n\n  /**\n   * Gets the subMenu for an overflow item\n   * Checks if itemSubMenuProvider has been defined, if not defaults to subMenuProps\n   */\n  private _getSubMenuForItem(item: any): any[] | undefined {\n    if (this.props.itemSubMenuProvider) {\n      return this.props.itemSubMenuProvider(item);\n    }\n    if (item.subMenuProps) {\n      return item.subMenuProps.items;\n    }\n    return undefined;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}