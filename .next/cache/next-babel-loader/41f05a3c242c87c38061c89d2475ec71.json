{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar React = require(\"react\");\n\nvar Utilities_1 = require(\"../../Utilities\");\n\nvar Image_types_1 = require(\"./Image.types\");\n\nvar getClassNames = Utilities_1.classNamesFunction();\nvar KEY_PREFIX = 'fabricImage';\n\nvar ImageBase =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ImageBase, _super);\n\n  function ImageBase(props) {\n    var _this = _super.call(this, props) || this; // Make an initial assumption about the image layout until we can\n    // check the rendered element. The value here only takes effect when\n    // shouldStartVisible is true.\n\n\n    _this._coverStyle = Image_types_1.ImageCoverStyle.portrait;\n    _this._imageElement = React.createRef();\n    _this._frameElement = React.createRef();\n\n    _this._onImageLoaded = function (ev) {\n      var _a = _this.props,\n          src = _a.src,\n          onLoad = _a.onLoad;\n\n      if (onLoad) {\n        onLoad(ev);\n      }\n\n      _this._computeCoverStyle(_this.props);\n\n      if (src) {\n        _this.setState({\n          loadState: Image_types_1.ImageLoadState.loaded\n        });\n      }\n    };\n\n    _this._onImageError = function (ev) {\n      if (_this.props.onError) {\n        _this.props.onError(ev);\n      }\n\n      _this.setState({\n        loadState: Image_types_1.ImageLoadState.error\n      });\n    };\n\n    _this.state = {\n      loadState: Image_types_1.ImageLoadState.notLoaded\n    };\n    return _this;\n  } // tslint:disable-next-line function-name\n\n\n  ImageBase.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    if (nextProps.src !== this.props.src) {\n      this.setState({\n        loadState: Image_types_1.ImageLoadState.notLoaded\n      });\n    } else if (this.state.loadState === Image_types_1.ImageLoadState.loaded) {\n      this._computeCoverStyle(nextProps);\n    }\n  };\n\n  ImageBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    this._checkImageLoaded();\n\n    if (this.props.onLoadingStateChange && prevState.loadState !== this.state.loadState) {\n      this.props.onLoadingStateChange(this.state.loadState);\n    }\n  };\n\n  ImageBase.prototype.render = function () {\n    var imageProps = Utilities_1.getNativeProps(this.props, Utilities_1.imageProperties, ['width', 'height']);\n    var _a = this.props,\n        src = _a.src,\n        alt = _a.alt,\n        width = _a.width,\n        height = _a.height,\n        shouldFadeIn = _a.shouldFadeIn,\n        shouldStartVisible = _a.shouldStartVisible,\n        className = _a.className,\n        imageFit = _a.imageFit,\n        role = _a.role,\n        maximizeFrame = _a.maximizeFrame,\n        styles = _a.styles,\n        theme = _a.theme;\n    var loadState = this.state.loadState;\n    var coverStyle = this.props.coverStyle !== undefined ? this.props.coverStyle : this._coverStyle;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      width: width,\n      height: height,\n      maximizeFrame: maximizeFrame,\n      shouldFadeIn: shouldFadeIn,\n      shouldStartVisible: shouldStartVisible,\n      isLoaded: loadState === Image_types_1.ImageLoadState.loaded || loadState === Image_types_1.ImageLoadState.notLoaded && this.props.shouldStartVisible,\n      isLandscape: coverStyle === Image_types_1.ImageCoverStyle.landscape,\n      isCenter: imageFit === Image_types_1.ImageFit.center,\n      isCenterContain: imageFit === Image_types_1.ImageFit.centerContain,\n      isCenterCover: imageFit === Image_types_1.ImageFit.centerCover,\n      isContain: imageFit === Image_types_1.ImageFit.contain,\n      isCover: imageFit === Image_types_1.ImageFit.cover,\n      isNone: imageFit === Image_types_1.ImageFit.none,\n      isError: loadState === Image_types_1.ImageLoadState.error,\n      isNotImageFit: imageFit === undefined\n    }); // If image dimensions aren't specified, the natural size of the image is used.\n\n    return React.createElement(\"div\", {\n      className: classNames.root,\n      style: {\n        width: width,\n        height: height\n      },\n      ref: this._frameElement\n    }, React.createElement(\"img\", tslib_1.__assign({}, imageProps, {\n      onLoad: this._onImageLoaded,\n      onError: this._onImageError,\n      key: KEY_PREFIX + this.props.src || '',\n      className: classNames.image,\n      ref: this._imageElement,\n      src: src,\n      alt: alt,\n      role: role\n    })));\n  };\n\n  ImageBase.prototype._checkImageLoaded = function () {\n    var src = this.props.src;\n    var loadState = this.state.loadState;\n\n    if (loadState === Image_types_1.ImageLoadState.notLoaded) {\n      // testing if naturalWidth and naturalHeight are greater than zero is better than checking\n      // .complete, because .complete will also be set to true if the image breaks. However,\n      // for some browsers, SVG images do not have a naturalWidth or naturalHeight, so fall back\n      // to checking .complete for these images.\n      var isLoaded = this._imageElement.current ? src && this._imageElement.current.naturalWidth > 0 && this._imageElement.current.naturalHeight > 0 || this._imageElement.current.complete && ImageBase._svgRegex.test(src) : false;\n\n      if (isLoaded) {\n        this._computeCoverStyle(this.props);\n\n        this.setState({\n          loadState: Image_types_1.ImageLoadState.loaded\n        });\n      }\n    }\n  };\n\n  ImageBase.prototype._computeCoverStyle = function (props) {\n    var imageFit = props.imageFit,\n        width = props.width,\n        height = props.height; // Do not compute cover style if it was already specified in props\n\n    if ((imageFit === Image_types_1.ImageFit.cover || imageFit === Image_types_1.ImageFit.contain || imageFit === Image_types_1.ImageFit.centerContain || imageFit === Image_types_1.ImageFit.centerCover) && this.props.coverStyle === undefined && this._imageElement.current && this._frameElement.current) {\n      // Determine the desired ratio using the width and height props.\n      // If those props aren't available, measure measure the frame.\n      var desiredRatio = void 0;\n\n      if (!!width && !!height && imageFit !== Image_types_1.ImageFit.centerContain && imageFit !== Image_types_1.ImageFit.centerCover) {\n        desiredRatio = width / height;\n      } else {\n        desiredRatio = this._frameElement.current.clientWidth / this._frameElement.current.clientHeight;\n      } // Examine the source image to determine its original ratio.\n\n\n      var naturalRatio = this._imageElement.current.naturalWidth / this._imageElement.current.naturalHeight; // Should we crop from the top or the sides?\n\n      if (naturalRatio > desiredRatio) {\n        this._coverStyle = Image_types_1.ImageCoverStyle.landscape;\n      } else {\n        this._coverStyle = Image_types_1.ImageCoverStyle.portrait;\n      }\n    }\n  };\n\n  ImageBase.defaultProps = {\n    shouldFadeIn: true\n  };\n  ImageBase._svgRegex = /\\.svg$/i;\n  return ImageBase;\n}(React.Component);\n\nexports.ImageBase = ImageBase;","map":{"version":3,"sources":["components/Image/Image.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { classNamesFunction, getNativeProps, imageProperties } from '../../Utilities';\nimport { IImageProps, IImageStyleProps, IImageStyles, ImageCoverStyle, ImageFit, ImageLoadState } from './Image.types';\n\nconst getClassNames = classNamesFunction<IImageStyleProps, IImageStyles>();\n\nexport interface IImageState {\n  loadState?: ImageLoadState;\n}\n\nconst KEY_PREFIX = 'fabricImage';\n\nexport class ImageBase extends React.Component<IImageProps, IImageState> {\n  public static defaultProps = {\n    shouldFadeIn: true\n  };\n\n  private static _svgRegex = /\\.svg$/i;\n\n  // Make an initial assumption about the image layout until we can\n  // check the rendered element. The value here only takes effect when\n  // shouldStartVisible is true.\n  private _coverStyle: ImageCoverStyle = ImageCoverStyle.portrait;\n  private _imageElement = React.createRef<HTMLImageElement>();\n  private _frameElement = React.createRef<HTMLDivElement>();\n\n  constructor(props: IImageProps) {\n    super(props);\n\n    this.state = {\n      loadState: ImageLoadState.notLoaded\n    };\n  }\n\n  // tslint:disable-next-line function-name\n  public UNSAFE_componentWillReceiveProps(nextProps: IImageProps): void {\n    if (nextProps.src !== this.props.src) {\n      this.setState({\n        loadState: ImageLoadState.notLoaded\n      });\n    } else if (this.state.loadState === ImageLoadState.loaded) {\n      this._computeCoverStyle(nextProps);\n    }\n  }\n\n  public componentDidUpdate(prevProps: IImageProps, prevState: IImageState) {\n    this._checkImageLoaded();\n    if (this.props.onLoadingStateChange && prevState.loadState !== this.state.loadState) {\n      this.props.onLoadingStateChange(this.state.loadState!);\n    }\n  }\n\n  public render(): JSX.Element {\n    const imageProps = getNativeProps<React.ImgHTMLAttributes<HTMLImageElement>>(this.props, imageProperties, ['width', 'height']);\n    const {\n      src,\n      alt,\n      width,\n      height,\n      shouldFadeIn,\n      shouldStartVisible,\n      className,\n      imageFit,\n      role,\n      maximizeFrame,\n      styles,\n      theme\n    } = this.props;\n    const { loadState } = this.state;\n    const coverStyle = this.props.coverStyle !== undefined ? this.props.coverStyle : this._coverStyle;\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      width,\n      height,\n      maximizeFrame,\n      shouldFadeIn,\n      shouldStartVisible,\n      isLoaded: loadState === ImageLoadState.loaded || (loadState === ImageLoadState.notLoaded && this.props.shouldStartVisible),\n      isLandscape: coverStyle === ImageCoverStyle.landscape,\n      isCenter: imageFit === ImageFit.center,\n      isCenterContain: imageFit === ImageFit.centerContain,\n      isCenterCover: imageFit === ImageFit.centerCover,\n      isContain: imageFit === ImageFit.contain,\n      isCover: imageFit === ImageFit.cover,\n      isNone: imageFit === ImageFit.none,\n      isError: loadState === ImageLoadState.error,\n      isNotImageFit: imageFit === undefined\n    });\n\n    // If image dimensions aren't specified, the natural size of the image is used.\n    return (\n      <div className={classNames.root} style={{ width: width, height: height }} ref={this._frameElement}>\n        <img\n          {...imageProps}\n          onLoad={this._onImageLoaded}\n          onError={this._onImageError}\n          key={KEY_PREFIX + this.props.src || ''}\n          className={classNames.image}\n          ref={this._imageElement}\n          src={src}\n          alt={alt}\n          role={role}\n        />\n      </div>\n    );\n  }\n\n  private _onImageLoaded = (ev: React.SyntheticEvent<HTMLImageElement>): void => {\n    const { src, onLoad } = this.props;\n    if (onLoad) {\n      onLoad(ev);\n    }\n\n    this._computeCoverStyle(this.props);\n\n    if (src) {\n      this.setState({\n        loadState: ImageLoadState.loaded\n      });\n    }\n  };\n\n  private _checkImageLoaded(): void {\n    const { src } = this.props;\n    const { loadState } = this.state;\n\n    if (loadState === ImageLoadState.notLoaded) {\n      // testing if naturalWidth and naturalHeight are greater than zero is better than checking\n      // .complete, because .complete will also be set to true if the image breaks. However,\n      // for some browsers, SVG images do not have a naturalWidth or naturalHeight, so fall back\n      // to checking .complete for these images.\n      const isLoaded: boolean = this._imageElement.current\n        ? (src && (this._imageElement.current.naturalWidth > 0 && this._imageElement.current.naturalHeight > 0)) ||\n          (this._imageElement.current.complete && ImageBase._svgRegex.test(src!))\n        : false;\n\n      if (isLoaded) {\n        this._computeCoverStyle(this.props);\n        this.setState({\n          loadState: ImageLoadState.loaded\n        });\n      }\n    }\n  }\n\n  private _computeCoverStyle(props: IImageProps): void {\n    const { imageFit, width, height } = props;\n\n    // Do not compute cover style if it was already specified in props\n    if (\n      (imageFit === ImageFit.cover ||\n        imageFit === ImageFit.contain ||\n        imageFit === ImageFit.centerContain ||\n        imageFit === ImageFit.centerCover) &&\n      this.props.coverStyle === undefined &&\n      this._imageElement.current &&\n      this._frameElement.current\n    ) {\n      // Determine the desired ratio using the width and height props.\n      // If those props aren't available, measure measure the frame.\n      let desiredRatio;\n      if (!!width && !!height && imageFit !== ImageFit.centerContain && imageFit !== ImageFit.centerCover) {\n        desiredRatio = (width as number) / (height as number);\n      } else {\n        desiredRatio = this._frameElement.current.clientWidth / this._frameElement.current.clientHeight;\n      }\n\n      // Examine the source image to determine its original ratio.\n      const naturalRatio = this._imageElement.current.naturalWidth / this._imageElement.current.naturalHeight;\n\n      // Should we crop from the top or the sides?\n      if (naturalRatio > desiredRatio) {\n        this._coverStyle = ImageCoverStyle.landscape;\n      } else {\n        this._coverStyle = ImageCoverStyle.portrait;\n      }\n    }\n  }\n\n  private _onImageError = (ev: React.SyntheticEvent<HTMLImageElement>): void => {\n    if (this.props.onError) {\n      this.props.onError(ev);\n    }\n    this.setState({\n      loadState: ImageLoadState.error\n    });\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"script"}