{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.DEFAULT_MASK_FORMAT_CHARS = {\n  '9': /[0-9]/,\n  a: /[a-zA-Z]/,\n  '*': /[a-zA-Z0-9]/\n};\n/**\n * Takes in the mask string and the formatCharacters and returns an array of MaskValues\n * Example:\n * mask = 'Phone Number: (999) - 9999'\n * return = [\n *    { value: undefined, displayIndex: 16, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 17, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 18, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 22, format: /[0-9]/ },\n * ]\n *\n * @param mask The string use to define the format of the displayed maskedValue.\n * @param formatChars An object defining how certain characters in the mask should accept input.\n */\n\nfunction parseMask(mask, formatChars) {\n  if (formatChars === void 0) {\n    formatChars = exports.DEFAULT_MASK_FORMAT_CHARS;\n  }\n\n  if (!mask) {\n    return [];\n  }\n\n  var maskCharData = []; // Count the escape characters in the mask string.\n\n  var escapedChars = 0;\n\n  for (var i = 0; i + escapedChars < mask.length; i++) {\n    var maskChar = mask.charAt(i + escapedChars);\n\n    if (maskChar === '\\\\') {\n      escapedChars++;\n    } else {\n      // Check if the maskChar is a format character.\n      var maskFormat = formatChars[maskChar];\n\n      if (maskFormat) {\n        maskCharData.push({\n          /**\n           * Do not add escapedChars to the displayIndex.\n           * The index refers to a position in the mask's displayValue.\n           * Since the backslashes don't appear in the displayValue,\n           * we do not add them to the charData displayIndex.\n           */\n          displayIndex: i,\n          format: maskFormat\n        });\n      }\n    }\n  }\n\n  return maskCharData;\n}\n\nexports.parseMask = parseMask;\n/**\n * Takes in the mask string, an array of MaskValues, and the maskCharacter\n * returns the mask string formatted with the input values and maskCharacter.\n * If the maskChar is undefined, the maskDisplay is truncated to the last filled format character.\n * Example:\n * mask = 'Phone Number: (999) 999 - 9999'\n * maskCharData = '12345'\n * maskChar = '_'\n * return = 'Phone Number: (123) 45_ - ___'\n *\n * Example:\n * mask = 'Phone Number: (999) 999 - 9999'\n * value = '12345'\n * maskChar = undefined\n * return = 'Phone Number: (123) 45'\n *\n * @param mask The string use to define the format of the displayed maskedValue.\n * @param maskCharData The input values to insert into the mask string for displaying.\n * @param maskChar? A character to display in place of unfilled mask format characters.\n */\n\nfunction getMaskDisplay(mask, maskCharData, maskChar) {\n  var maskDisplay = mask;\n\n  if (!maskDisplay) {\n    return '';\n  } // Remove all backslashes\n\n\n  maskDisplay = maskDisplay.replace(/\\\\/g, ''); // lastDisplayIndex is is used to truncate the string if necessary.\n\n  var lastDisplayIndex = 0;\n\n  if (maskCharData.length > 0) {\n    lastDisplayIndex = maskCharData[0].displayIndex - 1;\n  }\n  /**\n   * For each input value, replace the character in the maskDisplay with the value.\n   * If there is no value set for the format character, use the maskChar.\n   */\n\n\n  for (var _i = 0, maskCharData_1 = maskCharData; _i < maskCharData_1.length; _i++) {\n    var charData = maskCharData_1[_i];\n    var nextChar = ' ';\n\n    if (charData.value) {\n      nextChar = charData.value;\n\n      if (charData.displayIndex > lastDisplayIndex) {\n        lastDisplayIndex = charData.displayIndex;\n      }\n    } else {\n      if (maskChar) {\n        nextChar = maskChar;\n      }\n    } // Insert the character into the maskdisplay at its corresponding index\n\n\n    maskDisplay = maskDisplay.slice(0, charData.displayIndex) + nextChar + maskDisplay.slice(charData.displayIndex + 1);\n  } // Cut off all mask characters after the last filled format value\n\n\n  if (!maskChar) {\n    maskDisplay = maskDisplay.slice(0, lastDisplayIndex + 1);\n  }\n\n  return maskDisplay;\n}\n\nexports.getMaskDisplay = getMaskDisplay;\n/**\n * Get the next format index right of or at a specified index.\n * If no index exists, returns the rightmost index.\n * @param maskCharData\n * @param index\n */\n\nfunction getRightFormatIndex(maskCharData, index) {\n  for (var i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= index) {\n      return maskCharData[i].displayIndex;\n    }\n  }\n\n  return maskCharData[maskCharData.length - 1].displayIndex;\n}\n\nexports.getRightFormatIndex = getRightFormatIndex;\n/**\n * Get the next format index left of a specified index.\n * If no index exists, returns the leftmost index.\n * @param maskCharData\n * @param index\n */\n\nfunction getLeftFormatIndex(maskCharData, index) {\n  for (var i = maskCharData.length - 1; i >= 0; i--) {\n    if (maskCharData[i].displayIndex < index) {\n      return maskCharData[i].displayIndex;\n    }\n  }\n\n  return maskCharData[0].displayIndex;\n}\n\nexports.getLeftFormatIndex = getLeftFormatIndex;\n/**\n * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n * @param selectionCount\n */\n\nfunction clearRange(maskCharData, selectionStart, selectionCount) {\n  for (var i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      if (maskCharData[i].displayIndex >= selectionStart + selectionCount) {\n        break;\n      }\n\n      maskCharData[i].value = undefined;\n    }\n  }\n\n  return maskCharData;\n}\n\nexports.clearRange = clearRange;\n/**\n * Deletes the input character at or after a specified index and returns the new array of charData\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n */\n\nfunction clearNext(maskCharData, selectionStart) {\n  for (var i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      maskCharData[i].value = undefined;\n      break;\n    }\n  }\n\n  return maskCharData;\n}\n\nexports.clearNext = clearNext;\n/**\n * Deletes the input character before a specified index and returns the new array of charData\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n */\n\nfunction clearPrev(maskCharData, selectionStart) {\n  for (var i = maskCharData.length - 1; i >= 0; i--) {\n    if (maskCharData[i].displayIndex < selectionStart) {\n      maskCharData[i].value = undefined;\n      break;\n    }\n  }\n\n  return maskCharData;\n}\n\nexports.clearPrev = clearPrev;\n/**\n * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.\n * Modifies the maskCharData inplace with the passed string and returns the display index of the\n * next format character after the inserted string.\n * @param maskCharData\n * @param selectionStart\n * @param selectionCount\n * @return The displayIndex of the next format character\n */\n\nfunction insertString(maskCharData, selectionStart, newString) {\n  var stringIndex = 0;\n  var nextIndex = 0;\n  var isStringInserted = false; // Iterate through _maskCharData finding values with a displayIndex after the specified range start\n\n  for (var i = 0; i < maskCharData.length && stringIndex < newString.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      isStringInserted = true;\n      nextIndex = maskCharData[i].displayIndex; // Find the next character in the newString that matches the format\n\n      while (stringIndex < newString.length) {\n        // If the character matches the format regexp, set the maskCharData to the new character\n        if (maskCharData[i].format.test(newString.charAt(stringIndex))) {\n          maskCharData[i].value = newString.charAt(stringIndex++); // Set the nextIndex to the display index of the next mask format character.\n\n          if (i + 1 < maskCharData.length) {\n            nextIndex = maskCharData[i + 1].displayIndex;\n          } else {\n            nextIndex++;\n          }\n\n          break;\n        }\n\n        stringIndex++;\n      }\n    }\n  }\n\n  return isStringInserted ? nextIndex : selectionStart;\n}\n\nexports.insertString = insertString;","map":{"version":3,"sources":["components/TextField/MaskedTextField/inputMask.ts"],"names":[],"mappings":"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","sourcesContent":["export interface IMaskValue {\n  value?: string;\n  /**\n   * This index refers to the index in the displayMask rather than the inputMask.\n   * This means that any escaped characters do not count toward this index.\n   */\n  displayIndex: number;\n  format: RegExp;\n}\n\nexport const DEFAULT_MASK_FORMAT_CHARS: { [key: string]: RegExp } = {\n  '9': /[0-9]/,\n  a: /[a-zA-Z]/,\n  '*': /[a-zA-Z0-9]/\n};\n\n/**\n * Takes in the mask string and the formatCharacters and returns an array of MaskValues\n * Example:\n * mask = 'Phone Number: (999) - 9999'\n * return = [\n *    { value: undefined, displayIndex: 16, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 17, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 18, format: /[0-9]/ },\n *    { value: undefined, displayIndex: 22, format: /[0-9]/ },\n * ]\n *\n * @param mask The string use to define the format of the displayed maskedValue.\n * @param formatChars An object defining how certain characters in the mask should accept input.\n */\nexport function parseMask(mask: string | undefined, formatChars: { [key: string]: RegExp } = DEFAULT_MASK_FORMAT_CHARS): IMaskValue[] {\n  if (!mask) {\n    return [];\n  }\n\n  const maskCharData: IMaskValue[] = [];\n  // Count the escape characters in the mask string.\n  let escapedChars = 0;\n  for (let i = 0; i + escapedChars < mask.length; i++) {\n    const maskChar = mask.charAt(i + escapedChars);\n    if (maskChar === '\\\\') {\n      escapedChars++;\n    } else {\n      // Check if the maskChar is a format character.\n      const maskFormat = formatChars[maskChar];\n      if (maskFormat) {\n        maskCharData.push({\n          /**\n           * Do not add escapedChars to the displayIndex.\n           * The index refers to a position in the mask's displayValue.\n           * Since the backslashes don't appear in the displayValue,\n           * we do not add them to the charData displayIndex.\n           */\n          displayIndex: i,\n          format: maskFormat\n        });\n      }\n    }\n  }\n\n  return maskCharData;\n}\n\n/**\n * Takes in the mask string, an array of MaskValues, and the maskCharacter\n * returns the mask string formatted with the input values and maskCharacter.\n * If the maskChar is undefined, the maskDisplay is truncated to the last filled format character.\n * Example:\n * mask = 'Phone Number: (999) 999 - 9999'\n * maskCharData = '12345'\n * maskChar = '_'\n * return = 'Phone Number: (123) 45_ - ___'\n *\n * Example:\n * mask = 'Phone Number: (999) 999 - 9999'\n * value = '12345'\n * maskChar = undefined\n * return = 'Phone Number: (123) 45'\n *\n * @param mask The string use to define the format of the displayed maskedValue.\n * @param maskCharData The input values to insert into the mask string for displaying.\n * @param maskChar? A character to display in place of unfilled mask format characters.\n */\nexport function getMaskDisplay(mask: string | undefined, maskCharData: IMaskValue[], maskChar?: string): string {\n  let maskDisplay = mask;\n\n  if (!maskDisplay) {\n    return '';\n  }\n\n  // Remove all backslashes\n  maskDisplay = maskDisplay.replace(/\\\\/g, '');\n\n  // lastDisplayIndex is is used to truncate the string if necessary.\n  let lastDisplayIndex = 0;\n  if (maskCharData.length > 0) {\n    lastDisplayIndex = maskCharData[0].displayIndex - 1;\n  }\n\n  /**\n   * For each input value, replace the character in the maskDisplay with the value.\n   * If there is no value set for the format character, use the maskChar.\n   */\n  for (const charData of maskCharData) {\n    let nextChar = ' ';\n    if (charData.value) {\n      nextChar = charData.value;\n      if (charData.displayIndex > lastDisplayIndex) {\n        lastDisplayIndex = charData.displayIndex;\n      }\n    } else {\n      if (maskChar) {\n        nextChar = maskChar;\n      }\n    }\n\n    // Insert the character into the maskdisplay at its corresponding index\n    maskDisplay = maskDisplay.slice(0, charData.displayIndex) + nextChar + maskDisplay.slice(charData.displayIndex + 1);\n  }\n\n  // Cut off all mask characters after the last filled format value\n  if (!maskChar) {\n    maskDisplay = maskDisplay.slice(0, lastDisplayIndex + 1);\n  }\n\n  return maskDisplay;\n}\n\n/**\n * Get the next format index right of or at a specified index.\n * If no index exists, returns the rightmost index.\n * @param maskCharData\n * @param index\n */\nexport function getRightFormatIndex(maskCharData: IMaskValue[], index: number): number {\n  for (let i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= index) {\n      return maskCharData[i].displayIndex;\n    }\n  }\n  return maskCharData[maskCharData.length - 1].displayIndex;\n}\n\n/**\n * Get the next format index left of a specified index.\n * If no index exists, returns the leftmost index.\n * @param maskCharData\n * @param index\n */\nexport function getLeftFormatIndex(maskCharData: IMaskValue[], index: number): number {\n  for (let i = maskCharData.length - 1; i >= 0; i--) {\n    if (maskCharData[i].displayIndex < index) {\n      return maskCharData[i].displayIndex;\n    }\n  }\n  return maskCharData[0].displayIndex;\n}\n\n/**\n * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n * @param selectionCount\n */\nexport function clearRange(maskCharData: IMaskValue[], selectionStart: number, selectionCount: number): IMaskValue[] {\n  for (let i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      if (maskCharData[i].displayIndex >= selectionStart + selectionCount) {\n        break;\n      }\n      maskCharData[i].value = undefined;\n    }\n  }\n  return maskCharData;\n}\n\n/**\n * Deletes the input character at or after a specified index and returns the new array of charData\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n */\nexport function clearNext(maskCharData: IMaskValue[], selectionStart: number): IMaskValue[] {\n  for (let i = 0; i < maskCharData.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      maskCharData[i].value = undefined;\n      break;\n    }\n  }\n  return maskCharData;\n}\n\n/**\n * Deletes the input character before a specified index and returns the new array of charData\n * maskCharData is modified inline and also returned.\n * @param maskCharData\n * @param selectionStart\n */\nexport function clearPrev(maskCharData: IMaskValue[], selectionStart: number): IMaskValue[] {\n  for (let i = maskCharData.length - 1; i >= 0; i--) {\n    if (maskCharData[i].displayIndex < selectionStart) {\n      maskCharData[i].value = undefined;\n      break;\n    }\n  }\n  return maskCharData;\n}\n\n/**\n * Deletes all values in maskCharData with a displayIndex that falls inside the specified range.\n * Modifies the maskCharData inplace with the passed string and returns the display index of the\n * next format character after the inserted string.\n * @param maskCharData\n * @param selectionStart\n * @param selectionCount\n * @return The displayIndex of the next format character\n */\nexport function insertString(maskCharData: IMaskValue[], selectionStart: number, newString: string): number {\n  let stringIndex = 0;\n  let nextIndex = 0;\n  let isStringInserted = false;\n\n  // Iterate through _maskCharData finding values with a displayIndex after the specified range start\n  for (let i = 0; i < maskCharData.length && stringIndex < newString.length; i++) {\n    if (maskCharData[i].displayIndex >= selectionStart) {\n      isStringInserted = true;\n      nextIndex = maskCharData[i].displayIndex;\n      // Find the next character in the newString that matches the format\n      while (stringIndex < newString.length) {\n        // If the character matches the format regexp, set the maskCharData to the new character\n        if (maskCharData[i].format.test(newString.charAt(stringIndex))) {\n          maskCharData[i].value = newString.charAt(stringIndex++);\n          // Set the nextIndex to the display index of the next mask format character.\n          if (i + 1 < maskCharData.length) {\n            nextIndex = maskCharData[i + 1].displayIndex;\n          } else {\n            nextIndex++;\n          }\n          break;\n        }\n        stringIndex++;\n      }\n    }\n  }\n\n  return isStringInserted ? nextIndex : selectionStart;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"script"}