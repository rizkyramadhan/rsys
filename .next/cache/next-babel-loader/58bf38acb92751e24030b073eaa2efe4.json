{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar React = require(\"react\");\n\nvar Utilities_1 = require(\"../../Utilities\");\n/**\n * This adds accessibility to Dialog and Panel controls\n */\n\n\nvar Popup =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Popup, _super);\n\n  function Popup(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    _this._disposables = [];\n\n    _this._onKeyDown = function (ev) {\n      switch (ev.which) {\n        case Utilities_1.KeyCodes.escape:\n          if (_this.props.onDismiss) {\n            _this.props.onDismiss(ev);\n\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n\n          break;\n      }\n    };\n\n    _this._onFocus = function () {\n      _this._containsFocus = true;\n    };\n\n    _this._onBlur = function (ev) {\n      if (_this._root.current && _this._root.current.contains(ev.relatedTarget)) {\n        _this._containsFocus = false;\n      }\n    };\n\n    _this._async = new Utilities_1.Async(_this);\n    _this.state = {\n      needsVerticalScrollBar: false\n    };\n    return _this;\n  } // tslint:disable-next-line function-name\n\n\n  Popup.prototype.UNSAFE_componentWillMount = function () {\n    this._originalFocusedElement = Utilities_1.getDocument().activeElement;\n  };\n\n  Popup.prototype.componentDidMount = function () {\n    if (this._root.current) {\n      this._disposables.push(Utilities_1.on(this._root.current, 'focus', this._onFocus, true), Utilities_1.on(this._root.current, 'blur', this._onBlur, true));\n\n      if (Utilities_1.doesElementContainFocus(this._root.current)) {\n        this._containsFocus = true;\n      }\n    }\n\n    this._updateScrollBarAsync();\n  };\n\n  Popup.prototype.componentDidUpdate = function () {\n    this._updateScrollBarAsync();\n\n    this._async.dispose();\n  };\n\n  Popup.prototype.componentWillUnmount = function () {\n    this._disposables.forEach(function (dispose) {\n      return dispose();\n    });\n\n    if (this.props.shouldRestoreFocus && this._originalFocusedElement && this._containsFocus && this._originalFocusedElement !== window) {\n      // This slight delay is required so that we can unwind the stack, let react try to mess with focus, and then\n      // apply the correct focus. Without the setTimeout, we end up focusing the correct thing, and then React wants\n      // to reset the focus back to the thing it thinks should have been focused.\n      if (this._originalFocusedElement) {\n        this._originalFocusedElement.focus();\n      }\n    }\n  };\n\n  Popup.prototype.render = function () {\n    var _a = this.props,\n        role = _a.role,\n        className = _a.className,\n        ariaLabel = _a.ariaLabel,\n        ariaLabelledBy = _a.ariaLabelledBy,\n        ariaDescribedBy = _a.ariaDescribedBy,\n        style = _a.style;\n    return React.createElement(\"div\", tslib_1.__assign({\n      ref: this._root\n    }, Utilities_1.getNativeProps(this.props, Utilities_1.divProperties), {\n      className: className,\n      role: role,\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledBy,\n      \"aria-describedby\": ariaDescribedBy,\n      onKeyDown: this._onKeyDown,\n      style: tslib_1.__assign({\n        overflowY: this.state.needsVerticalScrollBar ? 'scroll' : undefined,\n        outline: 'none'\n      }, style)\n    }), this.props.children);\n  };\n\n  Popup.prototype._updateScrollBarAsync = function () {\n    var _this = this;\n\n    this._async.requestAnimationFrame(function () {\n      _this._getScrollBar();\n    });\n  };\n\n  Popup.prototype._getScrollBar = function () {\n    // If overflowY is overriden, don't waste time calculating whether the scrollbar is necessary.\n    if (this.props.style && this.props.style.overflowY) {\n      return;\n    }\n\n    var needsVerticalScrollBar = false;\n\n    if (this._root && this._root.current && this._root.current.firstElementChild) {\n      // ClientHeight returns the client height of an element rounded to an\n      // integer. On some browsers at different zoom levels this rounding\n      // can generate different results for the root container and child even\n      // though they are the same height. This causes us to show a scroll bar\n      // when not needed. Ideally we would use BoundingClientRect().height\n      // instead however seems that the API is 90% slower than using ClientHeight.\n      // Therefore instead we will calculate the difference between heights and\n      // allow for a 1px difference to still be considered ok and not show the\n      // scroll bar.\n      var rootHeight = this._root.current.clientHeight;\n      var firstChildHeight = this._root.current.firstElementChild.clientHeight;\n\n      if (rootHeight > 0 && firstChildHeight > rootHeight) {\n        needsVerticalScrollBar = firstChildHeight - rootHeight > 1;\n      }\n    }\n\n    if (this.state.needsVerticalScrollBar !== needsVerticalScrollBar) {\n      this.setState({\n        needsVerticalScrollBar: needsVerticalScrollBar\n      });\n    }\n  };\n\n  Popup.defaultProps = {\n    shouldRestoreFocus: true\n  };\n  return Popup;\n}(React.Component);\n\nexports.Popup = Popup;","map":{"version":3,"sources":["components/Popup/Popup.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Async, KeyCodes, divProperties, doesElementContainFocus, getDocument, getNativeProps, on } from '../../Utilities';\nimport { IPopupProps } from './Popup.types';\n\nexport interface IPopupState {\n  needsVerticalScrollBar?: boolean;\n}\n\n/**\n * This adds accessibility to Dialog and Panel controls\n */\nexport class Popup extends React.Component<IPopupProps, IPopupState> {\n  public static defaultProps: IPopupProps = {\n    shouldRestoreFocus: true\n  };\n\n  public _root = React.createRef<HTMLDivElement>();\n  private _disposables: (() => void)[] = [];\n  private _originalFocusedElement: HTMLElement;\n  private _containsFocus: boolean;\n  private _async: Async;\n\n  public constructor(props: IPopupProps) {\n    super(props);\n    this._async = new Async(this);\n    this.state = { needsVerticalScrollBar: false };\n  }\n\n  // tslint:disable-next-line function-name\n  public UNSAFE_componentWillMount(): void {\n    this._originalFocusedElement = getDocument()!.activeElement as HTMLElement;\n  }\n\n  public componentDidMount(): void {\n    if (this._root.current) {\n      this._disposables.push(on(this._root.current, 'focus', this._onFocus, true), on(this._root.current, 'blur', this._onBlur, true));\n      if (doesElementContainFocus(this._root.current)) {\n        this._containsFocus = true;\n      }\n    }\n\n    this._updateScrollBarAsync();\n  }\n\n  public componentDidUpdate() {\n    this._updateScrollBarAsync();\n    this._async.dispose();\n  }\n\n  public componentWillUnmount(): void {\n    this._disposables.forEach((dispose: () => void) => dispose());\n    if (\n      this.props.shouldRestoreFocus &&\n      this._originalFocusedElement &&\n      this._containsFocus &&\n      (this._originalFocusedElement as any) !== window\n    ) {\n      // This slight delay is required so that we can unwind the stack, let react try to mess with focus, and then\n      // apply the correct focus. Without the setTimeout, we end up focusing the correct thing, and then React wants\n      // to reset the focus back to the thing it thinks should have been focused.\n      if (this._originalFocusedElement) {\n        this._originalFocusedElement.focus();\n      }\n    }\n  }\n\n  public render(): JSX.Element {\n    const { role, className, ariaLabel, ariaLabelledBy, ariaDescribedBy, style } = this.props;\n\n    return (\n      <div\n        ref={this._root}\n        {...getNativeProps(this.props, divProperties)}\n        className={className}\n        role={role}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        aria-describedby={ariaDescribedBy}\n        onKeyDown={this._onKeyDown}\n        style={{ overflowY: this.state.needsVerticalScrollBar ? 'scroll' : undefined, outline: 'none', ...style }}\n      >\n        {this.props.children}\n      </div>\n    );\n  }\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    switch (ev.which) {\n      case KeyCodes.escape:\n        if (this.props.onDismiss) {\n          this.props.onDismiss(ev);\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n\n        break;\n    }\n  };\n\n  private _updateScrollBarAsync(): void {\n    this._async.requestAnimationFrame(() => {\n      this._getScrollBar();\n    });\n  }\n\n  private _getScrollBar(): void {\n    // If overflowY is overriden, don't waste time calculating whether the scrollbar is necessary.\n    if (this.props.style && this.props.style.overflowY) {\n      return;\n    }\n\n    let needsVerticalScrollBar = false;\n    if (this._root && this._root.current && this._root.current.firstElementChild) {\n      // ClientHeight returns the client height of an element rounded to an\n      // integer. On some browsers at different zoom levels this rounding\n      // can generate different results for the root container and child even\n      // though they are the same height. This causes us to show a scroll bar\n      // when not needed. Ideally we would use BoundingClientRect().height\n      // instead however seems that the API is 90% slower than using ClientHeight.\n      // Therefore instead we will calculate the difference between heights and\n      // allow for a 1px difference to still be considered ok and not show the\n      // scroll bar.\n      const rootHeight = this._root.current.clientHeight;\n      const firstChildHeight = this._root.current.firstElementChild.clientHeight;\n      if (rootHeight > 0 && firstChildHeight > rootHeight) {\n        needsVerticalScrollBar = firstChildHeight - rootHeight > 1;\n      }\n    }\n    if (this.state.needsVerticalScrollBar !== needsVerticalScrollBar) {\n      this.setState({\n        needsVerticalScrollBar: needsVerticalScrollBar\n      });\n    }\n  }\n\n  private _onFocus = (): void => {\n    this._containsFocus = true;\n  };\n\n  private _onBlur = (ev: FocusEvent): void => {\n    if (this._root.current && this._root.current.contains(ev.relatedTarget as HTMLElement)) {\n      this._containsFocus = false;\n    }\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"script"}