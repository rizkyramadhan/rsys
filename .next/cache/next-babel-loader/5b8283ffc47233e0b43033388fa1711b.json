{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { arraysEqual, replaceElement, findIndex, find, EventGroup, getId } from '../../Utilities';\nimport { KeytipEvents } from '../../utilities/keytips/KeytipConstants';\n/**\n * This class is responsible for handling registering, updating, and unregistering of keytips\n */\n\nvar KeytipManager =\n/** @class */\nfunction () {\n  function KeytipManager() {\n    this.keytips = [];\n    this.persistedKeytips = []; // This is (and should be) updated and kept in sync\n    // with the inKeytipMode in KeytipLayer.\n\n    this.inKeytipMode = false; // Boolean that gets checked before entering keytip mode by the KeytipLayer\n    // Used for an override in special cases (e.g. Disable entering keytip mode when a modal is shown)\n\n    this.shouldEnterKeytipMode = true;\n  }\n  /**\n   * Static function to get singleton KeytipManager instance\n   *\n   * @returns {KeytipManager} Singleton KeytipManager instance\n   */\n\n\n  KeytipManager.getInstance = function () {\n    return this._instance;\n  };\n  /**\n   * Registers a keytip\n   *\n   * @param keytipProps - Keytip to register\n   * @param persisted - T/F if this keytip should be persisted, default is false\n   * @returns {string} Unique ID for this keytip\n   */\n\n\n  KeytipManager.prototype.register = function (keytipProps, persisted) {\n    if (persisted === void 0) {\n      persisted = false;\n    }\n\n    var props = keytipProps;\n\n    if (!persisted) {\n      // Add the overflowSetSequence if necessary\n      props = this.addParentOverflow(keytipProps);\n    } // Create a unique keytip\n\n\n    var uniqueKeytip = this._getUniqueKtp(props); // Add to array\n\n\n    persisted ? this.persistedKeytips.push(uniqueKeytip) : this.keytips.push(uniqueKeytip);\n    var event = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;\n    EventGroup.raise(this, event, {\n      keytip: props,\n      uniqueID: uniqueKeytip.uniqueID\n    });\n    return uniqueKeytip.uniqueID;\n  };\n  /**\n   * Update a keytip\n   *\n   * @param keytipProps - Keytip to update\n   * @param uniqueID - Unique ID of this keytip\n   */\n\n\n  KeytipManager.prototype.update = function (keytipProps, uniqueID) {\n    var newKeytipProps = this.addParentOverflow(keytipProps);\n\n    var uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);\n\n    var keytipIndex = findIndex(this.keytips, function (ktp) {\n      return ktp.uniqueID === uniqueID;\n    });\n\n    if (keytipIndex >= 0) {\n      // Update everything except 'visible'\n      uniqueKeytip.keytip.visible = this.keytips[keytipIndex].keytip.visible; // Update keytip in this.keytips\n\n      this.keytips = replaceElement(this.keytips, uniqueKeytip, keytipIndex); // Raise event\n\n      EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {\n        keytip: uniqueKeytip.keytip,\n        uniqueID: uniqueKeytip.uniqueID\n      });\n    }\n  };\n  /**\n   * Unregisters a keytip\n   *\n   * @param keytipToRemove - IKeytipProps of the keytip to remove\n   * @param uniqueID - Unique ID of this keytip\n   * @param persisted - T/F if this keytip should be persisted, default is false\n   */\n\n\n  KeytipManager.prototype.unregister = function (keytipToRemove, uniqueID, persisted) {\n    if (persisted === void 0) {\n      persisted = false;\n    }\n\n    if (persisted) {\n      // Remove keytip from this.persistedKeytips\n      this.persistedKeytips = this.persistedKeytips.filter(function (uniqueKtp) {\n        return uniqueKtp.uniqueID !== uniqueID;\n      });\n    } else {\n      // Remove keytip from this.keytips\n      this.keytips = this.keytips.filter(function (uniqueKtp) {\n        return uniqueKtp.uniqueID !== uniqueID;\n      });\n    }\n\n    var event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED;\n    EventGroup.raise(this, event, {\n      keytip: keytipToRemove,\n      uniqueID: uniqueID\n    });\n  };\n  /**\n   * Manual call to enter keytip mode\n   */\n\n\n  KeytipManager.prototype.enterKeytipMode = function () {\n    EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);\n  };\n  /**\n   * Manual call to exit keytip mode\n   */\n\n\n  KeytipManager.prototype.exitKeytipMode = function () {\n    EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);\n  };\n  /**\n   * Gets all IKeytipProps from this.keytips\n   *\n   * @returns {IKeytipProps[]} All keytips stored in the manager\n   */\n\n\n  KeytipManager.prototype.getKeytips = function () {\n    return this.keytips.map(function (uniqueKeytip) {\n      return uniqueKeytip.keytip;\n    });\n  };\n  /**\n   * Adds the overflowSetSequence to the keytipProps if its parent keytip also has it\n   *\n   * @param keytipProps - Keytip props to add overflowSetSequence to if necessary\n   * @returns {IKeytipProps} - Modified keytip props, if needed to be modified\n   */\n\n\n  KeytipManager.prototype.addParentOverflow = function (keytipProps) {\n    var fullSequence = keytipProps.keySequences.slice();\n    fullSequence.pop();\n\n    if (fullSequence.length !== 0) {\n      var parentKeytip = find(this.getKeytips(), function (keytip) {\n        return arraysEqual(fullSequence, keytip.keySequences);\n      });\n\n      if (parentKeytip && parentKeytip.overflowSetSequence) {\n        return tslib_1.__assign({}, keytipProps, {\n          overflowSetSequence: parentKeytip.overflowSetSequence\n        });\n      }\n    }\n\n    return keytipProps;\n  };\n  /**\n   * Public function to bind for overflow items that have a submenu\n   *\n   * @param overflowButtonSequences\n   * @param keytipSequences\n   */\n\n\n  KeytipManager.prototype.menuExecute = function (overflowButtonSequences, keytipSequences) {\n    EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {\n      overflowButtonSequences: overflowButtonSequences,\n      keytipSequences: keytipSequences\n    });\n  };\n  /**\n   * Creates an IUniqueKeytip object\n   *\n   * @param keytipProps - IKeytipProps\n   * @param uniqueID - Unique ID, will default to the next unique ID if not passed\n   * @returns {IUniqueKeytip} IUniqueKeytip object\n   */\n\n\n  KeytipManager.prototype._getUniqueKtp = function (keytipProps, uniqueID) {\n    if (uniqueID === void 0) {\n      uniqueID = getId();\n    }\n\n    return {\n      keytip: tslib_1.__assign({}, keytipProps),\n      uniqueID: uniqueID\n    };\n  };\n\n  KeytipManager._instance = new KeytipManager();\n  return KeytipManager;\n}();\n\nexport { KeytipManager };","map":{"version":3,"sources":["utilities/keytips/KeytipManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { IKeytipProps } from '../../Keytip';\nimport { arraysEqual, replaceElement, findIndex, find, EventGroup, getId } from '../../Utilities';\nimport { KeytipEvents } from '../../utilities/keytips/KeytipConstants';\n\nexport interface IUniqueKeytip {\n  uniqueID: string;\n  keytip: IKeytipProps;\n}\n\n/**\n * This class is responsible for handling registering, updating, and unregistering of keytips\n */\nexport class KeytipManager {\n  private static _instance: KeytipManager = new KeytipManager();\n\n  public keytips: IUniqueKeytip[] = [];\n  public persistedKeytips: IUniqueKeytip[] = [];\n\n  // This is (and should be) updated and kept in sync\n  // with the inKeytipMode in KeytipLayer.\n  public inKeytipMode = false;\n\n  // Boolean that gets checked before entering keytip mode by the KeytipLayer\n  // Used for an override in special cases (e.g. Disable entering keytip mode when a modal is shown)\n  public shouldEnterKeytipMode = true;\n\n  /**\n   * Static function to get singleton KeytipManager instance\n   *\n   * @returns {KeytipManager} Singleton KeytipManager instance\n   */\n  public static getInstance(): KeytipManager {\n    return this._instance;\n  }\n\n  /**\n   * Registers a keytip\n   *\n   * @param keytipProps - Keytip to register\n   * @param persisted - T/F if this keytip should be persisted, default is false\n   * @returns {string} Unique ID for this keytip\n   */\n  public register(keytipProps: IKeytipProps, persisted: boolean = false): string {\n    let props: IKeytipProps = keytipProps;\n    if (!persisted) {\n      // Add the overflowSetSequence if necessary\n      props = this.addParentOverflow(keytipProps);\n    }\n    // Create a unique keytip\n    const uniqueKeytip: IUniqueKeytip = this._getUniqueKtp(props);\n    // Add to array\n    persisted ? this.persistedKeytips.push(uniqueKeytip) : this.keytips.push(uniqueKeytip);\n\n    const event = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;\n    EventGroup.raise(this, event, {\n      keytip: props,\n      uniqueID: uniqueKeytip.uniqueID\n    });\n\n    return uniqueKeytip.uniqueID;\n  }\n\n  /**\n   * Update a keytip\n   *\n   * @param keytipProps - Keytip to update\n   * @param uniqueID - Unique ID of this keytip\n   */\n  public update(keytipProps: IKeytipProps, uniqueID: string): void {\n    const newKeytipProps = this.addParentOverflow(keytipProps);\n    const uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);\n    const keytipIndex = findIndex(this.keytips, (ktp: IUniqueKeytip) => {\n      return ktp.uniqueID === uniqueID;\n    });\n    if (keytipIndex >= 0) {\n      // Update everything except 'visible'\n      uniqueKeytip.keytip.visible = this.keytips[keytipIndex].keytip.visible;\n      // Update keytip in this.keytips\n      this.keytips = replaceElement(this.keytips, uniqueKeytip, keytipIndex);\n      // Raise event\n      EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {\n        keytip: uniqueKeytip.keytip,\n        uniqueID: uniqueKeytip.uniqueID\n      });\n    }\n  }\n\n  /**\n   * Unregisters a keytip\n   *\n   * @param keytipToRemove - IKeytipProps of the keytip to remove\n   * @param uniqueID - Unique ID of this keytip\n   * @param persisted - T/F if this keytip should be persisted, default is false\n   */\n  public unregister(keytipToRemove: IKeytipProps, uniqueID: string, persisted: boolean = false): void {\n    if (persisted) {\n      // Remove keytip from this.persistedKeytips\n      this.persistedKeytips = this.persistedKeytips.filter((uniqueKtp: IUniqueKeytip) => {\n        return uniqueKtp.uniqueID !== uniqueID;\n      });\n    } else {\n      // Remove keytip from this.keytips\n      this.keytips = this.keytips.filter((uniqueKtp: IUniqueKeytip) => {\n        return uniqueKtp.uniqueID !== uniqueID;\n      });\n    }\n\n    const event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED;\n    EventGroup.raise(this, event, {\n      keytip: keytipToRemove,\n      uniqueID: uniqueID\n    });\n  }\n\n  /**\n   * Manual call to enter keytip mode\n   */\n  public enterKeytipMode(): void {\n    EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);\n  }\n\n  /**\n   * Manual call to exit keytip mode\n   */\n  public exitKeytipMode(): void {\n    EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);\n  }\n\n  /**\n   * Gets all IKeytipProps from this.keytips\n   *\n   * @returns {IKeytipProps[]} All keytips stored in the manager\n   */\n  public getKeytips(): IKeytipProps[] {\n    return this.keytips.map((uniqueKeytip: IUniqueKeytip) => {\n      return uniqueKeytip.keytip;\n    });\n  }\n\n  /**\n   * Adds the overflowSetSequence to the keytipProps if its parent keytip also has it\n   *\n   * @param keytipProps - Keytip props to add overflowSetSequence to if necessary\n   * @returns {IKeytipProps} - Modified keytip props, if needed to be modified\n   */\n  public addParentOverflow(keytipProps: IKeytipProps): IKeytipProps {\n    const fullSequence = [...keytipProps.keySequences];\n    fullSequence.pop();\n    if (fullSequence.length !== 0) {\n      const parentKeytip = find(this.getKeytips(), (keytip: IKeytipProps) => {\n        return arraysEqual(fullSequence, keytip.keySequences);\n      });\n      if (parentKeytip && parentKeytip.overflowSetSequence) {\n        return {\n          ...keytipProps,\n          overflowSetSequence: parentKeytip.overflowSetSequence\n        };\n      }\n    }\n    return keytipProps;\n  }\n\n  /**\n   * Public function to bind for overflow items that have a submenu\n   *\n   * @param overflowButtonSequences\n   * @param keytipSequences\n   */\n  public menuExecute(overflowButtonSequences: string[], keytipSequences: string[]) {\n    EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {\n      overflowButtonSequences,\n      keytipSequences\n    });\n  }\n\n  /**\n   * Creates an IUniqueKeytip object\n   *\n   * @param keytipProps - IKeytipProps\n   * @param uniqueID - Unique ID, will default to the next unique ID if not passed\n   * @returns {IUniqueKeytip} IUniqueKeytip object\n   */\n  private _getUniqueKtp(keytipProps: IKeytipProps, uniqueID: string = getId()): IUniqueKeytip {\n    return { keytip: { ...keytipProps }, uniqueID };\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}