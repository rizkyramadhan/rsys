{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, initializeComponentRef } from '../../Utilities';\nimport { TextField } from '../../TextField';\nimport { ColorRectangle } from './ColorRectangle/ColorRectangle';\nimport { ColorSlider } from './ColorSlider/ColorSlider'; // These imports are separated to help with bundling\n\nimport { MAX_COLOR_ALPHA, MAX_COLOR_HUE, MAX_COLOR_RGB, MAX_HEX_LENGTH, MAX_RGBA_LENGTH, MIN_HEX_LENGTH, MIN_RGBA_LENGTH, HEX_REGEX, RGBA_REGEX } from '../../utilities/color/consts';\nimport { getColorFromString } from '../../utilities/color/getColorFromString';\nimport { getColorFromRGBA } from '../../utilities/color/getColorFromRGBA';\nimport { updateA } from '../../utilities/color/updateA';\nimport { updateH } from '../../utilities/color/updateH';\nimport { correctRGB } from '../../utilities/color/correctRGB';\nimport { correctHex } from '../../utilities/color/correctHex';\nvar getClassNames = classNamesFunction();\nvar colorComponents = ['hex', 'r', 'g', 'b', 'a'];\n/**\n * {@docCategory ColorPicker}\n */\n\nvar ColorPickerBase =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ColorPickerBase, _super);\n\n  function ColorPickerBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._onSVChanged = function (ev, color) {\n      _this._updateColor(ev, color);\n    };\n\n    _this._onHChanged = function (ev, h) {\n      _this._updateColor(ev, updateH(_this.state.color, h));\n    };\n\n    _this._onAChanged = function (ev, a) {\n      _this._updateColor(ev, updateA(_this.state.color, Math.round(a)));\n    };\n\n    _this._onBlur = function (event) {\n      var _a;\n\n      var _b = _this.state,\n          color = _b.color,\n          editingColor = _b.editingColor;\n\n      if (!editingColor) {\n        return;\n      } // If there was an intermediate incorrect value (such as too large or empty), correct it.\n\n\n      var value = editingColor.value,\n          component = editingColor.component;\n      var isHex = component === 'hex';\n      var minLength = isHex ? MIN_HEX_LENGTH : MIN_RGBA_LENGTH;\n\n      if (value.length >= minLength && (isHex || !isNaN(Number(value)))) {\n        // Real value. Clamp to appropriate length (hex) or range (rgba).\n        var newColor = void 0;\n\n        if (isHex) {\n          newColor = getColorFromString('#' + correctHex(value));\n        } else {\n          newColor = getColorFromRGBA(correctRGB(tslib_1.__assign({}, color, (_a = {}, _a[component] = Number(value), _a))));\n        } // Update state and call onChange\n\n\n        _this._updateColor(event, newColor);\n      } else {\n        // Intermediate value was an empty string, too short (hex only), or just . (alpha only).\n        // Just clear the intermediate state and revert to the previous value.\n        _this.setState({\n          editingColor: undefined\n        });\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this.state = {\n      color: _getColorFromProps(props) || getColorFromString('#ffffff')\n    };\n    _this._textChangeHandlers = {};\n\n    for (var _i = 0, colorComponents_1 = colorComponents; _i < colorComponents_1.length; _i++) {\n      var component = colorComponents_1[_i];\n      _this._textChangeHandlers[component] = _this._onTextChange.bind(_this, component);\n    }\n\n    _this._textLabels = {\n      r: props.redLabel,\n      g: props.greenLabel,\n      b: props.blueLabel,\n      a: props.alphaLabel,\n      hex: props.hexLabel\n    };\n    return _this;\n  }\n\n  _Object$defineProperty(ColorPickerBase.prototype, \"color\", {\n    get: function get() {\n      return this.state.color;\n    },\n    enumerable: true,\n    configurable: true\n  }); // tslint:disable-next-line function-name\n\n\n  ColorPickerBase.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    var color = _getColorFromProps(newProps);\n\n    if (color) {\n      this._updateColor(undefined, color);\n    }\n  };\n\n  ColorPickerBase.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var theme = props.theme,\n        className = props.className,\n        styles = props.styles;\n    var color = this.state.color;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className\n    });\n    return React.createElement(\"div\", {\n      className: classNames.root\n    }, React.createElement(\"div\", {\n      className: classNames.panel\n    }, React.createElement(ColorRectangle, {\n      color: color,\n      onChange: this._onSVChanged\n    }), React.createElement(ColorSlider, {\n      className: \"is-hue\",\n      minValue: 0,\n      maxValue: MAX_COLOR_HUE,\n      value: color.h,\n      onChange: this._onHChanged\n    }), !props.alphaSliderHidden && React.createElement(ColorSlider, {\n      className: \"is-alpha\",\n      isAlpha: true,\n      overlayStyle: {\n        background: \"linear-gradient(to right, transparent 0, #\" + color.hex + \" 100%)\"\n      },\n      minValue: 0,\n      maxValue: MAX_COLOR_ALPHA,\n      value: color.a,\n      onChange: this._onAChanged\n    }), React.createElement(\"table\", {\n      className: classNames.table,\n      cellPadding: \"0\",\n      cellSpacing: \"0\"\n    }, React.createElement(\"thead\", null, React.createElement(\"tr\", {\n      className: classNames.tableHeader\n    }, React.createElement(\"td\", {\n      className: classNames.tableHexCell\n    }, props.hexLabel), React.createElement(\"td\", null, props.redLabel), React.createElement(\"td\", null, props.greenLabel), React.createElement(\"td\", null, props.blueLabel), !props.alphaSliderHidden && React.createElement(\"td\", null, props.alphaLabel))), React.createElement(\"tbody\", null, React.createElement(\"tr\", null, colorComponents.map(function (comp) {\n      if (comp === 'a' && props.alphaSliderHidden) {\n        return null;\n      }\n\n      return React.createElement(\"td\", {\n        key: comp,\n        style: comp === 'hex' ? undefined : {\n          width: '18%'\n        }\n      }, React.createElement(TextField, {\n        className: classNames.input,\n        onChange: _this._textChangeHandlers[comp],\n        onBlur: _this._onBlur,\n        value: _this._getDisplayValue(comp),\n        spellCheck: false,\n        ariaLabel: _this._textLabels[comp]\n      }));\n    }))))));\n  };\n\n  ColorPickerBase.prototype._getDisplayValue = function (component) {\n    var _a = this.state,\n        color = _a.color,\n        editingColor = _a.editingColor;\n\n    if (editingColor && editingColor.component === component) {\n      return editingColor.value;\n    }\n\n    if (color[component] === null || color[component] === undefined) {\n      return '';\n    } else {\n      return String(color[component]);\n    }\n  };\n\n  ColorPickerBase.prototype._onTextChange = function (component, event, newValue) {\n    var _a;\n\n    var color = this.state.color;\n    var isHex = component === 'hex';\n    var isAlpha = component === 'a';\n    newValue = (newValue || '').substr(0, isHex ? MAX_HEX_LENGTH : MAX_RGBA_LENGTH); // Ignore what the user typed if it contains invalid characters\n\n    var validCharsRegex = isHex ? HEX_REGEX : RGBA_REGEX;\n\n    if (!validCharsRegex.test(newValue)) {\n      return;\n    } // Determine if the entry is valid (different methods for hex, alpha, and RGB)\n\n\n    var isValid;\n\n    if (newValue === '') {\n      // Empty string is obviously not valid\n      isValid = false;\n    } else if (isHex) {\n      // Technically hex values of length 3 are also valid, but committing the value here would\n      // cause it to be automatically converted to a value of length 6, which may not be what the\n      // user wanted if they're not finished typing. (Values of length 3 will be committed on blur.)\n      isValid = newValue.length === MAX_HEX_LENGTH;\n    } else if (isAlpha) {\n      isValid = Number(newValue) <= MAX_COLOR_ALPHA;\n    } else {\n      isValid = Number(newValue) <= MAX_COLOR_RGB;\n    }\n\n    if (!isValid) {\n      // If the new value is an empty string or other invalid value, save that to display.\n      // (if the user still hasn't entered anything on blur, the last value is restored)\n      this.setState({\n        editingColor: {\n          component: component,\n          value: newValue\n        }\n      });\n    } else if (String(color[component]) === newValue) {\n      // If the new value is the same as the current value, mostly ignore it.\n      // Exception is that if the user was previously editing the value (but hadn't yet entered\n      // a new valid value), we should clear the intermediate value.\n      if (this.state.editingColor) {\n        this.setState({\n          editingColor: undefined\n        });\n      }\n    } else {\n      // Should be a valid color. Update the value.\n      var newColor = isHex ? getColorFromString('#' + newValue) : getColorFromRGBA(tslib_1.__assign({}, color, (_a = {}, _a[component] = Number(newValue), _a)));\n\n      this._updateColor(event, newColor);\n    }\n  };\n  /**\n   * Update the displayed color and call change handlers if appropriate.\n   * @param ev - Event if call was triggered by an event (undefined if triggered by props change)\n   * @param newColor - Updated color\n   */\n\n\n  ColorPickerBase.prototype._updateColor = function (ev, newColor) {\n    var _this = this;\n\n    if (!newColor) {\n      return;\n    }\n\n    var _a = this.state,\n        color = _a.color,\n        editingColor = _a.editingColor;\n    var isDifferentColor = newColor.h !== color.h || newColor.str !== color.str;\n\n    if (isDifferentColor || editingColor) {\n      this.setState({\n        color: newColor,\n        editingColor: undefined\n      }, function () {\n        if (ev && _this.props.onChange) {\n          _this.props.onChange(ev, newColor);\n        }\n      });\n    }\n  };\n\n  ColorPickerBase.defaultProps = {\n    hexLabel: 'Hex',\n    redLabel: 'Red',\n    greenLabel: 'Green',\n    blueLabel: 'Blue',\n    alphaLabel: 'Alpha'\n  };\n  return ColorPickerBase;\n}(React.Component);\n\nexport { ColorPickerBase };\n\nfunction _getColorFromProps(props) {\n  var color = props.color;\n  return typeof color === 'string' ? getColorFromString(color) : color;\n}","map":{"version":3,"sources":["components/ColorPicker/ColorPicker.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { classNamesFunction, initializeComponentRef } from '../../Utilities';\nimport { IColorPickerProps, IColorPickerStyleProps, IColorPickerStyles, IColorPicker } from './ColorPicker.types';\nimport { TextField } from '../../TextField';\nimport { ColorRectangle } from './ColorRectangle/ColorRectangle';\nimport { ColorSlider } from './ColorSlider/ColorSlider';\n// These imports are separated to help with bundling\nimport {\n  MAX_COLOR_ALPHA,\n  MAX_COLOR_HUE,\n  MAX_COLOR_RGB,\n  MAX_HEX_LENGTH,\n  MAX_RGBA_LENGTH,\n  MIN_HEX_LENGTH,\n  MIN_RGBA_LENGTH,\n  HEX_REGEX,\n  RGBA_REGEX\n} from '../../utilities/color/consts';\nimport { IColor, IRGB } from '../../utilities/color/interfaces';\nimport { getColorFromString } from '../../utilities/color/getColorFromString';\nimport { getColorFromRGBA } from '../../utilities/color/getColorFromRGBA';\nimport { updateA } from '../../utilities/color/updateA';\nimport { updateH } from '../../utilities/color/updateH';\nimport { correctRGB } from '../../utilities/color/correctRGB';\nimport { correctHex } from '../../utilities/color/correctHex';\n\ntype IRGBHex = Pick<IColor, 'r' | 'g' | 'b' | 'a' | 'hex'>;\n\nexport interface IColorPickerState {\n  color: IColor;\n  editingColor?: {\n    component: keyof IRGBHex;\n    value: string;\n  };\n}\n\nconst getClassNames = classNamesFunction<IColorPickerStyleProps, IColorPickerStyles>();\n\nconst colorComponents: Array<keyof IRGBHex> = ['hex', 'r', 'g', 'b', 'a'];\n\n/**\n * {@docCategory ColorPicker}\n */\nexport class ColorPickerBase extends React.Component<IColorPickerProps, IColorPickerState> implements IColorPicker {\n  public static defaultProps = {\n    hexLabel: 'Hex',\n    redLabel: 'Red',\n    greenLabel: 'Green',\n    blueLabel: 'Blue',\n    alphaLabel: 'Alpha'\n  };\n\n  private _textChangeHandlers: {\n    [K in keyof IRGBHex]: (event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>, newValue?: string) => void\n  };\n  private _textLabels: { [K in keyof IRGBHex]?: string };\n\n  constructor(props: IColorPickerProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    this.state = {\n      color: _getColorFromProps(props) || getColorFromString('#ffffff')!\n    };\n\n    this._textChangeHandlers = {} as any;\n    for (const component of colorComponents) {\n      this._textChangeHandlers[component] = this._onTextChange.bind(this, component);\n    }\n    this._textLabels = {\n      r: props.redLabel,\n      g: props.greenLabel,\n      b: props.blueLabel,\n      a: props.alphaLabel,\n      hex: props.hexLabel\n    };\n  }\n\n  public get color(): IColor {\n    return this.state.color;\n  }\n\n  // tslint:disable-next-line function-name\n  public UNSAFE_componentWillReceiveProps(newProps: IColorPickerProps): void {\n    const color = _getColorFromProps(newProps);\n    if (color) {\n      this._updateColor(undefined, color);\n    }\n  }\n\n  public render(): JSX.Element {\n    const props = this.props;\n    const { theme, className, styles } = props;\n    const { color } = this.state;\n\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className\n    });\n\n    return (\n      <div className={classNames.root}>\n        <div className={classNames.panel}>\n          <ColorRectangle color={color} onChange={this._onSVChanged} />\n          <ColorSlider className=\"is-hue\" minValue={0} maxValue={MAX_COLOR_HUE} value={color.h} onChange={this._onHChanged} />\n          {!props.alphaSliderHidden && (\n            <ColorSlider\n              className=\"is-alpha\"\n              isAlpha\n              overlayStyle={{ background: `linear-gradient(to right, transparent 0, #${color.hex} 100%)` }}\n              minValue={0}\n              maxValue={MAX_COLOR_ALPHA}\n              value={color.a}\n              onChange={this._onAChanged}\n            />\n          )}\n          <table className={classNames.table} cellPadding=\"0\" cellSpacing=\"0\">\n            <thead>\n              <tr className={classNames.tableHeader}>\n                <td className={classNames.tableHexCell}>{props.hexLabel}</td>\n                <td>{props.redLabel}</td>\n                <td>{props.greenLabel}</td>\n                <td>{props.blueLabel}</td>\n                {!props.alphaSliderHidden && <td>{props.alphaLabel}</td>}\n              </tr>\n            </thead>\n            <tbody>\n              <tr>\n                {...colorComponents.map((comp: keyof IRGBHex) => {\n                  if (comp === 'a' && props.alphaSliderHidden) {\n                    return null;\n                  }\n                  return (\n                    <td key={comp} style={comp === 'hex' ? undefined : { width: '18%' }}>\n                      <TextField\n                        className={classNames.input}\n                        onChange={this._textChangeHandlers[comp]}\n                        onBlur={this._onBlur}\n                        value={this._getDisplayValue(comp)}\n                        spellCheck={false}\n                        ariaLabel={this._textLabels[comp]}\n                      />\n                    </td>\n                  );\n                })}\n              </tr>\n            </tbody>\n          </table>\n        </div>\n      </div>\n    );\n  }\n\n  private _getDisplayValue(component: keyof IColor): string {\n    const { color, editingColor } = this.state;\n    if (editingColor && editingColor.component === component) {\n      return editingColor.value;\n    }\n    if (color[component] === null || color[component] === undefined) {\n      return '';\n    } else {\n      return String(color[component]);\n    }\n  }\n\n  private _onSVChanged = (ev: React.MouseEvent<HTMLElement>, color: IColor): void => {\n    this._updateColor(ev, color);\n  };\n\n  private _onHChanged = (ev: React.MouseEvent<HTMLElement>, h: number): void => {\n    this._updateColor(ev, updateH(this.state.color, h));\n  };\n\n  private _onAChanged = (ev: React.MouseEvent<HTMLElement>, a: number): void => {\n    this._updateColor(ev, updateA(this.state.color, Math.round(a)));\n  };\n\n  private _onTextChange(component: keyof IRGBHex, event: React.FormEvent<HTMLInputElement>, newValue?: string): void {\n    const color = this.state.color;\n    const isHex = component === 'hex';\n    const isAlpha = component === 'a';\n    newValue = (newValue || '').substr(0, isHex ? MAX_HEX_LENGTH : MAX_RGBA_LENGTH);\n\n    // Ignore what the user typed if it contains invalid characters\n    const validCharsRegex = isHex ? HEX_REGEX : RGBA_REGEX;\n    if (!validCharsRegex.test(newValue)) {\n      return;\n    }\n\n    // Determine if the entry is valid (different methods for hex, alpha, and RGB)\n    let isValid: boolean;\n    if (newValue === '') {\n      // Empty string is obviously not valid\n      isValid = false;\n    } else if (isHex) {\n      // Technically hex values of length 3 are also valid, but committing the value here would\n      // cause it to be automatically converted to a value of length 6, which may not be what the\n      // user wanted if they're not finished typing. (Values of length 3 will be committed on blur.)\n      isValid = newValue.length === MAX_HEX_LENGTH;\n    } else if (isAlpha) {\n      isValid = Number(newValue) <= MAX_COLOR_ALPHA;\n    } else {\n      isValid = Number(newValue) <= MAX_COLOR_RGB;\n    }\n\n    if (!isValid) {\n      // If the new value is an empty string or other invalid value, save that to display.\n      // (if the user still hasn't entered anything on blur, the last value is restored)\n      this.setState({ editingColor: { component, value: newValue } });\n    } else if (String(color[component]) === newValue) {\n      // If the new value is the same as the current value, mostly ignore it.\n      // Exception is that if the user was previously editing the value (but hadn't yet entered\n      // a new valid value), we should clear the intermediate value.\n      if (this.state.editingColor) {\n        this.setState({ editingColor: undefined });\n      }\n    } else {\n      // Should be a valid color. Update the value.\n      const newColor = isHex\n        ? getColorFromString('#' + newValue)\n        : getColorFromRGBA({\n            ...color,\n            // Overwrite whichever key is being updated with the new value\n            [component]: Number(newValue)\n          });\n      this._updateColor(event, newColor);\n    }\n  }\n\n  private _onBlur = (event: React.FocusEvent<HTMLInputElement>) => {\n    const { color, editingColor } = this.state;\n    if (!editingColor) {\n      return;\n    }\n\n    // If there was an intermediate incorrect value (such as too large or empty), correct it.\n    const { value, component } = editingColor;\n    const isHex = component === 'hex';\n    const minLength = isHex ? MIN_HEX_LENGTH : MIN_RGBA_LENGTH;\n    if (value.length >= minLength && (isHex || !isNaN(Number(value)))) {\n      // Real value. Clamp to appropriate length (hex) or range (rgba).\n      let newColor: IColor | undefined;\n      if (isHex) {\n        newColor = getColorFromString('#' + correctHex(value));\n      } else {\n        newColor = getColorFromRGBA(\n          correctRGB({\n            ...color,\n            [component]: Number(value)\n          } as IRGB)\n        );\n      }\n\n      // Update state and call onChange\n      this._updateColor(event, newColor);\n    } else {\n      // Intermediate value was an empty string, too short (hex only), or just . (alpha only).\n      // Just clear the intermediate state and revert to the previous value.\n      this.setState({ editingColor: undefined });\n    }\n  };\n\n  /**\n   * Update the displayed color and call change handlers if appropriate.\n   * @param ev - Event if call was triggered by an event (undefined if triggered by props change)\n   * @param newColor - Updated color\n   */\n  private _updateColor(ev: React.SyntheticEvent<HTMLElement> | undefined, newColor: IColor | undefined): void {\n    if (!newColor) {\n      return;\n    }\n\n    const { color, editingColor } = this.state;\n    const isDifferentColor = newColor.h !== color.h || newColor.str !== color.str;\n\n    if (isDifferentColor || editingColor) {\n      this.setState({ color: newColor, editingColor: undefined }, () => {\n        if (ev && this.props.onChange) {\n          this.props.onChange(ev, newColor);\n        }\n      });\n    }\n  }\n}\n\nfunction _getColorFromProps(props: IColorPickerProps): IColor | undefined {\n  const { color } = props;\n  return typeof color === 'string' ? getColorFromString(color) : color;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}