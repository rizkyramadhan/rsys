{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { BaseComponent, anchorProperties, assign, buttonProperties, getId, getNativeProps, KeyCodes, css, mergeAriaAttributeValues, portalContainsElement } from '../../Utilities';\nimport { Icon, FontIcon, ImageIcon } from '../../Icon';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { ContextualMenu } from '../../ContextualMenu';\nimport { getBaseButtonClassNames } from './BaseButton.classNames';\nimport { getClassNames as getBaseSplitButtonClassNames } from './SplitButton/SplitButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nimport { memoizeFunction, nullRender } from '@uifabric/utilities';\nvar TouchIdleDelay = 500;\n/* ms */\n\n/**\n * {@docCategory Button}\n */\n\nvar BaseButton =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(BaseButton, _super);\n\n  function BaseButton(props, rootClassName) {\n    var _this = _super.call(this, props) || this;\n\n    _this._buttonElement = React.createRef();\n    _this._splitButtonContainer = React.createRef();\n    _this._renderedPersistentMenu = false;\n    _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function (keytipProps) {\n      return tslib_1.__assign({}, keytipProps, {\n        hasMenu: true\n      });\n    });\n\n    _this._onRenderIcon = function (buttonProps, defaultRender) {\n      var iconProps = _this.props.iconProps;\n\n      if (iconProps && (iconProps.iconName !== undefined || iconProps.imageProps)) {\n        var className = iconProps.className,\n            imageProps = iconProps.imageProps,\n            rest = tslib_1.__rest(iconProps, [\"className\", \"imageProps\"]); // If the styles prop is specified as part of iconProps, fall back to regular Icon as FontIcon and ImageIcon do not have such prop.\n\n\n        if (iconProps.styles) {\n          return React.createElement(Icon, tslib_1.__assign({\n            className: css(_this._classNames.icon, className),\n            imageProps: imageProps\n          }, rest));\n        }\n\n        if (iconProps.iconName) {\n          return React.createElement(FontIcon, tslib_1.__assign({\n            className: css(_this._classNames.icon, className)\n          }, rest));\n        }\n\n        if (imageProps) {\n          return React.createElement(ImageIcon, tslib_1.__assign({\n            className: css(_this._classNames.icon, className),\n            imageProps: imageProps\n          }, rest));\n        }\n      }\n\n      return null;\n    };\n\n    _this._onRenderTextContents = function () {\n      var _a = _this.props,\n          text = _a.text,\n          children = _a.children,\n          _b = _a.secondaryText,\n          secondaryText = _b === void 0 ? _this.props.description : _b,\n          _c = _a.onRenderText,\n          onRenderText = _c === void 0 ? _this._onRenderText : _c,\n          _d = _a.onRenderDescription,\n          onRenderDescription = _d === void 0 ? _this._onRenderDescription : _d;\n\n      if (text || typeof children === 'string' || secondaryText) {\n        return React.createElement(\"div\", {\n          className: _this._classNames.textContainer\n        }, onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription));\n      }\n\n      return [onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription)];\n    };\n\n    _this._onRenderText = function () {\n      var text = _this.props.text;\n      var children = _this.props.children; // For backwards compat, we should continue to take in the text content from children.\n\n      if (text === undefined && typeof children === 'string') {\n        text = children;\n      }\n\n      if (_this._hasText()) {\n        return React.createElement(\"div\", {\n          key: _this._labelId,\n          className: _this._classNames.label,\n          id: _this._labelId\n        }, text);\n      }\n\n      return null;\n    };\n\n    _this._onRenderChildren = function () {\n      var children = _this.props.children; // If children is just a string, either it or the text will be rendered via onRenderLabel\n      // If children is another component, it will be rendered after text\n\n      if (typeof children === 'string') {\n        return null;\n      }\n\n      return children;\n    };\n\n    _this._onRenderDescription = function (props) {\n      var _a = props.secondaryText,\n          secondaryText = _a === void 0 ? _this.props.description : _a; // ms-Button-description is only shown when the button type is compound.\n      // In other cases it will not be displayed.\n\n      return secondaryText ? React.createElement(\"div\", {\n        key: _this._descriptionId,\n        className: _this._classNames.description,\n        id: _this._descriptionId\n      }, secondaryText) : null;\n    };\n\n    _this._onRenderAriaDescription = function () {\n      var ariaDescription = _this.props.ariaDescription; // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,\n      // otherwise it will be assigned to descriptionSpan.\n\n      return ariaDescription ? React.createElement(\"span\", {\n        className: _this._classNames.screenReaderText,\n        id: _this._ariaDescriptionId\n      }, ariaDescription) : null;\n    };\n\n    _this._onRenderMenuIcon = function (props) {\n      var menuIconProps = _this.props.menuIconProps;\n      return React.createElement(FontIcon, tslib_1.__assign({\n        iconName: \"ChevronDown\"\n      }, menuIconProps, {\n        className: _this._classNames.menuIcon\n      }));\n    };\n\n    _this._onRenderMenu = function (menuProps) {\n      var _a = menuProps.onDismiss,\n          onDismiss = _a === void 0 ? _this._dismissMenu : _a;\n      var MenuType = _this.props.menuAs || ContextualMenu; // the accessible menu label (accessible name) has a relationship to the button.\n      // If the menu props do not specify an explicit value for aria-label or aria-labelledBy,\n      // AND the button has text, we'll set the menu aria-labelledBy to the text element id.\n\n      if (!menuProps.ariaLabel && !menuProps.labelElementId && _this._hasText()) {\n        menuProps = tslib_1.__assign({}, menuProps, {\n          labelElementId: _this._labelId\n        });\n      }\n\n      return React.createElement(MenuType, tslib_1.__assign({\n        id: _this._labelId + '-menu',\n        directionalHint: DirectionalHint.bottomLeftEdge\n      }, menuProps, {\n        shouldFocusOnContainer: _this.state.menuProps ? _this.state.menuProps.shouldFocusOnContainer : undefined,\n        shouldFocusOnMount: _this.state.menuProps ? _this.state.menuProps.shouldFocusOnMount : undefined,\n        hidden: _this.state.menuProps ? _this.state.menuProps.hidden : undefined,\n        className: css('ms-BaseButton-menuhost', menuProps.className),\n        target: _this._isSplitButton ? _this._splitButtonContainer.current : _this._buttonElement.current,\n        onDismiss: onDismiss\n      }));\n    };\n\n    _this._dismissMenu = function () {\n      var menuProps = null;\n\n      if (_this.props.persistMenu && _this.state.menuProps) {\n        // Create a new object to trigger componentDidUpdate\n        menuProps = tslib_1.__assign({}, _this.state.menuProps, {\n          hidden: true\n        });\n      }\n\n      _this.setState({\n        menuProps: menuProps\n      });\n    };\n\n    _this._openMenu = function (shouldFocusOnContainer, shouldFocusOnMount) {\n      if (shouldFocusOnMount === void 0) {\n        shouldFocusOnMount = true;\n      }\n\n      if (_this.props.menuProps) {\n        var menuProps = tslib_1.__assign({}, _this.props.menuProps, {\n          shouldFocusOnContainer: shouldFocusOnContainer,\n          shouldFocusOnMount: shouldFocusOnMount\n        });\n\n        if (_this.props.persistMenu) {\n          _this._renderedPersistentMenu = true;\n          menuProps.hidden = false;\n        }\n\n        _this.setState({\n          menuProps: menuProps\n        });\n      }\n    };\n\n    _this._onToggleMenu = function (shouldFocusOnContainer) {\n      var currentMenuProps = _this.state.menuProps;\n      var shouldFocusOnMount = true;\n\n      if (_this.props.menuProps && _this.props.menuProps.shouldFocusOnMount === false) {\n        shouldFocusOnMount = false;\n      }\n\n      if (_this.props.persistMenu) {\n        // _renderedPersistentMenu ensures that the first rendering of\n        // the menu happens on-screen, as edge's scrollbar calcuations are off if done while hidden.\n        !_this._renderedPersistentMenu || currentMenuProps && currentMenuProps.hidden ? _this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : _this._dismissMenu();\n      } else {\n        currentMenuProps ? _this._dismissMenu() : _this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);\n      }\n    };\n\n    _this._onSplitContainerFocusCapture = function (ev) {\n      var container = _this._splitButtonContainer.current; // If the target is coming from the portal we do not need to set focus on the container.\n\n      if (!container || ev.target && portalContainsElement(ev.target, container)) {\n        return;\n      } // We should never be able to focus the individual buttons in a split button. Focus\n      // should always remain on the container.\n\n\n      container.focus();\n    };\n\n    _this._onSplitButtonPrimaryClick = function (ev) {\n      if (_this._isExpanded) {\n        _this._dismissMenu();\n      }\n\n      if (!_this._processingTouch && _this.props.onClick) {\n        _this.props.onClick(ev);\n      } else if (_this._processingTouch) {\n        _this._onMenuClick(ev);\n      }\n    };\n\n    _this._onKeyDown = function (ev) {\n      // explicity cancelling event so click won't fire after this\n      if (_this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {\n        ev.preventDefault();\n        ev.stopPropagation();\n      } else if (!_this.props.disabled) {\n        if (_this.props.menuProps) {\n          _this._onMenuKeyDown(ev);\n        } else if (_this.props.onKeyDown !== undefined) {\n          _this.props.onKeyDown(ev); // not cancelling event because it's not disabled\n\n        }\n      }\n    };\n\n    _this._onKeyUp = function (ev) {\n      if (!_this.props.disabled && _this.props.onKeyUp !== undefined) {\n        _this.props.onKeyUp(ev); // not cancelling event because it's not disabled\n\n      }\n    };\n\n    _this._onKeyPress = function (ev) {\n      if (!_this.props.disabled && _this.props.onKeyPress !== undefined) {\n        _this.props.onKeyPress(ev); // not cancelling event because it's not disabled\n\n      }\n    };\n\n    _this._onMouseUp = function (ev) {\n      if (!_this.props.disabled && _this.props.onMouseUp !== undefined) {\n        _this.props.onMouseUp(ev); // not cancelling event because it's not disabled\n\n      }\n    };\n\n    _this._onMouseDown = function (ev) {\n      if (!_this.props.disabled && _this.props.onMouseDown !== undefined) {\n        _this.props.onMouseDown(ev); // not cancelling event because it's not disabled\n\n      }\n    };\n\n    _this._onClick = function (ev) {\n      if (!_this.props.disabled) {\n        if (_this.props.menuProps) {\n          _this._onMenuClick(ev);\n        } else if (_this.props.onClick !== undefined) {\n          _this.props.onClick(ev); // not cancelling event because it's not disabled\n\n        }\n      }\n    };\n\n    _this._onSplitButtonContainerKeyDown = function (ev) {\n      if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {\n        if (_this._buttonElement.current) {\n          _this._buttonElement.current.click();\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      } else {\n        _this._onMenuKeyDown(ev);\n      }\n    };\n\n    _this._onMenuKeyDown = function (ev) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      }\n\n      var isUp = ev.which === KeyCodes.up;\n      var isDown = ev.which === KeyCodes.down;\n\n      if (!ev.defaultPrevented && _this._isValidMenuOpenKey(ev)) {\n        var onMenuClick = _this.props.onMenuClick;\n\n        if (onMenuClick) {\n          onMenuClick(ev, _this);\n        }\n\n        _this._onToggleMenu(false);\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n\n      if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {\n        _this.setState(function (state) {\n          if (state.menuProps && !state.menuProps.shouldFocusOnMount) {\n            return {\n              menuProps: tslib_1.__assign({}, state.menuProps, {\n                shouldFocusOnMount: true\n              })\n            };\n          }\n\n          return state;\n        }); // This should be done in the setStateCallback but because preventDefault\n        // needs to be called, we have to evaluate the current state, even though\n        // it might not be 100% accurate;\n\n\n        if (_this.state.menuProps && !_this.state.menuProps.shouldFocusOnMount) {\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    _this._onTouchStart = function () {\n      if (_this._isSplitButton && _this._splitButtonContainer.current && !('onpointerdown' in _this._splitButtonContainer.current)) {\n        _this._handleTouchAndPointerEvent();\n      }\n    };\n\n    _this._onMenuClick = function (ev) {\n      var onMenuClick = _this.props.onMenuClick;\n\n      if (onMenuClick) {\n        onMenuClick(ev, _this);\n      }\n\n      if (!ev.defaultPrevented) {\n        // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n        // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n        // between a real click event and a keypress event (detail should be the number of mouse clicks).\n        // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n        // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n        // and \"\" for pressing \"Enter\" with Narrator on.\n        var shouldFocusOnContainer = ev.nativeEvent.detail !== 0 || ev.nativeEvent.pointerType === 'mouse';\n\n        _this._onToggleMenu(shouldFocusOnContainer);\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    };\n\n    _this._warnConditionallyRequiredProps(['menuProps', 'onClick'], 'split', _this.props.split);\n\n    _this._warnDeprecations({\n      rootProps: undefined,\n      description: 'secondaryText',\n      toggled: 'checked'\n    });\n\n    _this._labelId = getId();\n    _this._descriptionId = getId();\n    _this._ariaDescriptionId = getId();\n    _this.state = {\n      menuProps: null\n    };\n    return _this;\n  }\n\n  _Object$defineProperty(BaseButton.prototype, \"_isSplitButton\", {\n    get: function get() {\n      return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  _Object$defineProperty(BaseButton.prototype, \"_isExpanded\", {\n    get: function get() {\n      var menuProps = this.state.menuProps;\n\n      if (this.props.persistMenu) {\n        return !!menuProps && !menuProps.hidden;\n      }\n\n      return !!menuProps;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BaseButton.prototype.render = function () {\n    var _a = this.props,\n        ariaDescription = _a.ariaDescription,\n        ariaLabel = _a.ariaLabel,\n        ariaHidden = _a.ariaHidden,\n        className = _a.className,\n        disabled = _a.disabled,\n        allowDisabledFocus = _a.allowDisabledFocus,\n        primaryDisabled = _a.primaryDisabled,\n        _b = _a.secondaryText,\n        secondaryText = _b === void 0 ? this.props.description : _b,\n        href = _a.href,\n        iconProps = _a.iconProps,\n        menuIconProps = _a.menuIconProps,\n        styles = _a.styles,\n        checked = _a.checked,\n        variantClassName = _a.variantClassName,\n        theme = _a.theme,\n        toggle = _a.toggle,\n        getClassNames = _a.getClassNames; // Button is disabled if the whole button (in case of splitbutton is disabled) or if the primary action is disabled\n\n    var isPrimaryButtonDisabled = disabled || primaryDisabled;\n    this._classNames = getClassNames ? getClassNames(theme, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, this._isExpanded, this.props.split, !!allowDisabledFocus) : getBaseButtonClassNames(theme, styles, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, this._isExpanded, this.props.split);\n\n    var _c = this,\n        _ariaDescriptionId = _c._ariaDescriptionId,\n        _labelId = _c._labelId,\n        _descriptionId = _c._descriptionId; // Anchor tag cannot be disabled hence in disabled state rendering\n    // anchor button as normal button\n\n\n    var renderAsAnchor = !isPrimaryButtonDisabled && !!href;\n    var tag = renderAsAnchor ? 'a' : 'button';\n    var nativeProps = getNativeProps(assign(renderAsAnchor ? {} : {\n      type: 'button'\n    }, this.props.rootProps, this.props), renderAsAnchor ? anchorProperties : buttonProperties, ['disabled' // let disabled buttons be focused and styled as disabled.\n    ]); // Check for ariaLabel passed in via Button props, and fall back to aria-label passed in via native props\n\n    var resolvedAriaLabel = ariaLabel || nativeProps['aria-label']; // Check for ariaDescription, secondaryText or aria-describedby in the native props to determine source of aria-describedby\n    // otherwise default to undefined so property does not appear in output.\n\n    var ariaDescribedBy = undefined;\n\n    if (ariaDescription) {\n      ariaDescribedBy = _ariaDescriptionId;\n    } else if (secondaryText && this.props.onRenderDescription !== nullRender) {\n      // for buttons like CompoundButton with a valid onRenderDescription, we need to set an ariaDescribedBy\n      // for buttons that do not render anything (via nullRender), we should not set an ariaDescribedBy\n      ariaDescribedBy = _descriptionId;\n    } else if (nativeProps['aria-describedby']) {\n      ariaDescribedBy = nativeProps['aria-describedby'];\n    } // If an explicit ariaLabel is given, use that as the label and we're done.\n    // If an explicit aria-labelledby is given, use that and we're done.\n    // If any kind of description is given (which will end up as an aria-describedby attribute),\n    // set the labelledby element. Otherwise, the button is labeled implicitly by the descendent\n    // text on the button (if it exists). Never set both aria-label and aria-labelledby.\n\n\n    var ariaLabelledBy = undefined;\n\n    if (!resolvedAriaLabel) {\n      if (nativeProps['aria-labelledby']) {\n        ariaLabelledBy = nativeProps['aria-labelledby'];\n      } else if (ariaDescribedBy) {\n        ariaLabelledBy = this._hasText() ? _labelId : undefined;\n      }\n    }\n\n    var dataIsFocusable = this.props['data-is-focusable'] === false || disabled && !allowDisabledFocus || this._isSplitButton ? false : true;\n    var buttonProps = assign(nativeProps, {\n      className: this._classNames.root,\n      ref: this._buttonElement,\n      disabled: isPrimaryButtonDisabled && !allowDisabledFocus,\n      onKeyDown: this._onKeyDown,\n      onKeyPress: this._onKeyPress,\n      onKeyUp: this._onKeyUp,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onClick: this._onClick,\n      'aria-label': resolvedAriaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-describedby': ariaDescribedBy,\n      'aria-disabled': isPrimaryButtonDisabled,\n      'data-is-focusable': dataIsFocusable,\n      'aria-pressed': toggle ? !!checked : undefined // aria-pressed attribute should only be present for toggle buttons\n\n    });\n\n    if (ariaHidden) {\n      buttonProps['aria-hidden'] = true;\n    }\n\n    if (this._isSplitButton) {\n      return this._onRenderSplitButtonContent(tag, buttonProps);\n    } else if (this.props.menuProps) {\n      assign(buttonProps, {\n        'aria-expanded': this._isExpanded,\n        'aria-owns': this.state.menuProps ? this._labelId + '-menu' : null,\n        'aria-haspopup': true\n      });\n    }\n\n    return this._onRenderContent(tag, buttonProps);\n  };\n\n  BaseButton.prototype.componentDidMount = function () {\n    // For split buttons, touching anywhere in the button should drop the dropdown, which should contain the primary action.\n    // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React\n    // does not support Pointer events yet.\n    if (this._isSplitButton && this._splitButtonContainer.current && 'onpointerdown' in this._splitButtonContainer.current) {\n      this._events.on(this._splitButtonContainer.current, 'pointerdown', this._onPointerDown, true);\n    }\n  };\n\n  BaseButton.prototype.componentDidUpdate = function (prevProps, prevState) {\n    // If Button's menu was closed, run onAfterMenuDismiss. If the menu is being persisted\n    // this condition is tested by checking on a change on the menuProps hidden value.\n    if (this.props.onAfterMenuDismiss && prevState.menuProps) {\n      if (!this.state.menuProps || this.props.persistMenu && !prevState.menuProps.hidden && this.state.menuProps.hidden) {\n        this.props.onAfterMenuDismiss();\n      }\n    }\n  };\n\n  BaseButton.prototype.focus = function () {\n    if (this._isSplitButton && this._splitButtonContainer.current) {\n      this._splitButtonContainer.current.focus();\n    } else if (this._buttonElement.current) {\n      this._buttonElement.current.focus();\n    }\n  };\n\n  BaseButton.prototype.dismissMenu = function () {\n    this._dismissMenu();\n  };\n\n  BaseButton.prototype.openMenu = function (shouldFocusOnContainer, shouldFocusOnMount) {\n    this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);\n  };\n\n  BaseButton.prototype._onRenderContent = function (tag, buttonProps) {\n    var _this = this;\n\n    var props = this.props;\n    var Tag = tag;\n    var menuIconProps = props.menuIconProps,\n        menuProps = props.menuProps,\n        _a = props.onRenderIcon,\n        onRenderIcon = _a === void 0 ? this._onRenderIcon : _a,\n        _b = props.onRenderAriaDescription,\n        onRenderAriaDescription = _b === void 0 ? this._onRenderAriaDescription : _b,\n        _c = props.onRenderChildren,\n        onRenderChildren = _c === void 0 ? this._onRenderChildren : _c,\n        _d = props.onRenderMenu,\n        onRenderMenu = _d === void 0 ? this._onRenderMenu : _d,\n        _e = props.onRenderMenuIcon,\n        onRenderMenuIcon = _e === void 0 ? this._onRenderMenuIcon : _e,\n        disabled = props.disabled;\n    var keytipProps = props.keytipProps;\n\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    var Button = function Button(keytipAttributes) {\n      return React.createElement(Tag, tslib_1.__assign({}, buttonProps, keytipAttributes), React.createElement(\"div\", {\n        className: _this._classNames.flexContainer\n      }, onRenderIcon(props, _this._onRenderIcon), _this._onRenderTextContents(), onRenderAriaDescription(props, _this._onRenderAriaDescription), onRenderChildren(props, _this._onRenderChildren), !_this._isSplitButton && (menuProps || menuIconProps || _this.props.onRenderMenuIcon) && onRenderMenuIcon(_this.props, _this._onRenderMenuIcon), _this.state.menuProps && !_this.state.menuProps.doNotLayer && onRenderMenu(menuProps, _this._onRenderMenu)));\n    };\n\n    var Content = keytipProps ? // If we're making a split button, we won't put the keytip here\n    React.createElement(KeytipData, {\n      keytipProps: !this._isSplitButton ? keytipProps : undefined,\n      ariaDescribedBy: buttonProps['aria-describedby'],\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return Button(keytipAttributes);\n    }) : Button();\n\n    if (menuProps && menuProps.doNotLayer) {\n      return React.createElement(\"div\", {\n        style: {\n          display: 'inline-block'\n        }\n      }, Content, this.state.menuProps && onRenderMenu(menuProps, this._onRenderMenu));\n    }\n\n    return Content;\n  };\n\n  BaseButton.prototype._hasText = function () {\n    // _onRenderTextContents and _onRenderText do not perform the same checks. Below is parity with what _onRenderText used to have\n    // before the refactor that introduced this function. _onRenderTextContents does not require props.text to be undefined in order\n    // for props.children to be used as a fallback. Purely a code maintainability/reuse issue, but logged as Issue #4979\n    return this.props.text !== null && (this.props.text !== undefined || typeof this.props.children === 'string');\n  };\n\n  BaseButton.prototype._onRenderSplitButtonContent = function (tag, buttonProps) {\n    var _this = this;\n\n    var _a = this.props,\n        _b = _a.styles,\n        styles = _b === void 0 ? {} : _b,\n        disabled = _a.disabled,\n        allowDisabledFocus = _a.allowDisabledFocus,\n        checked = _a.checked,\n        getSplitButtonClassNames = _a.getSplitButtonClassNames,\n        primaryDisabled = _a.primaryDisabled,\n        menuProps = _a.menuProps,\n        toggle = _a.toggle,\n        primaryActionButtonProps = _a.primaryActionButtonProps;\n    var keytipProps = this.props.keytipProps;\n    var classNames = getSplitButtonClassNames ? getSplitButtonClassNames(!!disabled, this._isExpanded, !!checked, !!allowDisabledFocus) : styles && getBaseSplitButtonClassNames(styles, !!disabled, this._isExpanded, !!checked, !!primaryDisabled);\n    assign(buttonProps, {\n      onClick: undefined,\n      tabIndex: -1,\n      'data-is-focusable': false\n    });\n    var ariaDescribedBy = buttonProps.ariaDescription;\n\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    var containerProps = getNativeProps(buttonProps, [], ['disabled']); // Add additional props to apply on primary action button\n\n    if (primaryActionButtonProps) {\n      assign(buttonProps, tslib_1.__assign({}, primaryActionButtonProps));\n    }\n\n    var SplitButton = function SplitButton(keytipAttributes) {\n      return React.createElement(\"div\", tslib_1.__assign({}, containerProps, {\n        \"data-ktp-target\": keytipAttributes ? keytipAttributes['data-ktp-target'] : undefined,\n        role: 'button',\n        \"aria-disabled\": disabled,\n        \"aria-haspopup\": true,\n        \"aria-expanded\": _this._isExpanded,\n        \"aria-pressed\": toggle ? !!checked : undefined,\n        \"aria-describedby\": mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes ? keytipAttributes['aria-describedby'] : undefined),\n        className: classNames && classNames.splitButtonContainer,\n        onKeyDown: _this._onSplitButtonContainerKeyDown,\n        onTouchStart: _this._onTouchStart,\n        ref: _this._splitButtonContainer,\n        \"data-is-focusable\": true,\n        onClick: !disabled && !primaryDisabled ? _this._onSplitButtonPrimaryClick : undefined,\n        tabIndex: !disabled || allowDisabledFocus ? 0 : undefined,\n        \"aria-roledescription\": buttonProps['aria-roledescription'],\n        onFocusCapture: _this._onSplitContainerFocusCapture\n      }), React.createElement(\"span\", {\n        style: {\n          display: 'flex'\n        }\n      }, _this._onRenderContent(tag, buttonProps), _this._onRenderSplitButtonMenuButton(classNames, keytipAttributes), _this._onRenderSplitButtonDivider(classNames)));\n    };\n\n    return keytipProps ? React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return SplitButton(keytipAttributes);\n    }) : SplitButton();\n  };\n\n  BaseButton.prototype._onRenderSplitButtonDivider = function (classNames) {\n    if (classNames && classNames.divider) {\n      return React.createElement(\"span\", {\n        className: classNames.divider,\n        \"aria-hidden\": true\n      });\n    }\n\n    return null;\n  };\n\n  BaseButton.prototype._onRenderSplitButtonMenuButton = function (classNames, keytipAttributes) {\n    var _a = this.props,\n        allowDisabledFocus = _a.allowDisabledFocus,\n        checked = _a.checked,\n        disabled = _a.disabled,\n        splitButtonMenuProps = _a.splitButtonMenuProps;\n    var menuIconProps = this.props.menuIconProps;\n    var splitButtonAriaLabel = this.props.splitButtonAriaLabel;\n\n    if (menuIconProps === undefined) {\n      menuIconProps = {\n        iconName: 'ChevronDown'\n      };\n    }\n\n    var splitButtonProps = tslib_1.__assign({}, splitButtonMenuProps, {\n      styles: classNames,\n      checked: checked,\n      disabled: disabled,\n      allowDisabledFocus: allowDisabledFocus,\n      onClick: this._onMenuClick,\n      menuProps: undefined,\n      iconProps: tslib_1.__assign({}, menuIconProps, {\n        className: this._classNames.menuIcon\n      }),\n      ariaLabel: splitButtonAriaLabel,\n      'aria-haspopup': true,\n      'aria-expanded': this._isExpanded,\n      'data-is-focusable': false\n    }); // Add data-ktp-execute-target to the split button if the keytip is defined\n\n\n    return React.createElement(BaseButton, tslib_1.__assign({}, splitButtonProps, {\n      \"data-ktp-execute-target\": keytipAttributes ? keytipAttributes['data-ktp-execute-target'] : keytipAttributes,\n      onMouseDown: this._onMouseDown,\n      tabIndex: -1\n    }));\n  };\n\n  BaseButton.prototype._onPointerDown = function (ev) {\n    if (ev.pointerType === 'touch') {\n      this._handleTouchAndPointerEvent();\n\n      ev.preventDefault();\n      ev.stopImmediatePropagation();\n    }\n  };\n\n  BaseButton.prototype._handleTouchAndPointerEvent = function () {\n    var _this = this; // If we already have an existing timeeout from a previous touch and pointer event\n    // cancel that timeout so we can set a nwe one.\n\n\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n\n      this._lastTouchTimeoutId = undefined;\n    }\n\n    this._processingTouch = true;\n    this._lastTouchTimeoutId = this._async.setTimeout(function () {\n      _this._processingTouch = false;\n      _this._lastTouchTimeoutId = undefined;\n    }, TouchIdleDelay);\n  };\n  /**\n   * Returns if the user hits a valid keyboard key to open the menu\n   * @param ev - the keyboard event\n   * @returns True if user clicks on custom trigger key if enabled or alt + down arrow if not. False otherwise.\n   */\n\n\n  BaseButton.prototype._isValidMenuOpenKey = function (ev) {\n    if (this.props.menuTriggerKeyCode) {\n      return ev.which === this.props.menuTriggerKeyCode;\n    } else if (this.props.menuProps) {\n      return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);\n    } // Note: When enter is pressed, we will let the event continue to propagate\n    // to trigger the onClick event on the button\n\n\n    return false;\n  };\n\n  BaseButton.defaultProps = {\n    baseClassName: 'ms-Button',\n    styles: {},\n    split: false\n  };\n  return BaseButton;\n}(BaseComponent);\n\nexport { BaseButton };","map":{"version":3,"sources":["components/Button/BaseButton.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  BaseComponent,\n  IRenderFunction,\n  anchorProperties,\n  assign,\n  buttonProperties,\n  getId,\n  getNativeProps,\n  KeyCodes,\n  css,\n  mergeAriaAttributeValues,\n  portalContainsElement\n} from '../../Utilities';\nimport { Icon, FontIcon, ImageIcon } from '../../Icon';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { ContextualMenu, IContextualMenuProps } from '../../ContextualMenu';\nimport { IButtonProps, IButton } from './Button.types';\nimport { IButtonClassNames, getBaseButtonClassNames } from './BaseButton.classNames';\nimport { getClassNames as getBaseSplitButtonClassNames, ISplitButtonClassNames } from './SplitButton/SplitButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nimport { memoizeFunction, nullRender } from '@uifabric/utilities';\nimport { IKeytipProps } from '../Keytip/Keytip.types';\n\n/**\n * {@docCategory Button}\n */\nexport interface IBaseButtonProps extends IButtonProps {\n  baseClassName?: string;\n  variantClassName?: string;\n}\n\nexport interface IBaseButtonState {\n  menuProps?: IContextualMenuProps | null;\n}\n\nconst TouchIdleDelay = 500; /* ms */\n\n/**\n * {@docCategory Button}\n */\nexport class BaseButton extends BaseComponent<IBaseButtonProps, IBaseButtonState> implements IButton {\n  private get _isSplitButton(): boolean {\n    return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;\n  }\n\n  private get _isExpanded(): boolean {\n    const { menuProps } = this.state;\n    if (this.props.persistMenu) {\n      return !!menuProps && !menuProps.hidden;\n    }\n    return !!menuProps;\n  }\n\n  public static defaultProps: Partial<IBaseButtonProps> = {\n    baseClassName: 'ms-Button',\n    styles: {},\n    split: false\n  };\n\n  private _buttonElement = React.createRef<HTMLElement>();\n  private _splitButtonContainer = React.createRef<HTMLDivElement>();\n  private _labelId: string;\n  private _descriptionId: string;\n  private _ariaDescriptionId: string;\n  private _classNames: IButtonClassNames;\n  private _processingTouch: boolean;\n  private _lastTouchTimeoutId: number | undefined;\n  private _renderedPersistentMenu: boolean = false;\n\n  private _getMemoizedMenuButtonKeytipProps = memoizeFunction((keytipProps: IKeytipProps) => {\n    return {\n      ...keytipProps,\n      hasMenu: true\n    };\n  });\n\n  constructor(props: IBaseButtonProps, rootClassName: string) {\n    super(props);\n\n    this._warnConditionallyRequiredProps(['menuProps', 'onClick'], 'split', this.props.split!);\n\n    this._warnDeprecations({\n      rootProps: undefined,\n      description: 'secondaryText',\n      toggled: 'checked'\n    });\n    this._labelId = getId();\n    this._descriptionId = getId();\n    this._ariaDescriptionId = getId();\n\n    this.state = {\n      menuProps: null\n    };\n  }\n\n  public render(): JSX.Element {\n    const {\n      ariaDescription,\n      ariaLabel,\n      ariaHidden,\n      className,\n      disabled,\n      allowDisabledFocus,\n      primaryDisabled,\n      secondaryText = this.props.description,\n      href,\n      iconProps,\n      menuIconProps,\n      styles,\n      checked,\n      variantClassName,\n      theme,\n      toggle,\n      getClassNames\n    } = this.props;\n\n    // Button is disabled if the whole button (in case of splitbutton is disabled) or if the primary action is disabled\n    const isPrimaryButtonDisabled = disabled || primaryDisabled;\n\n    this._classNames = getClassNames\n      ? getClassNames(\n          theme!,\n          className!,\n          variantClassName!,\n          iconProps && iconProps.className,\n          menuIconProps && menuIconProps.className,\n          isPrimaryButtonDisabled!,\n          checked!,\n          this._isExpanded,\n          this.props.split,\n          !!allowDisabledFocus\n        )\n      : getBaseButtonClassNames(\n          theme!,\n          styles!,\n          className!,\n          variantClassName!,\n          iconProps && iconProps.className,\n          menuIconProps && menuIconProps.className,\n          isPrimaryButtonDisabled!,\n          checked!,\n          this._isExpanded,\n          this.props.split\n        );\n\n    const { _ariaDescriptionId, _labelId, _descriptionId } = this;\n    // Anchor tag cannot be disabled hence in disabled state rendering\n    // anchor button as normal button\n    const renderAsAnchor: boolean = !isPrimaryButtonDisabled && !!href;\n    const tag = renderAsAnchor ? 'a' : 'button';\n\n    const nativeProps = getNativeProps(\n      assign(renderAsAnchor ? {} : { type: 'button' }, this.props.rootProps, this.props),\n      renderAsAnchor ? anchorProperties : buttonProperties,\n      [\n        'disabled' // let disabled buttons be focused and styled as disabled.\n      ]\n    );\n\n    // Check for ariaLabel passed in via Button props, and fall back to aria-label passed in via native props\n    const resolvedAriaLabel = ariaLabel || (nativeProps as any)['aria-label'];\n\n    // Check for ariaDescription, secondaryText or aria-describedby in the native props to determine source of aria-describedby\n    // otherwise default to undefined so property does not appear in output.\n    let ariaDescribedBy = undefined;\n    if (ariaDescription) {\n      ariaDescribedBy = _ariaDescriptionId;\n    } else if (secondaryText && this.props.onRenderDescription !== nullRender) {\n      // for buttons like CompoundButton with a valid onRenderDescription, we need to set an ariaDescribedBy\n      // for buttons that do not render anything (via nullRender), we should not set an ariaDescribedBy\n      ariaDescribedBy = _descriptionId;\n    } else if ((nativeProps as any)['aria-describedby']) {\n      ariaDescribedBy = (nativeProps as any)['aria-describedby'];\n    }\n\n    // If an explicit ariaLabel is given, use that as the label and we're done.\n    // If an explicit aria-labelledby is given, use that and we're done.\n    // If any kind of description is given (which will end up as an aria-describedby attribute),\n    // set the labelledby element. Otherwise, the button is labeled implicitly by the descendent\n    // text on the button (if it exists). Never set both aria-label and aria-labelledby.\n    let ariaLabelledBy = undefined;\n    if (!resolvedAriaLabel) {\n      if ((nativeProps as any)['aria-labelledby']) {\n        ariaLabelledBy = (nativeProps as any)['aria-labelledby'];\n      } else if (ariaDescribedBy) {\n        ariaLabelledBy = this._hasText() ? _labelId : undefined;\n      }\n    }\n\n    const dataIsFocusable =\n      (this.props as any)['data-is-focusable'] === false || (disabled && !allowDisabledFocus) || this._isSplitButton ? false : true;\n\n    const buttonProps = assign(nativeProps, {\n      className: this._classNames.root,\n      ref: this._buttonElement,\n      disabled: isPrimaryButtonDisabled && !allowDisabledFocus,\n      onKeyDown: this._onKeyDown,\n      onKeyPress: this._onKeyPress,\n      onKeyUp: this._onKeyUp,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onClick: this._onClick,\n      'aria-label': resolvedAriaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-describedby': ariaDescribedBy,\n      'aria-disabled': isPrimaryButtonDisabled,\n      'data-is-focusable': dataIsFocusable,\n      'aria-pressed': toggle ? !!checked : undefined // aria-pressed attribute should only be present for toggle buttons\n    });\n\n    if (ariaHidden) {\n      buttonProps['aria-hidden'] = true;\n    }\n\n    if (this._isSplitButton) {\n      return this._onRenderSplitButtonContent(tag, buttonProps);\n    } else if (this.props.menuProps) {\n      assign(buttonProps, {\n        'aria-expanded': this._isExpanded,\n        'aria-owns': this.state.menuProps ? this._labelId + '-menu' : null,\n        'aria-haspopup': true\n      });\n    }\n\n    return this._onRenderContent(tag, buttonProps);\n  }\n\n  public componentDidMount() {\n    // For split buttons, touching anywhere in the button should drop the dropdown, which should contain the primary action.\n    // This gives more hit target space for touch environments. We're setting the onpointerdown here, because React\n    // does not support Pointer events yet.\n    if (this._isSplitButton && this._splitButtonContainer.current && 'onpointerdown' in this._splitButtonContainer.current) {\n      this._events.on(this._splitButtonContainer.current, 'pointerdown', this._onPointerDown, true);\n    }\n  }\n\n  public componentDidUpdate(prevProps: IBaseButtonProps, prevState: IBaseButtonState) {\n    // If Button's menu was closed, run onAfterMenuDismiss. If the menu is being persisted\n    // this condition is tested by checking on a change on the menuProps hidden value.\n    if (this.props.onAfterMenuDismiss && prevState.menuProps) {\n      if (!this.state.menuProps || (this.props.persistMenu && !prevState.menuProps.hidden && this.state.menuProps.hidden)) {\n        this.props.onAfterMenuDismiss();\n      }\n    }\n  }\n\n  public focus(): void {\n    if (this._isSplitButton && this._splitButtonContainer.current) {\n      this._splitButtonContainer.current.focus();\n    } else if (this._buttonElement.current) {\n      this._buttonElement.current.focus();\n    }\n  }\n\n  public dismissMenu(): void {\n    this._dismissMenu();\n  }\n\n  public openMenu(shouldFocusOnContainer?: boolean, shouldFocusOnMount?: boolean): void {\n    this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);\n  }\n\n  private _onRenderContent(tag: any, buttonProps: IButtonProps): JSX.Element {\n    const props = this.props;\n    const Tag = tag;\n    const {\n      menuIconProps,\n      menuProps,\n      onRenderIcon = this._onRenderIcon,\n      onRenderAriaDescription = this._onRenderAriaDescription,\n      onRenderChildren = this._onRenderChildren,\n      onRenderMenu = this._onRenderMenu,\n      onRenderMenuIcon = this._onRenderMenuIcon,\n      disabled\n    } = props;\n    let { keytipProps } = props;\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    const Button = (keytipAttributes?: any): JSX.Element => (\n      <Tag {...buttonProps} {...keytipAttributes}>\n        <div className={this._classNames.flexContainer}>\n          {onRenderIcon(props, this._onRenderIcon)}\n          {this._onRenderTextContents()}\n          {onRenderAriaDescription(props, this._onRenderAriaDescription)}\n          {onRenderChildren(props, this._onRenderChildren)}\n          {!this._isSplitButton &&\n            (menuProps || menuIconProps || this.props.onRenderMenuIcon) &&\n            onRenderMenuIcon(this.props, this._onRenderMenuIcon)}\n          {this.state.menuProps && !this.state.menuProps.doNotLayer && onRenderMenu(menuProps, this._onRenderMenu)}\n        </div>\n      </Tag>\n    );\n\n    const Content = keytipProps ? (\n      // If we're making a split button, we won't put the keytip here\n      <KeytipData\n        keytipProps={!this._isSplitButton ? keytipProps : undefined}\n        ariaDescribedBy={(buttonProps as any)['aria-describedby']}\n        disabled={disabled}\n      >\n        {(keytipAttributes: any): JSX.Element => Button(keytipAttributes)}\n      </KeytipData>\n    ) : (\n      Button()\n    );\n\n    if (menuProps && menuProps.doNotLayer) {\n      return (\n        <div style={{ display: 'inline-block' }}>\n          {Content}\n          {this.state.menuProps && onRenderMenu(menuProps, this._onRenderMenu)}\n        </div>\n      );\n    }\n\n    return Content;\n  }\n\n  private _onRenderIcon = (buttonProps?: IButtonProps, defaultRender?: IRenderFunction<IButtonProps>): JSX.Element | null => {\n    const { iconProps } = this.props;\n\n    if (iconProps && (iconProps.iconName !== undefined || iconProps.imageProps)) {\n      const { className, imageProps, ...rest } = iconProps;\n\n      // If the styles prop is specified as part of iconProps, fall back to regular Icon as FontIcon and ImageIcon do not have such prop.\n      if (iconProps.styles) {\n        return <Icon className={css(this._classNames.icon, className)} imageProps={imageProps} {...rest} />;\n      }\n      if (iconProps.iconName) {\n        return <FontIcon className={css(this._classNames.icon, className)} {...rest} />;\n      }\n      if (imageProps) {\n        return <ImageIcon className={css(this._classNames.icon, className)} imageProps={imageProps} {...rest} />;\n      }\n    }\n    return null;\n  };\n\n  private _onRenderTextContents = (): JSX.Element | (JSX.Element | null)[] => {\n    const {\n      text,\n      children,\n      secondaryText = this.props.description,\n      onRenderText = this._onRenderText,\n      onRenderDescription = this._onRenderDescription\n    } = this.props;\n\n    if (text || typeof children === 'string' || secondaryText) {\n      return (\n        <div className={this._classNames.textContainer}>\n          {onRenderText(this.props, this._onRenderText)}\n          {onRenderDescription(this.props, this._onRenderDescription)}\n        </div>\n      );\n    }\n    return [onRenderText(this.props, this._onRenderText), onRenderDescription(this.props, this._onRenderDescription)];\n  };\n\n  private _onRenderText = (): JSX.Element | null => {\n    let { text } = this.props;\n    const { children } = this.props;\n\n    // For backwards compat, we should continue to take in the text content from children.\n    if (text === undefined && typeof children === 'string') {\n      text = children;\n    }\n\n    if (this._hasText()) {\n      return (\n        <div key={this._labelId} className={this._classNames.label} id={this._labelId}>\n          {text}\n        </div>\n      );\n    }\n\n    return null;\n  };\n\n  private _hasText(): boolean {\n    // _onRenderTextContents and _onRenderText do not perform the same checks. Below is parity with what _onRenderText used to have\n    // before the refactor that introduced this function. _onRenderTextContents does not require props.text to be undefined in order\n    // for props.children to be used as a fallback. Purely a code maintainability/reuse issue, but logged as Issue #4979\n    return this.props.text !== null && (this.props.text !== undefined || typeof this.props.children === 'string');\n  }\n\n  private _onRenderChildren = (): JSX.Element | null => {\n    const { children } = this.props;\n\n    // If children is just a string, either it or the text will be rendered via onRenderLabel\n    // If children is another component, it will be rendered after text\n    if (typeof children === 'string') {\n      return null;\n    }\n\n    return children as any;\n  };\n\n  private _onRenderDescription = (props: IButtonProps) => {\n    const { secondaryText = this.props.description } = props;\n\n    // ms-Button-description is only shown when the button type is compound.\n    // In other cases it will not be displayed.\n    return secondaryText ? (\n      <div key={this._descriptionId} className={this._classNames.description} id={this._descriptionId}>\n        {secondaryText}\n      </div>\n    ) : null;\n  };\n\n  private _onRenderAriaDescription = () => {\n    const { ariaDescription } = this.props;\n\n    // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,\n    // otherwise it will be assigned to descriptionSpan.\n    return ariaDescription ? (\n      <span className={this._classNames.screenReaderText} id={this._ariaDescriptionId}>\n        {ariaDescription}\n      </span>\n    ) : null;\n  };\n\n  private _onRenderMenuIcon = (props: IButtonProps): JSX.Element | null => {\n    const { menuIconProps } = this.props;\n\n    return <FontIcon iconName=\"ChevronDown\" {...menuIconProps} className={this._classNames.menuIcon} />;\n  };\n\n  private _onRenderMenu = (menuProps: IContextualMenuProps): JSX.Element => {\n    const { onDismiss = this._dismissMenu } = menuProps;\n\n    const MenuType = this.props.menuAs || (ContextualMenu as React.ReactType<IContextualMenuProps>);\n\n    // the accessible menu label (accessible name) has a relationship to the button.\n    // If the menu props do not specify an explicit value for aria-label or aria-labelledBy,\n    // AND the button has text, we'll set the menu aria-labelledBy to the text element id.\n    if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {\n      menuProps = { ...menuProps, labelElementId: this._labelId };\n    }\n\n    return (\n      <MenuType\n        id={this._labelId + '-menu'}\n        directionalHint={DirectionalHint.bottomLeftEdge}\n        {...menuProps}\n        shouldFocusOnContainer={this.state.menuProps ? this.state.menuProps.shouldFocusOnContainer : undefined}\n        shouldFocusOnMount={this.state.menuProps ? this.state.menuProps.shouldFocusOnMount : undefined}\n        hidden={this.state.menuProps ? this.state.menuProps.hidden : undefined}\n        className={css('ms-BaseButton-menuhost', menuProps.className)}\n        target={this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current}\n        onDismiss={onDismiss}\n      />\n    );\n  };\n\n  private _dismissMenu = (): void => {\n    let menuProps = null;\n    if (this.props.persistMenu && this.state.menuProps) {\n      // Create a new object to trigger componentDidUpdate\n      menuProps = { ...this.state.menuProps, hidden: true };\n    }\n    this.setState({ menuProps: menuProps });\n  };\n\n  private _openMenu = (shouldFocusOnContainer?: boolean, shouldFocusOnMount: boolean = true): void => {\n    if (this.props.menuProps) {\n      const menuProps = { ...this.props.menuProps, shouldFocusOnContainer, shouldFocusOnMount };\n      if (this.props.persistMenu) {\n        this._renderedPersistentMenu = true;\n        menuProps.hidden = false;\n      }\n      this.setState({ menuProps: menuProps });\n    }\n  };\n\n  private _onToggleMenu = (shouldFocusOnContainer: boolean): void => {\n    const currentMenuProps = this.state.menuProps;\n    let shouldFocusOnMount = true;\n    if (this.props.menuProps && this.props.menuProps.shouldFocusOnMount === false) {\n      shouldFocusOnMount = false;\n    }\n    if (this.props.persistMenu) {\n      // _renderedPersistentMenu ensures that the first rendering of\n      // the menu happens on-screen, as edge's scrollbar calcuations are off if done while hidden.\n      !this._renderedPersistentMenu || (currentMenuProps && currentMenuProps.hidden)\n        ? this._openMenu(shouldFocusOnContainer, shouldFocusOnMount)\n        : this._dismissMenu();\n    } else {\n      currentMenuProps ? this._dismissMenu() : this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);\n    }\n  };\n\n  private _onRenderSplitButtonContent(tag: any, buttonProps: IButtonProps): JSX.Element {\n    const {\n      styles = {},\n      disabled,\n      allowDisabledFocus,\n      checked,\n      getSplitButtonClassNames,\n      primaryDisabled,\n      menuProps,\n      toggle,\n      primaryActionButtonProps\n    } = this.props;\n    let { keytipProps } = this.props;\n\n    const classNames = getSplitButtonClassNames\n      ? getSplitButtonClassNames(!!disabled, this._isExpanded, !!checked, !!allowDisabledFocus)\n      : styles && getBaseSplitButtonClassNames(styles!, !!disabled, this._isExpanded, !!checked, !!primaryDisabled);\n\n    assign(buttonProps, {\n      onClick: undefined,\n      tabIndex: -1,\n      'data-is-focusable': false\n    });\n    const ariaDescribedBy = buttonProps.ariaDescription;\n\n    if (keytipProps && menuProps) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    const containerProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(buttonProps, [], ['disabled']);\n\n    // Add additional props to apply on primary action button\n    if (primaryActionButtonProps) {\n      assign(buttonProps, { ...primaryActionButtonProps });\n    }\n\n    const SplitButton = (keytipAttributes?: any): JSX.Element => (\n      <div\n        {...containerProps}\n        data-ktp-target={keytipAttributes ? keytipAttributes['data-ktp-target'] : undefined}\n        role={'button'}\n        aria-disabled={disabled}\n        aria-haspopup={true}\n        aria-expanded={this._isExpanded}\n        aria-pressed={toggle ? !!checked : undefined} // aria-pressed attribute should only be present for toggle buttons\n        aria-describedby={mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes ? keytipAttributes['aria-describedby'] : undefined)}\n        className={classNames && classNames.splitButtonContainer}\n        onKeyDown={this._onSplitButtonContainerKeyDown}\n        onTouchStart={this._onTouchStart}\n        ref={this._splitButtonContainer}\n        data-is-focusable={true}\n        onClick={!disabled && !primaryDisabled ? this._onSplitButtonPrimaryClick : undefined}\n        tabIndex={!disabled || allowDisabledFocus ? 0 : undefined}\n        aria-roledescription={buttonProps['aria-roledescription']}\n        onFocusCapture={this._onSplitContainerFocusCapture}\n      >\n        <span style={{ display: 'flex' }}>\n          {this._onRenderContent(tag, buttonProps)}\n          {this._onRenderSplitButtonMenuButton(classNames, keytipAttributes)}\n          {this._onRenderSplitButtonDivider(classNames)}\n        </span>\n      </div>\n    );\n\n    return keytipProps ? (\n      <KeytipData keytipProps={keytipProps} disabled={disabled}>\n        {(keytipAttributes: any): JSX.Element => SplitButton(keytipAttributes)}\n      </KeytipData>\n    ) : (\n      SplitButton()\n    );\n  }\n\n  private _onSplitContainerFocusCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    const container = this._splitButtonContainer.current;\n\n    // If the target is coming from the portal we do not need to set focus on the container.\n    if (!container || (ev.target && portalContainsElement(ev.target, container))) {\n      return;\n    }\n\n    // We should never be able to focus the individual buttons in a split button. Focus\n    // should always remain on the container.\n    container.focus();\n  };\n\n  private _onSplitButtonPrimaryClick = (ev: React.MouseEvent<HTMLDivElement>) => {\n    if (this._isExpanded) {\n      this._dismissMenu();\n    }\n\n    if (!this._processingTouch && this.props.onClick) {\n      this.props.onClick(ev);\n    } else if (this._processingTouch) {\n      this._onMenuClick(ev);\n    }\n  };\n\n  private _onRenderSplitButtonDivider(classNames: ISplitButtonClassNames | undefined): JSX.Element | null {\n    if (classNames && classNames.divider) {\n      return <span className={classNames.divider} aria-hidden={true} />;\n    }\n    return null;\n  }\n\n  private _onRenderSplitButtonMenuButton(classNames: ISplitButtonClassNames | undefined, keytipAttributes: any): JSX.Element {\n    const { allowDisabledFocus, checked, disabled, splitButtonMenuProps } = this.props;\n    let menuIconProps = this.props.menuIconProps;\n\n    const { splitButtonAriaLabel } = this.props;\n\n    if (menuIconProps === undefined) {\n      menuIconProps = {\n        iconName: 'ChevronDown'\n      };\n    }\n\n    const splitButtonProps = {\n      ...splitButtonMenuProps,\n      styles: classNames,\n      checked: checked,\n      disabled: disabled,\n      allowDisabledFocus: allowDisabledFocus,\n      onClick: this._onMenuClick,\n      menuProps: undefined,\n      iconProps: { ...menuIconProps, className: this._classNames.menuIcon },\n      ariaLabel: splitButtonAriaLabel,\n      'aria-haspopup': true,\n      'aria-expanded': this._isExpanded,\n      'data-is-focusable': false\n    };\n\n    // Add data-ktp-execute-target to the split button if the keytip is defined\n    return (\n      <BaseButton\n        {...splitButtonProps}\n        data-ktp-execute-target={keytipAttributes ? keytipAttributes['data-ktp-execute-target'] : keytipAttributes}\n        onMouseDown={this._onMouseDown}\n        tabIndex={-1}\n      />\n    );\n  }\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>) => {\n    // explicity cancelling event so click won't fire after this\n    if (this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    } else if (!this.props.disabled) {\n      if (this.props.menuProps) {\n        this._onMenuKeyDown(ev);\n      } else if (this.props.onKeyDown !== undefined) {\n        this.props.onKeyDown(ev); // not cancelling event because it's not disabled\n      }\n    }\n  };\n\n  private _onKeyUp = (ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>) => {\n    if (!this.props.disabled && this.props.onKeyUp !== undefined) {\n      this.props.onKeyUp(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onKeyPress = (ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>) => {\n    if (!this.props.disabled && this.props.onKeyPress !== undefined) {\n      this.props.onKeyPress(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onMouseUp = (ev: React.MouseEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>) => {\n    if (!this.props.disabled && this.props.onMouseUp !== undefined) {\n      this.props.onMouseUp(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onMouseDown = (ev: React.MouseEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>) => {\n    if (!this.props.disabled && this.props.onMouseDown !== undefined) {\n      this.props.onMouseDown(ev); // not cancelling event because it's not disabled\n    }\n  };\n\n  private _onClick = (ev: React.MouseEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>) => {\n    if (!this.props.disabled) {\n      if (this.props.menuProps) {\n        this._onMenuClick(ev);\n      } else if (this.props.onClick !== undefined) {\n        this.props.onClick(ev); // not cancelling event because it's not disabled\n      }\n    }\n  };\n\n  private _onSplitButtonContainerKeyDown = (ev: React.KeyboardEvent<HTMLDivElement>) => {\n    if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {\n      if (this._buttonElement.current) {\n        this._buttonElement.current.click();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    } else {\n      this._onMenuKeyDown(ev);\n    }\n  };\n\n  private _onMenuKeyDown = (ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>) => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    const isUp = ev.which === KeyCodes.up;\n    const isDown = ev.which === KeyCodes.down;\n\n    if (!ev.defaultPrevented && this._isValidMenuOpenKey(ev)) {\n      const { onMenuClick } = this.props;\n      if (onMenuClick) {\n        onMenuClick(ev, this);\n      }\n\n      this._onToggleMenu(false);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n\n    if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {\n      this.setState(state => {\n        if (state.menuProps && !state.menuProps.shouldFocusOnMount) {\n          return { menuProps: { ...state.menuProps, shouldFocusOnMount: true } };\n        }\n        return state;\n      });\n\n      // This should be done in the setStateCallback but because preventDefault\n      // needs to be called, we have to evaluate the current state, even though\n      // it might not be 100% accurate;\n      if (this.state.menuProps && !this.state.menuProps.shouldFocusOnMount) {\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  private _onTouchStart: () => void = () => {\n    if (this._isSplitButton && this._splitButtonContainer.current && !('onpointerdown' in this._splitButtonContainer.current)) {\n      this._handleTouchAndPointerEvent();\n    }\n  };\n\n  private _onPointerDown(ev: PointerEvent) {\n    if (ev.pointerType === 'touch') {\n      this._handleTouchAndPointerEvent();\n\n      ev.preventDefault();\n      ev.stopImmediatePropagation();\n    }\n  }\n\n  private _handleTouchAndPointerEvent() {\n    // If we already have an existing timeeout from a previous touch and pointer event\n    // cancel that timeout so we can set a nwe one.\n    if (this._lastTouchTimeoutId !== undefined) {\n      this._async.clearTimeout(this._lastTouchTimeoutId);\n      this._lastTouchTimeoutId = undefined;\n    }\n    this._processingTouch = true;\n\n    this._lastTouchTimeoutId = this._async.setTimeout(() => {\n      this._processingTouch = false;\n      this._lastTouchTimeoutId = undefined;\n    }, TouchIdleDelay);\n  }\n\n  /**\n   * Returns if the user hits a valid keyboard key to open the menu\n   * @param ev - the keyboard event\n   * @returns True if user clicks on custom trigger key if enabled or alt + down arrow if not. False otherwise.\n   */\n  private _isValidMenuOpenKey(ev: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement | HTMLButtonElement>): boolean {\n    if (this.props.menuTriggerKeyCode) {\n      return ev.which === this.props.menuTriggerKeyCode;\n    } else if (this.props.menuProps) {\n      return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);\n    }\n\n    // Note: When enter is pressed, we will let the event continue to propagate\n    // to trigger the onClick event on the button\n    return false;\n  }\n\n  private _onMenuClick = (ev: React.MouseEvent<HTMLDivElement | HTMLButtonElement | HTMLAnchorElement>) => {\n    const { onMenuClick } = this.props;\n    if (onMenuClick) {\n      onMenuClick(ev, this);\n    }\n\n    if (!ev.defaultPrevented) {\n      // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n      // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n      // between a real click event and a keypress event (detail should be the number of mouse clicks).\n      // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n      // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n      // and \"\" for pressing \"Enter\" with Narrator on.\n      const shouldFocusOnContainer = ev.nativeEvent.detail !== 0 || (ev.nativeEvent as PointerEvent).pointerType === 'mouse';\n      this._onToggleMenu(shouldFocusOnContainer);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}