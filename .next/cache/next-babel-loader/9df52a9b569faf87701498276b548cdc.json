{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar React = require(\"react\");\n\nvar Utilities_1 = require(\"../../Utilities\");\n\nvar FocusTrapZone =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(FocusTrapZone, _super);\n\n  function FocusTrapZone(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    _this._firstBumper = React.createRef();\n    _this._lastBumper = React.createRef();\n    _this._hasFocus = false;\n\n    _this._onRootFocus = function (ev) {\n      if (_this.props.onFocus) {\n        _this.props.onFocus(ev);\n      }\n\n      _this._hasFocus = true;\n    };\n\n    _this._onRootBlur = function (ev) {\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n\n      var relatedTarget = ev.relatedTarget;\n\n      if (ev.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the ComboBox\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = _this._getDocument().activeElement;\n      }\n\n      if (!Utilities_1.elementContains(_this._root.current, relatedTarget)) {\n        _this._hasFocus = false;\n      }\n    };\n\n    _this._onFirstBumperFocus = function () {\n      _this._onBumperFocus(true);\n    };\n\n    _this._onLastBumperFocus = function () {\n      _this._onBumperFocus(false);\n    };\n\n    _this._onBumperFocus = function (isFirstBumper) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      var currentBumper = isFirstBumper === _this._hasFocus ? _this._lastBumper.current : _this._firstBumper.current;\n\n      if (_this._root.current) {\n        var nextFocusable = isFirstBumper === _this._hasFocus ? Utilities_1.getLastTabbable(_this._root.current, currentBumper, true, false) : Utilities_1.getFirstTabbable(_this._root.current, currentBumper, true, false);\n\n        if (nextFocusable) {\n          if (_this._isBumper(nextFocusable)) {\n            // This can happen when FTZ contains no tabbable elements. focus will take care of finding a focusable element in FTZ.\n            _this.focus();\n          } else {\n            nextFocusable.focus();\n          }\n        }\n      }\n    };\n\n    _this._onFocusCapture = function (ev) {\n      if (_this.props.onFocusCapture) {\n        _this.props.onFocusCapture(ev);\n      }\n\n      if (ev.target !== ev.currentTarget && !_this._isBumper(ev.target)) {\n        // every time focus changes within the trap zone, remember the focused element so that\n        // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n        _this._previouslyFocusedElementInTrapZone = ev.target;\n      }\n    };\n\n    _this._forceFocusInTrap = function (ev) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (FocusTrapZone._focusStack.length && _this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n        var focusedElement = _this._getDocument().activeElement;\n\n        if (!Utilities_1.elementContains(_this._root.current, focusedElement)) {\n          _this.focus();\n\n          _this._hasFocus = true; // set focus here since we stop event propagation\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    _this._forceClickInTrap = function (ev) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (FocusTrapZone._focusStack.length && _this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n        var clickedElement = ev.target;\n\n        if (clickedElement && !Utilities_1.elementContains(_this._root.current, clickedElement)) {\n          _this.focus();\n\n          _this._hasFocus = true; // set focus here since we stop event propagation\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    Utilities_1.initializeComponentRef(_this);\n    return _this;\n  }\n\n  FocusTrapZone.prototype.componentDidMount = function () {\n    this._bringFocusIntoZone();\n\n    this._updateEventHandlers(this.props);\n  }; // tslint:disable-next-line function-name\n\n\n  FocusTrapZone.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    var elementToFocusOnDismiss = nextProps.elementToFocusOnDismiss;\n\n    if (elementToFocusOnDismiss && this._previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    }\n\n    this._updateEventHandlers(nextProps);\n  };\n\n  FocusTrapZone.prototype.componentDidUpdate = function (prevProps) {\n    var prevForceFocusInsideTrap = prevProps.forceFocusInsideTrap !== undefined ? prevProps.forceFocusInsideTrap : true;\n    var newForceFocusInsideTrap = this.props.forceFocusInsideTrap !== undefined ? this.props.forceFocusInsideTrap : true;\n    var prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;\n    var newDisabled = this.props.disabled !== undefined ? this.props.disabled : false;\n\n    if (!prevForceFocusInsideTrap && newForceFocusInsideTrap || prevDisabled && !newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n      // Emulate what happens when a FocusTrapZone gets mounted.\n      this._bringFocusIntoZone();\n    } else if (prevForceFocusInsideTrap && !newForceFocusInsideTrap || !prevDisabled && newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      // Emulate what happens when a FocusTrapZone gets unmounted.\n      this._returnFocusToInitiator();\n    }\n  };\n\n  FocusTrapZone.prototype.componentWillUnmount = function () {\n    // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n    if (!this.props.disabled || this.props.forceFocusInsideTrap || !Utilities_1.elementContains(this._root.current, this._getDocument().activeElement)) {\n      this._returnFocusToInitiator();\n    }\n  };\n\n  FocusTrapZone.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        _b = _a.disabled,\n        disabled = _b === void 0 ? false : _b,\n        ariaLabelledBy = _a.ariaLabelledBy;\n    var divProps = Utilities_1.getNativeProps(this.props, Utilities_1.divProperties);\n    var bumperProps = {\n      style: {\n        pointerEvents: 'none',\n        position: 'fixed' // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n\n      },\n      tabIndex: disabled ? -1 : 0,\n      'data-is-visible': true\n    };\n    return React.createElement(\"div\", tslib_1.__assign({}, divProps, {\n      className: className,\n      ref: this._root,\n      \"aria-labelledby\": ariaLabelledBy,\n      onFocusCapture: this._onFocusCapture,\n      onFocus: this._onRootFocus,\n      onBlur: this._onRootBlur\n    }), React.createElement(\"div\", tslib_1.__assign({}, bumperProps, {\n      ref: this._firstBumper,\n      onFocus: this._onFirstBumperFocus\n    })), this.props.children, React.createElement(\"div\", tslib_1.__assign({}, bumperProps, {\n      ref: this._lastBumper,\n      onFocus: this._onLastBumperFocus\n    })));\n  };\n\n  FocusTrapZone.prototype.focus = function () {\n    var _a = this.props,\n        focusPreviouslyFocusedInnerElement = _a.focusPreviouslyFocusedInnerElement,\n        firstFocusableSelector = _a.firstFocusableSelector;\n\n    if (focusPreviouslyFocusedInnerElement && this._previouslyFocusedElementInTrapZone && Utilities_1.elementContains(this._root.current, this._previouslyFocusedElementInTrapZone)) {\n      // focus on the last item that had focus in the zone before we left the zone\n      this._focusAsync(this._previouslyFocusedElementInTrapZone);\n\n      return;\n    }\n\n    var focusSelector = typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector && firstFocusableSelector();\n    var _firstFocusableChild = null;\n\n    if (this._root.current) {\n      if (focusSelector) {\n        _firstFocusableChild = this._root.current.querySelector('.' + focusSelector);\n      } // Fall back to first element if query selector did not match any elements.\n\n\n      if (!_firstFocusableChild) {\n        _firstFocusableChild = Utilities_1.getNextElement(this._root.current, this._root.current.firstChild, false, false, false, true);\n      }\n    }\n\n    if (_firstFocusableChild) {\n      this._focusAsync(_firstFocusableChild);\n    }\n  };\n\n  FocusTrapZone.prototype._focusAsync = function (element) {\n    if (!this._isBumper(element)) {\n      Utilities_1.focusAsync(element);\n    }\n  };\n\n  FocusTrapZone.prototype._bringFocusIntoZone = function () {\n    var _a = this.props,\n        elementToFocusOnDismiss = _a.elementToFocusOnDismiss,\n        _b = _a.disabled,\n        disabled = _b === void 0 ? false : _b,\n        _c = _a.disableFirstFocus,\n        disableFirstFocus = _c === void 0 ? false : _c;\n\n    if (disabled) {\n      return;\n    }\n\n    FocusTrapZone._focusStack.push(this);\n\n    this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss ? elementToFocusOnDismiss : this._getDocument().activeElement;\n\n    if (!disableFirstFocus && !Utilities_1.elementContains(this._root.current, this._previouslyFocusedElementOutsideTrapZone)) {\n      this.focus();\n    }\n  };\n\n  FocusTrapZone.prototype._returnFocusToInitiator = function () {\n    var _this = this;\n\n    var ignoreExternalFocusing = this.props.ignoreExternalFocusing;\n    FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter(function (value) {\n      return _this !== value;\n    });\n\n    var doc = this._getDocument();\n\n    var activeElement = doc.activeElement;\n\n    if (!ignoreExternalFocusing && this._previouslyFocusedElementOutsideTrapZone && typeof this._previouslyFocusedElementOutsideTrapZone.focus === 'function' && (Utilities_1.elementContains(this._root.current, activeElement) || activeElement === doc.body)) {\n      this._focusAsync(this._previouslyFocusedElementOutsideTrapZone);\n    }\n  };\n\n  FocusTrapZone.prototype._updateEventHandlers = function (newProps) {\n    var _a = newProps.isClickableOutsideFocusTrap,\n        isClickableOutsideFocusTrap = _a === void 0 ? false : _a,\n        _b = newProps.forceFocusInsideTrap,\n        forceFocusInsideTrap = _b === void 0 ? true : _b;\n\n    if (forceFocusInsideTrap && !this._disposeFocusHandler) {\n      this._disposeFocusHandler = Utilities_1.on(window, 'focus', this._forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !this._disposeClickHandler) {\n      this._disposeClickHandler = Utilities_1.on(window, 'click', this._forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && this._disposeClickHandler) {\n      this._disposeClickHandler();\n\n      this._disposeClickHandler = undefined;\n    }\n  };\n\n  FocusTrapZone.prototype._isBumper = function (element) {\n    return element === this._firstBumper.current || element === this._lastBumper.current;\n  };\n\n  FocusTrapZone.prototype._getDocument = function () {\n    return Utilities_1.getDocument(this._root.current);\n  };\n\n  FocusTrapZone._focusStack = [];\n  return FocusTrapZone;\n}(React.Component);\n\nexports.FocusTrapZone = FocusTrapZone;","map":{"version":3,"sources":["components/FocusTrapZone/FocusTrapZone.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  elementContains,\n  getNativeProps,\n  divProperties,\n  getFirstTabbable,\n  getLastTabbable,\n  getNextElement,\n  getDocument,\n  focusAsync,\n  initializeComponentRef,\n  on\n} from '../../Utilities';\nimport { IFocusTrapZone, IFocusTrapZoneProps } from './FocusTrapZone.types';\n\nexport class FocusTrapZone extends React.Component<IFocusTrapZoneProps, {}> implements IFocusTrapZone {\n  private static _focusStack: FocusTrapZone[] = [];\n\n  private _root = React.createRef<HTMLDivElement>();\n  private _firstBumper = React.createRef<HTMLDivElement>();\n  private _lastBumper = React.createRef<HTMLDivElement>();\n  private _hasFocus: boolean = false;\n\n  private _previouslyFocusedElementOutsideTrapZone: HTMLElement;\n  private _previouslyFocusedElementInTrapZone?: HTMLElement;\n  private _disposeFocusHandler: (() => void) | undefined;\n  private _disposeClickHandler: (() => void) | undefined;\n\n  public constructor(props: IFocusTrapZoneProps) {\n    super(props);\n    initializeComponentRef(this);\n  }\n\n  public componentDidMount(): void {\n    this._bringFocusIntoZone();\n    this._updateEventHandlers(this.props);\n  }\n\n  // tslint:disable-next-line function-name\n  public UNSAFE_componentWillReceiveProps(nextProps: IFocusTrapZoneProps): void {\n    const { elementToFocusOnDismiss } = nextProps;\n    if (elementToFocusOnDismiss && this._previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    }\n\n    this._updateEventHandlers(nextProps);\n  }\n\n  public componentDidUpdate(prevProps: IFocusTrapZoneProps) {\n    const prevForceFocusInsideTrap = prevProps.forceFocusInsideTrap !== undefined ? prevProps.forceFocusInsideTrap : true;\n    const newForceFocusInsideTrap = this.props.forceFocusInsideTrap !== undefined ? this.props.forceFocusInsideTrap : true;\n    const prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;\n    const newDisabled = this.props.disabled !== undefined ? this.props.disabled : false;\n\n    if ((!prevForceFocusInsideTrap && newForceFocusInsideTrap) || (prevDisabled && !newDisabled)) {\n      // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n      // Emulate what happens when a FocusTrapZone gets mounted.\n      this._bringFocusIntoZone();\n    } else if ((prevForceFocusInsideTrap && !newForceFocusInsideTrap) || (!prevDisabled && newDisabled)) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      // Emulate what happens when a FocusTrapZone gets unmounted.\n      this._returnFocusToInitiator();\n    }\n  }\n\n  public componentWillUnmount(): void {\n    // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n    if (\n      !this.props.disabled ||\n      this.props.forceFocusInsideTrap ||\n      !elementContains(this._root.current, this._getDocument().activeElement as HTMLElement)\n    ) {\n      this._returnFocusToInitiator();\n    }\n  }\n\n  public render(): JSX.Element {\n    const { className, disabled = false, ariaLabelledBy } = this.props;\n    const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties);\n\n    const bumperProps = {\n      style: {\n        pointerEvents: 'none',\n        position: 'fixed' // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n      },\n      tabIndex: disabled ? -1 : 0, // make bumpers tabbable only when enabled\n      'data-is-visible': true\n    } as React.HTMLAttributes<HTMLDivElement>;\n\n    return (\n      <div\n        {...divProps}\n        className={className}\n        ref={this._root}\n        aria-labelledby={ariaLabelledBy}\n        onFocusCapture={this._onFocusCapture}\n        onFocus={this._onRootFocus}\n        onBlur={this._onRootBlur}\n      >\n        <div {...bumperProps} ref={this._firstBumper} onFocus={this._onFirstBumperFocus} />\n        {this.props.children}\n        <div {...bumperProps} ref={this._lastBumper} onFocus={this._onLastBumperFocus} />\n      </div>\n    );\n  }\n\n  public focus() {\n    const { focusPreviouslyFocusedInnerElement, firstFocusableSelector } = this.props;\n\n    if (\n      focusPreviouslyFocusedInnerElement &&\n      this._previouslyFocusedElementInTrapZone &&\n      elementContains(this._root.current, this._previouslyFocusedElementInTrapZone)\n    ) {\n      // focus on the last item that had focus in the zone before we left the zone\n      this._focusAsync(this._previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    const focusSelector =\n      typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector && firstFocusableSelector();\n\n    let _firstFocusableChild: HTMLElement | null = null;\n\n    if (this._root.current) {\n      if (focusSelector) {\n        _firstFocusableChild = this._root.current.querySelector('.' + focusSelector);\n      }\n\n      // Fall back to first element if query selector did not match any elements.\n      if (!_firstFocusableChild) {\n        _firstFocusableChild = getNextElement(this._root.current, this._root.current.firstChild as HTMLElement, false, false, false, true);\n      }\n    }\n    if (_firstFocusableChild) {\n      this._focusAsync(_firstFocusableChild);\n    }\n  }\n\n  private _focusAsync(element: HTMLElement): void {\n    if (!this._isBumper(element)) {\n      focusAsync(element);\n    }\n  }\n\n  private _onRootFocus = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onFocus) {\n      this.props.onFocus(ev);\n    }\n\n    this._hasFocus = true;\n  };\n\n  private _onRootBlur = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onBlur) {\n      this.props.onBlur(ev);\n    }\n\n    let relatedTarget = ev.relatedTarget;\n    if (ev.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the ComboBox\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = this._getDocument().activeElement as Element;\n    }\n\n    if (!elementContains(this._root.current, relatedTarget as HTMLElement)) {\n      this._hasFocus = false;\n    }\n  };\n\n  private _onFirstBumperFocus = () => {\n    this._onBumperFocus(true);\n  };\n\n  private _onLastBumperFocus = () => {\n    this._onBumperFocus(false);\n  };\n\n  private _onBumperFocus = (isFirstBumper: boolean) => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    const currentBumper = (isFirstBumper === this._hasFocus ? this._lastBumper.current : this._firstBumper.current) as HTMLElement;\n\n    if (this._root.current) {\n      const nextFocusable =\n        isFirstBumper === this._hasFocus\n          ? getLastTabbable(this._root.current, currentBumper, true, false)\n          : getFirstTabbable(this._root.current, currentBumper, true, false);\n\n      if (nextFocusable) {\n        if (this._isBumper(nextFocusable)) {\n          // This can happen when FTZ contains no tabbable elements. focus will take care of finding a focusable element in FTZ.\n          this.focus();\n        } else {\n          nextFocusable.focus();\n        }\n      }\n    }\n  };\n\n  private _bringFocusIntoZone(): void {\n    const { elementToFocusOnDismiss, disabled = false, disableFirstFocus = false } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    FocusTrapZone._focusStack.push(this);\n\n    this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss\n      ? elementToFocusOnDismiss\n      : (this._getDocument().activeElement as HTMLElement);\n    if (!disableFirstFocus && !elementContains(this._root.current, this._previouslyFocusedElementOutsideTrapZone)) {\n      this.focus();\n    }\n  }\n\n  private _returnFocusToInitiator(): void {\n    const { ignoreExternalFocusing } = this.props;\n\n    FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter((value: FocusTrapZone) => {\n      return this !== value;\n    });\n\n    const doc = this._getDocument();\n    const activeElement = doc.activeElement as HTMLElement;\n    if (\n      !ignoreExternalFocusing &&\n      this._previouslyFocusedElementOutsideTrapZone &&\n      typeof this._previouslyFocusedElementOutsideTrapZone.focus === 'function' &&\n      (elementContains(this._root.current, activeElement) || activeElement === doc.body)\n    ) {\n      this._focusAsync(this._previouslyFocusedElementOutsideTrapZone);\n    }\n  }\n\n  private _updateEventHandlers(newProps: IFocusTrapZoneProps): void {\n    const { isClickableOutsideFocusTrap = false, forceFocusInsideTrap = true } = newProps;\n\n    if (forceFocusInsideTrap && !this._disposeFocusHandler) {\n      this._disposeFocusHandler = on(window, 'focus', this._forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !this._disposeClickHandler) {\n      this._disposeClickHandler = on(window, 'click', this._forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && this._disposeClickHandler) {\n      this._disposeClickHandler();\n      this._disposeClickHandler = undefined;\n    }\n  }\n\n  private _onFocusCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onFocusCapture) {\n      this.props.onFocusCapture(ev);\n    }\n\n    if (ev.target !== ev.currentTarget && !this._isBumper(ev.target)) {\n      // every time focus changes within the trap zone, remember the focused element so that\n      // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n      this._previouslyFocusedElementInTrapZone = ev.target as HTMLElement;\n    }\n  };\n\n  private _isBumper(element: HTMLElement): boolean {\n    return element === this._firstBumper.current || element === this._lastBumper.current;\n  }\n\n  private _forceFocusInTrap = (ev: FocusEvent): void => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n      const focusedElement = this._getDocument().activeElement as HTMLElement;\n\n      if (!elementContains(this._root.current, focusedElement)) {\n        this.focus();\n        this._hasFocus = true; // set focus here since we stop event propagation\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  private _forceClickInTrap = (ev: MouseEvent): void => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n      const clickedElement = ev.target as HTMLElement;\n\n      if (clickedElement && !elementContains(this._root.current, clickedElement)) {\n        this.focus();\n        this._hasFocus = true; // set focus here since we stop event propagation\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  private _getDocument(): Document {\n    return getDocument(this._root.current)!;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"script"}