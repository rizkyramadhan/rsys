{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar React = require(\"react\");\n\nvar KeytipLayer_styles_1 = require(\"./KeytipLayer.styles\");\n\nvar Keytip_1 = require(\"../../Keytip\");\n\nvar Layer_1 = require(\"../../Layer\");\n\nvar Utilities_1 = require(\"../../Utilities\");\n\nvar KeytipManager_1 = require(\"../../utilities/keytips/KeytipManager\");\n\nvar KeytipTree_1 = require(\"./KeytipTree\");\n\nvar KeytipUtils_1 = require(\"../../utilities/keytips/KeytipUtils\");\n\nvar IKeytipTransitionKey_1 = require(\"../../utilities/keytips/IKeytipTransitionKey\");\n\nvar KeytipConstants_1 = require(\"../../utilities/keytips/KeytipConstants\"); // Default sequence is Alt-Windows (Alt-Meta) in Windows, Option-Control (Alt-Control) in Mac\n\n\nvar defaultStartSequence = {\n  key: Utilities_1.isMac() ? 'Control' : 'Meta',\n  modifierKeys: [IKeytipTransitionKey_1.KeytipTransitionModifier.alt]\n}; // Default exit sequence is the same as the start sequence\n\nvar defaultExitSequence = defaultStartSequence; // Default return sequence is Escape\n\nvar defaultReturnSequence = {\n  key: 'Escape'\n};\nvar getClassNames = Utilities_1.classNamesFunction();\n/**\n * A layer that holds all keytip items\n * {@docCategory Keytips}\n */\n\nvar KeytipLayerBase =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(KeytipLayerBase, _super); // tslint:disable-next-line:no-any\n\n\n  function KeytipLayerBase(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this._keytipManager = KeytipManager_1.KeytipManager.getInstance();\n    _this._delayedKeytipQueue = [];\n    _this._keyHandled = false;\n\n    _this._onDismiss = function (ev) {\n      // if we are in keytip mode, then exit keytip mode\n      if (_this.state.inKeytipMode) {\n        _this._exitKeytipMode(ev);\n      }\n    };\n\n    _this._onKeyDown = function (ev) {\n      _this._keyHandled = false; // using key since which has been deprecated and key is now widely suporrted.\n      // See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which\n\n      var key = ev.key;\n\n      switch (key) {\n        case 'Alt':\n          // ALT puts focus in the browser bar, so it should not be used as a key for keytips.\n          // It can be used as a modifier\n          break;\n\n        case 'Tab':\n        case 'Enter':\n        case 'Spacebar':\n        case ' ':\n        case 'ArrowUp':\n        case 'Up':\n        case 'ArrowDown':\n        case 'Down':\n        case 'ArrowLeft':\n        case 'Left':\n        case 'ArrowRight':\n        case 'Right':\n          if (_this.state.inKeytipMode) {\n            _this._keyHandled = true;\n\n            _this._exitKeytipMode(ev);\n          }\n\n          break;\n\n        default:\n          // Special cases for browser-specific keys that are not at standard\n          // (according to http://www.w3.org/TR/uievents-key/#keys-navigation)\n          if (key === 'Esc') {\n            // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/5290772/\n            key = 'Escape';\n          } else if (key === 'OS' || key === 'Win') {\n            // Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1232918\n            // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n            // and https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/16424492/\n            key = 'Meta';\n          }\n\n          var transitionKey = {\n            key: key\n          };\n          transitionKey.modifierKeys = _this._getModifierKey(key, ev);\n\n          _this.processTransitionInput(transitionKey, ev);\n\n          break;\n      }\n    };\n\n    _this._onKeyPress = function (ev) {\n      if (_this.state.inKeytipMode && !_this._keyHandled) {\n        // Call processInput\n        _this.processInput(ev.key.toLocaleLowerCase(), ev);\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    };\n\n    _this._onKeytipAdded = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n\n      _this._keytipTree.addNode(keytipProps, uniqueID);\n\n      _this._setKeytips(); // Add the keytip to the queue to show later\n\n\n      if (_this._keytipTree.isCurrentKeytipParent(keytipProps)) {\n        _this._addKeytipToQueue(KeytipUtils_1.sequencesToID(keytipProps.keySequences)); // Check to make sure that child of currentKeytip is successfully added to currentKeytip's children and update it if not\n        // Note: Added this condition because KeytipTree.addNode was not always reflecting updates made to a parent node in currentKeytip\n        // when that parent is the currentKeytip\n\n\n        if (_this._keytipTree.currentKeytip && _this._keytipTree.currentKeytip.hasDynamicChildren && _this._keytipTree.currentKeytip.children.indexOf(keytipProps.id) < 0) {\n          _this._keytipTree.currentKeytip = _this._keytipTree.getNode(_this._keytipTree.currentKeytip.id);\n        }\n      }\n\n      if (_this._newCurrentKeytipSequences && Utilities_1.arraysEqual(keytipProps.keySequences, _this._newCurrentKeytipSequences)) {\n        _this._triggerKeytipImmediately(keytipProps);\n      }\n\n      if (_this._isCurrentKeytipAnAlias(keytipProps)) {\n        var keytipSequence = keytipProps.keySequences;\n\n        if (keytipProps.overflowSetSequence) {\n          keytipSequence = KeytipUtils_1.mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);\n        }\n\n        _this._keytipTree.currentKeytip = _this._keytipTree.getNode(KeytipUtils_1.sequencesToID(keytipSequence));\n      }\n    };\n\n    _this._onKeytipUpdated = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n\n      _this._keytipTree.updateNode(keytipProps, uniqueID);\n\n      _this._setKeytips();\n    };\n\n    _this._onKeytipRemoved = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID; // Remove keytip from the delayed queue\n\n      _this._removeKeytipFromQueue(KeytipUtils_1.sequencesToID(keytipProps.keySequences)); // Remove the node from the Tree\n\n\n      _this._keytipTree.removeNode(keytipProps, uniqueID);\n\n      _this._setKeytips();\n    };\n\n    _this._onPersistedKeytipAdded = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n\n      _this._keytipTree.addNode(keytipProps, uniqueID, true);\n    };\n\n    _this._onPersistedKeytipRemoved = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n\n      _this._keytipTree.removeNode(keytipProps, uniqueID);\n    };\n\n    _this._onPersistedKeytipExecute = function (eventArgs) {\n      _this._persistedKeytipExecute(eventArgs.overflowButtonSequences, eventArgs.keytipSequences);\n    };\n    /**\n     * Sets if we are in keytip mode.\n     * Note, this sets both the state for the layer as well as\n     * the value that the manager will expose externally.\n     * @param inKeytipMode - Boolean so set whether we are in keytip mode or not\n     */\n\n\n    _this._setInKeytipMode = function (inKeytipMode) {\n      _this.setState({\n        inKeytipMode: inKeytipMode\n      });\n\n      _this._keytipManager.inKeytipMode = inKeytipMode;\n    };\n    /**\n     * Emits a warning if duplicate keytips are found for the children of the current keytip\n     */\n\n\n    _this._warnIfDuplicateKeytips = function () {\n      var duplicateKeytips = _this._getDuplicateIds(_this._keytipTree.getChildren());\n\n      if (duplicateKeytips.length) {\n        Utilities_1.warn('Duplicate keytips found for ' + duplicateKeytips.join(', '));\n      }\n    };\n    /**\n     * Returns duplicates among keytip IDs\n     * If the returned array is empty, no duplicates were found\n     *\n     * @param keytipIds - Array of keytip IDs to find duplicates for\n     * @returns - Array of duplicates that were found. If multiple duplicates were found it will only be added once to this array\n     */\n\n\n    _this._getDuplicateIds = function (keytipIds) {\n      var seenIds = {};\n      return keytipIds.filter(function (keytipId) {\n        seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1; // Only add the first duplicate keytip seen\n\n        return seenIds[keytipId] === 2;\n      });\n    };\n\n    var managerKeytips = _this._keytipManager.getKeytips().slice();\n\n    _this.state = {\n      inKeytipMode: false,\n      // Get the initial set of keytips\n      keytips: managerKeytips,\n      visibleKeytips: _this._getVisibleKeytips(managerKeytips)\n    };\n    _this._keytipTree = new KeytipTree_1.KeytipTree(); // Add regular and persisted keytips to the tree\n\n    for (var _i = 0, _a = _this._keytipManager.keytips.concat(_this._keytipManager.persistedKeytips); _i < _a.length; _i++) {\n      var uniqueKeytip = _a[_i];\n\n      _this._keytipTree.addNode(uniqueKeytip.keytip, uniqueKeytip.uniqueID);\n    }\n\n    _this._currentSequence = ''; // Add keytip listeners\n\n    _this._events.on(_this._keytipManager, KeytipConstants_1.KeytipEvents.KEYTIP_ADDED, _this._onKeytipAdded);\n\n    _this._events.on(_this._keytipManager, KeytipConstants_1.KeytipEvents.KEYTIP_UPDATED, _this._onKeytipUpdated);\n\n    _this._events.on(_this._keytipManager, KeytipConstants_1.KeytipEvents.KEYTIP_REMOVED, _this._onKeytipRemoved);\n\n    _this._events.on(_this._keytipManager, KeytipConstants_1.KeytipEvents.PERSISTED_KEYTIP_ADDED, _this._onPersistedKeytipAdded);\n\n    _this._events.on(_this._keytipManager, KeytipConstants_1.KeytipEvents.PERSISTED_KEYTIP_REMOVED, _this._onPersistedKeytipRemoved);\n\n    _this._events.on(_this._keytipManager, KeytipConstants_1.KeytipEvents.PERSISTED_KEYTIP_EXECUTE, _this._onPersistedKeytipExecute);\n\n    return _this;\n  }\n\n  KeytipLayerBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        content = _a.content,\n        styles = _a.styles;\n    var _b = this.state,\n        keytips = _b.keytips,\n        visibleKeytips = _b.visibleKeytips;\n    this._classNames = getClassNames(styles, {});\n    return React.createElement(Layer_1.Layer, {\n      styles: KeytipLayer_styles_1.getLayerStyles\n    }, React.createElement(\"span\", {\n      id: KeytipConstants_1.KTP_LAYER_ID,\n      className: this._classNames.innerContent\n    }, \"\" + content + KeytipConstants_1.KTP_ARIA_SEPARATOR), keytips && keytips.map(function (keytipProps, index) {\n      return React.createElement(\"span\", {\n        key: index,\n        id: KeytipUtils_1.sequencesToID(keytipProps.keySequences),\n        className: _this._classNames.innerContent\n      }, keytipProps.keySequences.join(KeytipConstants_1.KTP_ARIA_SEPARATOR));\n    }), visibleKeytips && visibleKeytips.map(function (visibleKeytipProps) {\n      return React.createElement(Keytip_1.Keytip, tslib_1.__assign({\n        key: KeytipUtils_1.sequencesToID(visibleKeytipProps.keySequences)\n      }, visibleKeytipProps));\n    }));\n  };\n\n  KeytipLayerBase.prototype.componentDidMount = function () {\n    // Add window listeners\n    this._events.on(window, 'mouseup', this._onDismiss, true\n    /* useCapture */\n    );\n\n    this._events.on(window, 'pointerup', this._onDismiss, true\n    /* useCapture */\n    );\n\n    this._events.on(window, 'resize', this._onDismiss);\n\n    this._events.on(window, 'keydown', this._onKeyDown, true\n    /* useCapture */\n    );\n\n    this._events.on(window, 'keypress', this._onKeyPress, true\n    /* useCapture */\n    );\n\n    this._events.on(window, 'scroll', this._onDismiss, true\n    /* useCapture */\n    ); // Add keytip listeners\n\n\n    this._events.on(this._keytipManager, KeytipConstants_1.KeytipEvents.ENTER_KEYTIP_MODE, this._enterKeytipMode);\n\n    this._events.on(this._keytipManager, KeytipConstants_1.KeytipEvents.EXIT_KEYTIP_MODE, this._exitKeytipMode);\n  };\n\n  KeytipLayerBase.prototype.componentWillUnmount = function () {\n    // Remove window listeners\n    this._events.off(window, 'mouseup', this._onDismiss, true\n    /* useCapture */\n    );\n\n    this._events.off(window, 'pointerup', this._onDismiss, true\n    /* useCapture */\n    );\n\n    this._events.off(window, 'resize', this._onDismiss);\n\n    this._events.off(window, 'keydown', this._onKeyDown, true\n    /* useCapture */\n    );\n\n    this._events.off(window, 'keypress', this._onKeyPress, true\n    /* useCapture */\n    );\n\n    this._events.off(window, 'scroll', this._onDismiss, true\n    /* useCapture */\n    ); // Remove keytip listeners\n\n\n    this._events.off(this._keytipManager, KeytipConstants_1.KeytipEvents.KEYTIP_ADDED, this._onKeytipAdded);\n\n    this._events.off(this._keytipManager, KeytipConstants_1.KeytipEvents.KEYTIP_UPDATED, this._onKeytipUpdated);\n\n    this._events.off(this._keytipManager, KeytipConstants_1.KeytipEvents.KEYTIP_REMOVED, this._onKeytipRemoved);\n\n    this._events.off(this._keytipManager, KeytipConstants_1.KeytipEvents.PERSISTED_KEYTIP_ADDED, this._onPersistedKeytipAdded);\n\n    this._events.off(this._keytipManager, KeytipConstants_1.KeytipEvents.PERSISTED_KEYTIP_REMOVED, this._onPersistedKeytipRemoved);\n\n    this._events.off(this._keytipManager, KeytipConstants_1.KeytipEvents.PERSISTED_KEYTIP_EXECUTE, this._onPersistedKeytipExecute);\n\n    this._events.off(this._keytipManager, KeytipConstants_1.KeytipEvents.ENTER_KEYTIP_MODE, this._enterKeytipMode);\n\n    this._events.off(this._keytipManager, KeytipConstants_1.KeytipEvents.EXIT_KEYTIP_MODE, this._exitKeytipMode);\n  }; // The below public functions are only public for testing purposes\n  // They are not intended to be used in app code by using a KeytipLayer reference\n\n\n  KeytipLayerBase.prototype.getCurrentSequence = function () {\n    return this._currentSequence;\n  };\n\n  KeytipLayerBase.prototype.getKeytipTree = function () {\n    return this._keytipTree;\n  };\n  /**\n   * Processes an IKeytipTransitionKey entered by the user\n   *\n   * @param transitionKey - IKeytipTransitionKey received by the layer to process\n   */\n\n\n  KeytipLayerBase.prototype.processTransitionInput = function (transitionKey, ev) {\n    var currKtp = this._keytipTree.currentKeytip;\n\n    if (IKeytipTransitionKey_1.transitionKeysContain(this.props.keytipExitSequences, transitionKey) && currKtp) {\n      // If key sequence is in 'exit sequences', exit keytip mode\n      this._keyHandled = true;\n\n      this._exitKeytipMode(ev);\n    } else if (IKeytipTransitionKey_1.transitionKeysContain(this.props.keytipReturnSequences, transitionKey)) {\n      // If key sequence is in return sequences, move currentKeytip to parent (or if currentKeytip is the root, exit)\n      if (currKtp) {\n        this._keyHandled = true;\n\n        if (currKtp.id === this._keytipTree.root.id) {\n          // We are at the root, exit keytip mode\n          this._exitKeytipMode(ev);\n        } else {\n          // If this keytip has a onReturn prop, we execute the func.\n          if (currKtp.onReturn) {\n            currKtp.onReturn(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp));\n          } // Reset currentSequence\n\n\n          this._currentSequence = ''; // Return pointer to its parent\n\n          this._keytipTree.currentKeytip = this._keytipTree.getNode(currKtp.parent); // Show children keytips of the new currentKeytip\n\n          this.showKeytips(this._keytipTree.getChildren());\n\n          this._warnIfDuplicateKeytips();\n        }\n      }\n    } else if (IKeytipTransitionKey_1.transitionKeysContain(this.props.keytipStartSequences, transitionKey) && !currKtp) {\n      // If key sequence is in 'entry sequences' and currentKeytip is null, we enter keytip mode\n      this._keyHandled = true;\n\n      this._enterKeytipMode();\n\n      this._warnIfDuplicateKeytips();\n    }\n  };\n  /**\n   * Processes inputs from the document listener and traverse the keytip tree\n   *\n   * @param key - Key pressed by the user\n   */\n\n\n  KeytipLayerBase.prototype.processInput = function (key, ev) {\n    // Concat the input key with the current sequence\n    var currSequence = this._currentSequence + key;\n    var currKtp = this._keytipTree.currentKeytip; // currentKeytip must be defined, otherwise we haven't entered keytip mode yet\n\n    if (currKtp) {\n      var node = this._keytipTree.getExactMatchedNode(currSequence, currKtp);\n\n      if (node) {\n        this._keytipTree.currentKeytip = currKtp = node;\n\n        var currKtpChildren = this._keytipTree.getChildren(); // Execute this node's onExecute if defined\n\n\n        if (currKtp.onExecute) {\n          currKtp.onExecute(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp)); // Reset currKtp, this might have changed from the onExecute\n\n          currKtp = this._keytipTree.currentKeytip;\n        } // To exit keytipMode after executing the keytip it must not have a menu or have dynamic children\n\n\n        if (currKtpChildren.length === 0 && !(currKtp.hasDynamicChildren || currKtp.hasMenu)) {\n          this._exitKeytipMode(ev);\n        } else {\n          // Show all children keytips\n          this.showKeytips(currKtpChildren);\n\n          this._warnIfDuplicateKeytips();\n        } // Clear currentSequence\n\n\n        this._currentSequence = '';\n        return;\n      }\n\n      var partialNodes = this._keytipTree.getPartiallyMatchedNodes(currSequence, currKtp);\n\n      if (partialNodes.length > 0) {\n        // We found nodes that partially match the sequence, so we show only those\n        // Omit showing persisted nodes here\n        var ids = partialNodes.filter(function (partialNode) {\n          return !partialNode.persisted;\n        }).map(function (partialNode) {\n          return partialNode.id;\n        });\n        this.showKeytips(ids); // Save currentSequence\n\n        this._currentSequence = currSequence;\n      }\n    }\n  };\n  /**\n   * Show the given keytips and hide all others\n   *\n   * @param ids - Keytip IDs to show\n   */\n\n\n  KeytipLayerBase.prototype.showKeytips = function (ids) {\n    // Update the visible prop in the manager\n    for (var _i = 0, _a = this._keytipManager.getKeytips(); _i < _a.length; _i++) {\n      var keytip = _a[_i];\n      var keytipId = KeytipUtils_1.sequencesToID(keytip.keySequences);\n\n      if (ids.indexOf(keytipId) >= 0) {\n        keytip.visible = true;\n      } else if (keytip.overflowSetSequence && ids.indexOf(KeytipUtils_1.sequencesToID(KeytipUtils_1.mergeOverflows(keytip.keySequences, keytip.overflowSetSequence))) >= 0) {\n        // Check if the ID with the overflow is the keytip we're looking for\n        keytip.visible = true;\n      } else {\n        keytip.visible = false;\n      }\n    } // Apply the manager changes to the Layer state\n\n\n    this._setKeytips();\n  };\n  /**\n   * Enters keytip mode for this layer\n   */\n\n\n  KeytipLayerBase.prototype._enterKeytipMode = function () {\n    if (this._keytipManager.shouldEnterKeytipMode) {\n      this._keytipTree.currentKeytip = this._keytipTree.root; // Show children of root\n\n      this.showKeytips(this._keytipTree.getChildren());\n\n      this._setInKeytipMode(true\n      /* inKeytipMode */\n      );\n\n      if (this.props.onEnterKeytipMode) {\n        this.props.onEnterKeytipMode();\n      }\n    }\n  };\n  /**\n   * Exits keytip mode for this layer\n   */\n\n\n  KeytipLayerBase.prototype._exitKeytipMode = function (ev) {\n    this._keytipTree.currentKeytip = undefined;\n    this._currentSequence = ''; // Hide all keytips\n\n    this.showKeytips([]); // Reset the delayed keytips if any\n\n    this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n    this._delayedKeytipQueue = [];\n\n    this._setInKeytipMode(false\n    /* inKeytipMode */\n    );\n\n    if (this.props.onExitKeytipMode) {\n      this.props.onExitKeytipMode(ev);\n    }\n  };\n  /**\n   * Sets the keytips state property\n   *\n   * @param keytipProps - Keytips to set in this layer\n   */\n\n\n  KeytipLayerBase.prototype._setKeytips = function (keytipProps) {\n    if (keytipProps === void 0) {\n      keytipProps = this._keytipManager.getKeytips();\n    }\n\n    this.setState({\n      keytips: keytipProps,\n      visibleKeytips: this._getVisibleKeytips(keytipProps)\n    });\n  };\n  /**\n   * Callback function to use for persisted keytips\n   *\n   * @param overflowButtonSequences - The overflow button sequence to execute\n   * @param keytipSequences - The keytip that should become the 'currentKeytip' when it is registered\n   */\n\n\n  KeytipLayerBase.prototype._persistedKeytipExecute = function (overflowButtonSequences, keytipSequences) {\n    // Save newCurrentKeytip for later\n    this._newCurrentKeytipSequences = keytipSequences; // Execute the overflow button's onExecute\n\n    var overflowKeytipNode = this._keytipTree.getNode(KeytipUtils_1.sequencesToID(overflowButtonSequences));\n\n    if (overflowKeytipNode && overflowKeytipNode.onExecute) {\n      overflowKeytipNode.onExecute(this._getKtpExecuteTarget(overflowKeytipNode), this._getKtpTarget(overflowKeytipNode));\n    }\n  };\n\n  KeytipLayerBase.prototype._getVisibleKeytips = function (keytips) {\n    // Filter out non-visible keytips and duplicates\n    var seenIds = {};\n    return keytips.filter(function (keytip) {\n      var keytipId = KeytipUtils_1.sequencesToID(keytip.keySequences);\n      seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1;\n      return keytip.visible && seenIds[keytipId] === 1;\n    });\n  };\n  /**\n   * Gets the ModifierKeyCodes based on the keyboard event\n   *\n   * @param ev - React.KeyboardEvent\n   * @returns List of ModifierKeyCodes that were pressed\n   */\n\n\n  KeytipLayerBase.prototype._getModifierKey = function (key, ev) {\n    var modifierKeys = [];\n\n    if (ev.altKey && key !== 'Alt') {\n      modifierKeys.push(IKeytipTransitionKey_1.KeytipTransitionModifier.alt);\n    }\n\n    if (ev.ctrlKey && key !== 'Control') {\n      modifierKeys.push(IKeytipTransitionKey_1.KeytipTransitionModifier.ctrl);\n    }\n\n    if (ev.shiftKey && key !== 'Shift') {\n      modifierKeys.push(IKeytipTransitionKey_1.KeytipTransitionModifier.shift);\n    }\n\n    if (ev.metaKey && key !== 'Meta') {\n      modifierKeys.push(IKeytipTransitionKey_1.KeytipTransitionModifier.meta);\n    }\n\n    return modifierKeys.length ? modifierKeys : undefined;\n  };\n  /**\n   * Trigger a keytip immediately and set it as the current keytip\n   *\n   * @param keytipProps - Keytip to trigger immediately\n   */\n\n\n  KeytipLayerBase.prototype._triggerKeytipImmediately = function (keytipProps) {\n    // This keytip should become the currentKeytip and should execute right away\n    var keytipSequence = keytipProps.keySequences.slice();\n\n    if (keytipProps.overflowSetSequence) {\n      keytipSequence = KeytipUtils_1.mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);\n    } // Set currentKeytip\n\n\n    this._keytipTree.currentKeytip = this._keytipTree.getNode(KeytipUtils_1.sequencesToID(keytipSequence));\n\n    if (this._keytipTree.currentKeytip) {\n      // Show all children keytips if any\n      var children = this._keytipTree.getChildren();\n\n      if (children.length) {\n        this.showKeytips(children);\n      }\n\n      if (this._keytipTree.currentKeytip.onExecute) {\n        this._keytipTree.currentKeytip.onExecute(this._getKtpExecuteTarget(this._keytipTree.currentKeytip), this._getKtpTarget(this._keytipTree.currentKeytip));\n      }\n    } // Unset _newCurrKtpSequences\n\n\n    this._newCurrentKeytipSequences = undefined;\n  };\n\n  KeytipLayerBase.prototype._addKeytipToQueue = function (keytipID) {\n    var _this = this; // Add keytip\n\n\n    this._delayedKeytipQueue.push(keytipID); // Clear timeout\n\n\n    this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout); // Reset timeout\n\n    this._delayedQueueTimeout = this._async.setTimeout(function () {\n      if (_this._delayedKeytipQueue.length) {\n        _this.showKeytips(_this._delayedKeytipQueue);\n\n        _this._delayedKeytipQueue = [];\n      }\n    }, 300);\n  };\n\n  KeytipLayerBase.prototype._removeKeytipFromQueue = function (keytipID) {\n    var _this = this;\n\n    var index = this._delayedKeytipQueue.indexOf(keytipID);\n\n    if (index >= 0) {\n      // Remove keytip\n      this._delayedKeytipQueue.splice(index, 1); // Clear timeout\n\n\n      this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout); // Reset timeout\n\n      this._delayedQueueTimeout = this._async.setTimeout(function () {\n        if (_this._delayedKeytipQueue.length) {\n          _this.showKeytips(_this._delayedKeytipQueue);\n\n          _this._delayedKeytipQueue = [];\n        }\n      }, 300);\n    }\n  };\n\n  KeytipLayerBase.prototype._getKtpExecuteTarget = function (currKtp) {\n    return Utilities_1.getDocument().querySelector(KeytipUtils_1.ktpTargetFromId(currKtp.id));\n  };\n\n  KeytipLayerBase.prototype._getKtpTarget = function (currKtp) {\n    return Utilities_1.getDocument().querySelector(KeytipUtils_1.ktpTargetFromSequences(currKtp.keySequences));\n  };\n  /**\n   * Returns T/F if the keytipProps keySequences match the currentKeytip, and the currentKeytip is in an overflow well\n   * This will make 'keytipProps' the new currentKeytip\n   *\n   * @param keytipProps - Keytip props to check\n   * @returns - T/F if this keytip should become the currentKeytip\n   */\n\n\n  KeytipLayerBase.prototype._isCurrentKeytipAnAlias = function (keytipProps) {\n    var currKtp = this._keytipTree.currentKeytip;\n\n    if (currKtp && (currKtp.overflowSetSequence || currKtp.persisted) && Utilities_1.arraysEqual(keytipProps.keySequences, currKtp.keySequences)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  KeytipLayerBase.defaultProps = {\n    keytipStartSequences: [defaultStartSequence],\n    keytipExitSequences: [defaultExitSequence],\n    keytipReturnSequences: [defaultReturnSequence],\n    content: ''\n  };\n  return KeytipLayerBase;\n}(Utilities_1.BaseComponent);\n\nexports.KeytipLayerBase = KeytipLayerBase;","map":{"version":3,"sources":["components/KeytipLayer/KeytipLayer.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { IKeytipLayerProps, IKeytipLayerStyles, IKeytipLayerStyleProps } from './KeytipLayer.types';\nimport { getLayerStyles } from './KeytipLayer.styles';\nimport { Keytip, IKeytipProps } from '../../Keytip';\nimport { Layer } from '../../Layer';\nimport { BaseComponent, classNamesFunction, getDocument, arraysEqual, warn, isMac } from '../../Utilities';\nimport { KeytipManager } from '../../utilities/keytips/KeytipManager';\nimport { KeytipTree } from './KeytipTree';\nimport { IKeytipTreeNode } from './IKeytipTreeNode';\nimport { ktpTargetFromId, ktpTargetFromSequences, sequencesToID, mergeOverflows } from '../../utilities/keytips/KeytipUtils';\nimport { transitionKeysContain, KeytipTransitionModifier, IKeytipTransitionKey } from '../../utilities/keytips/IKeytipTransitionKey';\nimport { KeytipEvents, KTP_LAYER_ID, KTP_ARIA_SEPARATOR } from '../../utilities/keytips/KeytipConstants';\n\nexport interface IKeytipLayerState {\n  inKeytipMode: boolean;\n  keytips: IKeytipProps[];\n  visibleKeytips: IKeytipProps[];\n}\n\n// Default sequence is Alt-Windows (Alt-Meta) in Windows, Option-Control (Alt-Control) in Mac\nconst defaultStartSequence: IKeytipTransitionKey = {\n  key: isMac() ? 'Control' : 'Meta',\n  modifierKeys: [KeytipTransitionModifier.alt]\n};\n\n// Default exit sequence is the same as the start sequence\nconst defaultExitSequence: IKeytipTransitionKey = defaultStartSequence;\n\n// Default return sequence is Escape\nconst defaultReturnSequence: IKeytipTransitionKey = {\n  key: 'Escape'\n};\n\nconst getClassNames = classNamesFunction<IKeytipLayerStyleProps, IKeytipLayerStyles>();\n\n/**\n * A layer that holds all keytip items\n * {@docCategory Keytips}\n */\nexport class KeytipLayerBase extends BaseComponent<IKeytipLayerProps, IKeytipLayerState> {\n  public static defaultProps: IKeytipLayerProps = {\n    keytipStartSequences: [defaultStartSequence],\n    keytipExitSequences: [defaultExitSequence],\n    keytipReturnSequences: [defaultReturnSequence],\n    content: ''\n  };\n\n  private _keytipTree: KeytipTree;\n\n  private _keytipManager: KeytipManager = KeytipManager.getInstance();\n  private _classNames: { [key in keyof IKeytipLayerStyles]: string };\n  private _currentSequence: string;\n  private _newCurrentKeytipSequences?: string[];\n\n  private _delayedKeytipQueue: string[] = [];\n  private _delayedQueueTimeout: number;\n\n  private _keyHandled = false;\n\n  // tslint:disable-next-line:no-any\n  constructor(props: IKeytipLayerProps, context: any) {\n    super(props, context);\n\n    const managerKeytips = [...this._keytipManager.getKeytips()];\n    this.state = {\n      inKeytipMode: false,\n      // Get the initial set of keytips\n      keytips: managerKeytips,\n      visibleKeytips: this._getVisibleKeytips(managerKeytips)\n    };\n\n    this._keytipTree = new KeytipTree();\n    // Add regular and persisted keytips to the tree\n    for (const uniqueKeytip of this._keytipManager.keytips.concat(this._keytipManager.persistedKeytips)) {\n      this._keytipTree.addNode(uniqueKeytip.keytip, uniqueKeytip.uniqueID);\n    }\n\n    this._currentSequence = '';\n\n    // Add keytip listeners\n    this._events.on(this._keytipManager, KeytipEvents.KEYTIP_ADDED, this._onKeytipAdded);\n    this._events.on(this._keytipManager, KeytipEvents.KEYTIP_UPDATED, this._onKeytipUpdated);\n    this._events.on(this._keytipManager, KeytipEvents.KEYTIP_REMOVED, this._onKeytipRemoved);\n    this._events.on(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_ADDED, this._onPersistedKeytipAdded);\n    this._events.on(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_REMOVED, this._onPersistedKeytipRemoved);\n    this._events.on(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, this._onPersistedKeytipExecute);\n  }\n\n  public render(): JSX.Element {\n    const { content, styles } = this.props;\n\n    const { keytips, visibleKeytips } = this.state;\n\n    this._classNames = getClassNames(styles, {});\n\n    return (\n      <Layer styles={getLayerStyles}>\n        <span id={KTP_LAYER_ID} className={this._classNames.innerContent}>{`${content}${KTP_ARIA_SEPARATOR}`}</span>\n        {keytips &&\n          keytips.map((keytipProps: IKeytipProps, index: number) => {\n            return (\n              <span key={index} id={sequencesToID(keytipProps.keySequences)} className={this._classNames.innerContent}>\n                {keytipProps.keySequences.join(KTP_ARIA_SEPARATOR)}\n              </span>\n            );\n          })}\n        {visibleKeytips &&\n          visibleKeytips.map((visibleKeytipProps: IKeytipProps) => {\n            return <Keytip key={sequencesToID(visibleKeytipProps.keySequences)} {...visibleKeytipProps} />;\n          })}\n      </Layer>\n    );\n  }\n\n  public componentDidMount(): void {\n    // Add window listeners\n    this._events.on(window, 'mouseup', this._onDismiss, true /* useCapture */);\n    this._events.on(window, 'pointerup', this._onDismiss, true /* useCapture */);\n    this._events.on(window, 'resize', this._onDismiss);\n    this._events.on(window, 'keydown', this._onKeyDown, true /* useCapture */);\n    this._events.on(window, 'keypress', this._onKeyPress, true /* useCapture */);\n    this._events.on(window, 'scroll', this._onDismiss, true /* useCapture */);\n\n    // Add keytip listeners\n    this._events.on(this._keytipManager, KeytipEvents.ENTER_KEYTIP_MODE, this._enterKeytipMode);\n    this._events.on(this._keytipManager, KeytipEvents.EXIT_KEYTIP_MODE, this._exitKeytipMode);\n  }\n\n  public componentWillUnmount(): void {\n    // Remove window listeners\n    this._events.off(window, 'mouseup', this._onDismiss, true /* useCapture */);\n    this._events.off(window, 'pointerup', this._onDismiss, true /* useCapture */);\n    this._events.off(window, 'resize', this._onDismiss);\n    this._events.off(window, 'keydown', this._onKeyDown, true /* useCapture */);\n    this._events.off(window, 'keypress', this._onKeyPress, true /* useCapture */);\n    this._events.off(window, 'scroll', this._onDismiss, true /* useCapture */);\n\n    // Remove keytip listeners\n    this._events.off(this._keytipManager, KeytipEvents.KEYTIP_ADDED, this._onKeytipAdded);\n    this._events.off(this._keytipManager, KeytipEvents.KEYTIP_UPDATED, this._onKeytipUpdated);\n    this._events.off(this._keytipManager, KeytipEvents.KEYTIP_REMOVED, this._onKeytipRemoved);\n    this._events.off(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_ADDED, this._onPersistedKeytipAdded);\n    this._events.off(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_REMOVED, this._onPersistedKeytipRemoved);\n    this._events.off(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, this._onPersistedKeytipExecute);\n    this._events.off(this._keytipManager, KeytipEvents.ENTER_KEYTIP_MODE, this._enterKeytipMode);\n    this._events.off(this._keytipManager, KeytipEvents.EXIT_KEYTIP_MODE, this._exitKeytipMode);\n  }\n\n  // The below public functions are only public for testing purposes\n  // They are not intended to be used in app code by using a KeytipLayer reference\n\n  public getCurrentSequence(): string {\n    return this._currentSequence;\n  }\n\n  public getKeytipTree(): KeytipTree {\n    return this._keytipTree;\n  }\n\n  /**\n   * Processes an IKeytipTransitionKey entered by the user\n   *\n   * @param transitionKey - IKeytipTransitionKey received by the layer to process\n   */\n  public processTransitionInput(transitionKey: IKeytipTransitionKey, ev?: React.KeyboardEvent<HTMLElement>): void {\n    const currKtp = this._keytipTree.currentKeytip;\n    if (transitionKeysContain(this.props.keytipExitSequences!, transitionKey) && currKtp) {\n      // If key sequence is in 'exit sequences', exit keytip mode\n      this._keyHandled = true;\n      this._exitKeytipMode(ev);\n    } else if (transitionKeysContain(this.props.keytipReturnSequences!, transitionKey)) {\n      // If key sequence is in return sequences, move currentKeytip to parent (or if currentKeytip is the root, exit)\n      if (currKtp) {\n        this._keyHandled = true;\n        if (currKtp.id === this._keytipTree.root.id) {\n          // We are at the root, exit keytip mode\n          this._exitKeytipMode(ev);\n        } else {\n          // If this keytip has a onReturn prop, we execute the func.\n          if (currKtp.onReturn) {\n            currKtp.onReturn(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp));\n          }\n\n          // Reset currentSequence\n          this._currentSequence = '';\n          // Return pointer to its parent\n          this._keytipTree.currentKeytip = this._keytipTree.getNode(currKtp.parent);\n          // Show children keytips of the new currentKeytip\n          this.showKeytips(this._keytipTree.getChildren());\n          this._warnIfDuplicateKeytips();\n        }\n      }\n    } else if (transitionKeysContain(this.props.keytipStartSequences!, transitionKey) && !currKtp) {\n      // If key sequence is in 'entry sequences' and currentKeytip is null, we enter keytip mode\n      this._keyHandled = true;\n      this._enterKeytipMode();\n      this._warnIfDuplicateKeytips();\n    }\n  }\n\n  /**\n   * Processes inputs from the document listener and traverse the keytip tree\n   *\n   * @param key - Key pressed by the user\n   */\n  public processInput(key: string, ev?: React.KeyboardEvent<HTMLElement>): void {\n    // Concat the input key with the current sequence\n    const currSequence: string = this._currentSequence + key;\n    let currKtp = this._keytipTree.currentKeytip;\n\n    // currentKeytip must be defined, otherwise we haven't entered keytip mode yet\n    if (currKtp) {\n      const node = this._keytipTree.getExactMatchedNode(currSequence, currKtp);\n      if (node) {\n        this._keytipTree.currentKeytip = currKtp = node;\n        const currKtpChildren = this._keytipTree.getChildren();\n\n        // Execute this node's onExecute if defined\n        if (currKtp.onExecute) {\n          currKtp.onExecute(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp));\n          // Reset currKtp, this might have changed from the onExecute\n          currKtp = this._keytipTree.currentKeytip;\n        }\n\n        // To exit keytipMode after executing the keytip it must not have a menu or have dynamic children\n        if (currKtpChildren.length === 0 && !(currKtp.hasDynamicChildren || currKtp.hasMenu)) {\n          this._exitKeytipMode(ev);\n        } else {\n          // Show all children keytips\n          this.showKeytips(currKtpChildren);\n          this._warnIfDuplicateKeytips();\n        }\n\n        // Clear currentSequence\n        this._currentSequence = '';\n        return;\n      }\n\n      const partialNodes = this._keytipTree.getPartiallyMatchedNodes(currSequence, currKtp);\n      if (partialNodes.length > 0) {\n        // We found nodes that partially match the sequence, so we show only those\n        // Omit showing persisted nodes here\n        const ids = partialNodes\n          .filter((partialNode: IKeytipTreeNode) => {\n            return !partialNode.persisted;\n          })\n          .map((partialNode: IKeytipTreeNode) => {\n            return partialNode.id;\n          });\n        this.showKeytips(ids);\n\n        // Save currentSequence\n        this._currentSequence = currSequence;\n      }\n    }\n  }\n\n  /**\n   * Show the given keytips and hide all others\n   *\n   * @param ids - Keytip IDs to show\n   */\n  public showKeytips(ids: string[]): void {\n    // Update the visible prop in the manager\n    for (const keytip of this._keytipManager.getKeytips()) {\n      const keytipId = sequencesToID(keytip.keySequences);\n      if (ids.indexOf(keytipId) >= 0) {\n        keytip.visible = true;\n      } else if (\n        keytip.overflowSetSequence &&\n        ids.indexOf(sequencesToID(mergeOverflows(keytip.keySequences, keytip.overflowSetSequence))) >= 0\n      ) {\n        // Check if the ID with the overflow is the keytip we're looking for\n        keytip.visible = true;\n      } else {\n        keytip.visible = false;\n      }\n    }\n    // Apply the manager changes to the Layer state\n    this._setKeytips();\n  }\n\n  /**\n   * Enters keytip mode for this layer\n   */\n  private _enterKeytipMode(): void {\n    if (this._keytipManager.shouldEnterKeytipMode) {\n      this._keytipTree.currentKeytip = this._keytipTree.root;\n      // Show children of root\n      this.showKeytips(this._keytipTree.getChildren());\n\n      this._setInKeytipMode(true /* inKeytipMode */);\n\n      if (this.props.onEnterKeytipMode) {\n        this.props.onEnterKeytipMode();\n      }\n    }\n  }\n\n  /**\n   * Exits keytip mode for this layer\n   */\n  private _exitKeytipMode(ev?: React.KeyboardEvent<HTMLElement> | React.MouseEvent<HTMLElement>): void {\n    this._keytipTree.currentKeytip = undefined;\n    this._currentSequence = '';\n    // Hide all keytips\n    this.showKeytips([]);\n\n    // Reset the delayed keytips if any\n    this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n    this._delayedKeytipQueue = [];\n\n    this._setInKeytipMode(false /* inKeytipMode */);\n\n    if (this.props.onExitKeytipMode) {\n      this.props.onExitKeytipMode(ev);\n    }\n  }\n\n  /**\n   * Sets the keytips state property\n   *\n   * @param keytipProps - Keytips to set in this layer\n   */\n  private _setKeytips(keytipProps: IKeytipProps[] = this._keytipManager.getKeytips()) {\n    this.setState({ keytips: keytipProps, visibleKeytips: this._getVisibleKeytips(keytipProps) });\n  }\n\n  /**\n   * Callback function to use for persisted keytips\n   *\n   * @param overflowButtonSequences - The overflow button sequence to execute\n   * @param keytipSequences - The keytip that should become the 'currentKeytip' when it is registered\n   */\n  private _persistedKeytipExecute(overflowButtonSequences: string[], keytipSequences: string[]) {\n    // Save newCurrentKeytip for later\n    this._newCurrentKeytipSequences = keytipSequences;\n\n    // Execute the overflow button's onExecute\n    const overflowKeytipNode = this._keytipTree.getNode(sequencesToID(overflowButtonSequences));\n    if (overflowKeytipNode && overflowKeytipNode.onExecute) {\n      overflowKeytipNode.onExecute(this._getKtpExecuteTarget(overflowKeytipNode), this._getKtpTarget(overflowKeytipNode));\n    }\n  }\n\n  private _getVisibleKeytips(keytips: IKeytipProps[]): IKeytipProps[] {\n    // Filter out non-visible keytips and duplicates\n    const seenIds: { [childSequence: string]: number } = {};\n    return keytips.filter(keytip => {\n      const keytipId = sequencesToID(keytip.keySequences);\n      seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1;\n      return keytip.visible && seenIds[keytipId] === 1;\n    });\n  }\n\n  private _onDismiss = (ev?: React.MouseEvent<HTMLElement>): void => {\n    // if we are in keytip mode, then exit keytip mode\n    if (this.state.inKeytipMode) {\n      this._exitKeytipMode(ev);\n    }\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    this._keyHandled = false;\n    // using key since which has been deprecated and key is now widely suporrted.\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which\n    let key = ev.key;\n    switch (key) {\n      case 'Alt':\n        // ALT puts focus in the browser bar, so it should not be used as a key for keytips.\n        // It can be used as a modifier\n        break;\n      case 'Tab':\n      case 'Enter':\n      case 'Spacebar':\n      case ' ':\n      case 'ArrowUp':\n      case 'Up':\n      case 'ArrowDown':\n      case 'Down':\n      case 'ArrowLeft':\n      case 'Left':\n      case 'ArrowRight':\n      case 'Right':\n        if (this.state.inKeytipMode) {\n          this._keyHandled = true;\n          this._exitKeytipMode(ev);\n        }\n        break;\n      default:\n        // Special cases for browser-specific keys that are not at standard\n        // (according to http://www.w3.org/TR/uievents-key/#keys-navigation)\n        if (key === 'Esc') {\n          // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/5290772/\n          key = 'Escape';\n        } else if (key === 'OS' || key === 'Win') {\n          // Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1232918\n          // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n          // and https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/16424492/\n          key = 'Meta';\n        }\n        const transitionKey: IKeytipTransitionKey = { key };\n        transitionKey.modifierKeys = this._getModifierKey(key, ev);\n        this.processTransitionInput(transitionKey, ev);\n        break;\n    }\n  };\n\n  /**\n   * Gets the ModifierKeyCodes based on the keyboard event\n   *\n   * @param ev - React.KeyboardEvent\n   * @returns List of ModifierKeyCodes that were pressed\n   */\n  private _getModifierKey(key: string, ev: React.KeyboardEvent<HTMLElement>): KeytipTransitionModifier[] | undefined {\n    const modifierKeys = [];\n    if (ev.altKey && key !== 'Alt') {\n      modifierKeys.push(KeytipTransitionModifier.alt);\n    }\n    if (ev.ctrlKey && key !== 'Control') {\n      modifierKeys.push(KeytipTransitionModifier.ctrl);\n    }\n    if (ev.shiftKey && key !== 'Shift') {\n      modifierKeys.push(KeytipTransitionModifier.shift);\n    }\n    if (ev.metaKey && key !== 'Meta') {\n      modifierKeys.push(KeytipTransitionModifier.meta);\n    }\n    return modifierKeys.length ? modifierKeys : undefined;\n  }\n\n  private _onKeyPress = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    if (this.state.inKeytipMode && !this._keyHandled) {\n      // Call processInput\n      this.processInput(ev.key.toLocaleLowerCase(), ev);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  };\n\n  private _onKeytipAdded = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n\n    this._keytipTree.addNode(keytipProps, uniqueID);\n    this._setKeytips();\n\n    // Add the keytip to the queue to show later\n    if (this._keytipTree.isCurrentKeytipParent(keytipProps)) {\n      this._addKeytipToQueue(sequencesToID(keytipProps.keySequences));\n      // Check to make sure that child of currentKeytip is successfully added to currentKeytip's children and update it if not\n      // Note: Added this condition because KeytipTree.addNode was not always reflecting updates made to a parent node in currentKeytip\n      // when that parent is the currentKeytip\n      if (\n        this._keytipTree.currentKeytip &&\n        this._keytipTree.currentKeytip.hasDynamicChildren &&\n        this._keytipTree.currentKeytip.children.indexOf(keytipProps.id) < 0\n      ) {\n        this._keytipTree.currentKeytip = this._keytipTree.getNode(this._keytipTree.currentKeytip.id);\n      }\n    }\n\n    if (this._newCurrentKeytipSequences && arraysEqual(keytipProps.keySequences, this._newCurrentKeytipSequences)) {\n      this._triggerKeytipImmediately(keytipProps);\n    }\n\n    if (this._isCurrentKeytipAnAlias(keytipProps)) {\n      let keytipSequence = keytipProps.keySequences;\n      if (keytipProps.overflowSetSequence) {\n        keytipSequence = mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);\n      }\n      this._keytipTree.currentKeytip = this._keytipTree.getNode(sequencesToID(keytipSequence));\n    }\n  };\n\n  private _onKeytipUpdated = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n    this._keytipTree.updateNode(keytipProps, uniqueID);\n    this._setKeytips();\n  };\n\n  private _onKeytipRemoved = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n\n    // Remove keytip from the delayed queue\n    this._removeKeytipFromQueue(sequencesToID(keytipProps.keySequences));\n\n    // Remove the node from the Tree\n    this._keytipTree.removeNode(keytipProps, uniqueID);\n    this._setKeytips();\n  };\n\n  private _onPersistedKeytipAdded = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n    this._keytipTree.addNode(keytipProps, uniqueID, true);\n  };\n\n  private _onPersistedKeytipRemoved = (eventArgs: any) => {\n    const keytipProps = eventArgs.keytip;\n    const uniqueID = eventArgs.uniqueID;\n    this._keytipTree.removeNode(keytipProps, uniqueID);\n  };\n\n  private _onPersistedKeytipExecute = (eventArgs: any) => {\n    this._persistedKeytipExecute(eventArgs.overflowButtonSequences, eventArgs.keytipSequences);\n  };\n\n  /**\n   * Trigger a keytip immediately and set it as the current keytip\n   *\n   * @param keytipProps - Keytip to trigger immediately\n   */\n  private _triggerKeytipImmediately(keytipProps: IKeytipProps) {\n    // This keytip should become the currentKeytip and should execute right away\n    let keytipSequence = [...keytipProps.keySequences];\n    if (keytipProps.overflowSetSequence) {\n      keytipSequence = mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);\n    }\n\n    // Set currentKeytip\n    this._keytipTree.currentKeytip = this._keytipTree.getNode(sequencesToID(keytipSequence));\n    if (this._keytipTree.currentKeytip) {\n      // Show all children keytips if any\n      const children = this._keytipTree.getChildren();\n      if (children.length) {\n        this.showKeytips(children);\n      }\n\n      if (this._keytipTree.currentKeytip.onExecute) {\n        this._keytipTree.currentKeytip.onExecute(\n          this._getKtpExecuteTarget(this._keytipTree.currentKeytip),\n          this._getKtpTarget(this._keytipTree.currentKeytip)\n        );\n      }\n    }\n\n    // Unset _newCurrKtpSequences\n    this._newCurrentKeytipSequences = undefined;\n  }\n\n  private _addKeytipToQueue(keytipID: string) {\n    // Add keytip\n    this._delayedKeytipQueue.push(keytipID);\n    // Clear timeout\n    this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n    // Reset timeout\n    this._delayedQueueTimeout = this._async.setTimeout(() => {\n      if (this._delayedKeytipQueue.length) {\n        this.showKeytips(this._delayedKeytipQueue);\n        this._delayedKeytipQueue = [];\n      }\n    }, 300);\n  }\n\n  private _removeKeytipFromQueue(keytipID: string) {\n    const index = this._delayedKeytipQueue.indexOf(keytipID);\n    if (index >= 0) {\n      // Remove keytip\n      this._delayedKeytipQueue.splice(index, 1);\n      // Clear timeout\n      this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n      // Reset timeout\n      this._delayedQueueTimeout = this._async.setTimeout(() => {\n        if (this._delayedKeytipQueue.length) {\n          this.showKeytips(this._delayedKeytipQueue);\n          this._delayedKeytipQueue = [];\n        }\n      }, 300);\n    }\n  }\n\n  private _getKtpExecuteTarget(currKtp: IKeytipTreeNode): HTMLElement | null {\n    return getDocument()!.querySelector(ktpTargetFromId(currKtp.id));\n  }\n\n  private _getKtpTarget(currKtp: IKeytipTreeNode): HTMLElement | null {\n    return getDocument()!.querySelector(ktpTargetFromSequences(currKtp.keySequences));\n  }\n\n  /**\n   * Returns T/F if the keytipProps keySequences match the currentKeytip, and the currentKeytip is in an overflow well\n   * This will make 'keytipProps' the new currentKeytip\n   *\n   * @param keytipProps - Keytip props to check\n   * @returns - T/F if this keytip should become the currentKeytip\n   */\n  private _isCurrentKeytipAnAlias(keytipProps: IKeytipProps): boolean {\n    const currKtp = this._keytipTree.currentKeytip;\n    if (currKtp && (currKtp.overflowSetSequence || currKtp.persisted) && arraysEqual(keytipProps.keySequences, currKtp.keySequences)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Sets if we are in keytip mode.\n   * Note, this sets both the state for the layer as well as\n   * the value that the manager will expose externally.\n   * @param inKeytipMode - Boolean so set whether we are in keytip mode or not\n   */\n  private _setInKeytipMode = (inKeytipMode: boolean): void => {\n    this.setState({ inKeytipMode: inKeytipMode });\n    this._keytipManager.inKeytipMode = inKeytipMode;\n  };\n\n  /**\n   * Emits a warning if duplicate keytips are found for the children of the current keytip\n   */\n  private _warnIfDuplicateKeytips = (): void => {\n    const duplicateKeytips = this._getDuplicateIds(this._keytipTree.getChildren());\n    if (duplicateKeytips.length) {\n      warn('Duplicate keytips found for ' + duplicateKeytips.join(', '));\n    }\n  };\n\n  /**\n   * Returns duplicates among keytip IDs\n   * If the returned array is empty, no duplicates were found\n   *\n   * @param keytipIds - Array of keytip IDs to find duplicates for\n   * @returns - Array of duplicates that were found. If multiple duplicates were found it will only be added once to this array\n   */\n  private _getDuplicateIds = (keytipIds: string[]): string[] => {\n    const seenIds: { [id: string]: number } = {};\n    return keytipIds.filter(keytipId => {\n      seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1;\n      // Only add the first duplicate keytip seen\n      return seenIds[keytipId] === 2;\n    });\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"script"}