{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { ContextualMenuItemType } from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, FocusZoneTabbableElements } from '../../FocusZone';\nimport { divProperties, getNativeProps, shallowCompare } from '../../Utilities';\nimport { assign, BaseComponent, classNamesFunction, css, getDocument, getFirstFocusable, getId, getLastFocusable, getRTL, getWindow, KeyCodes, shouldWrapFocus, isIOS, isMac } from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { Callout } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport { ContextualMenuSplitButton, ContextualMenuButton, ContextualMenuAnchor } from './ContextualMenuItemWrapper/index';\nimport { mergeStyleSets } from '../../Styling';\nimport { getItemStyles } from './ContextualMenu.classNames';\nvar getClassNames = classNamesFunction({\n  disableCaching: true\n});\nvar getContextualMenuItemClassNames = classNamesFunction({\n  disableCaching: true\n});\nexport function getSubmenuItems(item) {\n  return item.subMenuProps ? item.subMenuProps.items : item.items;\n}\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\n\nexport function canAnyMenuItemsCheck(items) {\n  return items.some(function (item) {\n    if (item.canCheck) {\n      return true;\n    } // If the item is a section, check if any of the items in the section can check.\n\n\n    if (item.sectionProps && item.sectionProps.items.some(function (submenuItem) {\n      return submenuItem.canCheck === true;\n    })) {\n      return true;\n    }\n\n    return false;\n  });\n}\nvar NavigationIdleDelay = 250\n/* ms */\n;\n\nvar ContextualMenuBase =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ContextualMenuBase, _super);\n\n  function ContextualMenuBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._mounted = false;\n\n    _this.dismiss = function (ev, dismissAll) {\n      var onDismiss = _this.props.onDismiss;\n\n      if (onDismiss) {\n        onDismiss(ev, dismissAll);\n      }\n    };\n\n    _this._onRenderMenuList = function (menuListProps, defaultRender) {\n      var indexCorrection = 0;\n      return React.createElement(\"ul\", {\n        className: _this._classNames.list,\n        onKeyDown: _this._onKeyDown,\n        onKeyUp: _this._onKeyUp,\n        role: \"menu\"\n      }, menuListProps.items.map(function (item, index) {\n        var menuItem = _this._renderMenuItem(item, index, indexCorrection, menuListProps.totalItemCount, menuListProps.hasCheckmarks, menuListProps.hasIcons);\n\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          var indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          indexCorrection += indexIncrease;\n        }\n\n        return menuItem;\n      }));\n    };\n\n    _this._onKeyDown = function (ev) {\n      // Take note if we are processing an alt (option) or meta (command) keydown.\n      // See comment in _shouldHandleKeyUp for reasoning.\n      _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev); // On Mac, pressing escape dismisses all levels of native context menus\n\n      var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n      return _this._keyHandler(ev, _this._shouldHandleKeyDown, dismissAllMenus);\n    };\n\n    _this._shouldHandleKeyDown = function (ev) {\n      return ev.which === KeyCodes.escape || _this._shouldCloseSubMenu(ev) || ev.which === KeyCodes.up && (ev.altKey || ev.metaKey);\n    };\n\n    _this._onMenuFocusCapture = function (ev) {\n      if (_this.props.delayUpdateFocusOnHover) {\n        _this._shouldUpdateFocusOnMouseEvent = true;\n      }\n    };\n\n    _this._onKeyUp = function (ev) {\n      return _this._keyHandler(ev, _this._shouldHandleKeyUp, true\n      /* dismissAllMenus */\n      );\n    };\n    /**\n     * We close the menu on key up only if ALL of the following are true:\n     * - Most recent key down was alt or meta (command)\n     * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n     *   expand/collapse the menu)\n     * - We're not on a Mac (or iOS)\n     *\n     * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n     * closing any open context menus. There is not a similar behavior on Macs.\n     */\n\n\n    _this._shouldHandleKeyUp = function (ev) {\n      var keyPressIsAltOrMetaAlone = _this._lastKeyDownWasAltOrMeta && _this._isAltOrMeta(ev);\n\n      _this._lastKeyDownWasAltOrMeta = false;\n      return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n    };\n    /**\n     * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n     * if so, stops event propagation and dismisses menu(s).\n     * @param ev - The keyboard event.\n     * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n     * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n     * Only does anything if `shouldHandleKey` returns true.\n     * @returns Whether the event was handled.\n     */\n\n\n    _this._keyHandler = function (ev, shouldHandleKey, dismissAllMenus) {\n      var handled = false;\n\n      if (shouldHandleKey(ev)) {\n        _this._isFocusingPreviousElement = true;\n        ev.preventDefault();\n        ev.stopPropagation();\n\n        _this.dismiss(ev, dismissAllMenus);\n\n        handled = true;\n      }\n\n      return handled;\n    };\n    /**\n     * Checks if the submenu should be closed\n     */\n\n\n    _this._shouldCloseSubMenu = function (ev) {\n      var submenuCloseKey = getRTL() ? KeyCodes.right : KeyCodes.left;\n\n      if (ev.which !== submenuCloseKey || !_this.props.isSubMenu) {\n        return false;\n      }\n\n      return _this._adjustedFocusZoneProps.direction === FocusZoneDirection.vertical || !!_this._adjustedFocusZoneProps.checkForNoWrap && !shouldWrapFocus(ev.target, 'data-no-horizontal-wrap');\n    };\n\n    _this._onMenuKeyDown = function (ev) {\n      // Mark as handled if onKeyDown returns true (for handling collapse cases)\n      // or if we are attempting to expand a submenu\n      var handled = _this._onKeyDown(ev);\n\n      if (handled || !_this._host) {\n        return;\n      } // If we have a modifier key being pressed, we do not want to move focus.\n      // Otherwise, handle up and down keys.\n\n\n      var hasModifier = !!(ev.altKey || ev.metaKey);\n      var isUp = ev.which === KeyCodes.up;\n      var isDown = ev.which === KeyCodes.down;\n\n      if (!hasModifier && (isUp || isDown)) {\n        var elementToFocus = isUp ? getLastFocusable(_this._host, _this._host.lastChild, true) : getFirstFocusable(_this._host, _this._host.firstChild, true);\n\n        if (elementToFocus) {\n          elementToFocus.focus();\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n    /**\n     * Scroll handler for the callout to make sure the mouse events\n     * for updating focus are not interacting during scroll\n     */\n\n\n    _this._onScroll = function () {\n      if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== undefined) {\n        _this._async.clearTimeout(_this._scrollIdleTimeoutId);\n\n        _this._scrollIdleTimeoutId = undefined;\n      } else {\n        _this._isScrollIdle = false;\n      }\n\n      _this._scrollIdleTimeoutId = _this._async.setTimeout(function () {\n        _this._isScrollIdle = true;\n      }, NavigationIdleDelay);\n    };\n\n    _this._onItemMouseEnterBase = function (item, ev, target) {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      }\n\n      _this._updateFocusOnMouseEvent(item, ev, target);\n    };\n\n    _this._onItemMouseMoveBase = function (item, ev, target) {\n      var targetElement = ev.currentTarget; // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n\n      if (_this._shouldUpdateFocusOnMouseEvent) {\n        _this._gotMouseMove = true;\n      } else {\n        return;\n      }\n\n      if (!_this._isScrollIdle || _this._enterTimerId !== undefined || targetElement === _this._targetWindow.document.activeElement) {\n        return;\n      }\n\n      _this._updateFocusOnMouseEvent(item, ev, target);\n    };\n\n    _this._onMouseItemLeave = function (item, ev) {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      }\n\n      if (_this._enterTimerId !== undefined) {\n        _this._async.clearTimeout(_this._enterTimerId);\n\n        _this._enterTimerId = undefined;\n      }\n\n      if (_this.state.expandedMenuItemKey !== undefined) {\n        return;\n      }\n      /**\n       * IE11 focus() method forces parents to scroll to top of element.\n       * Edge and IE expose a setActive() function for focusable divs that\n       * sets the page focus but does not scroll the parent element.\n       */\n\n\n      if (_this._host.setActive) {\n        try {\n          _this._host.setActive();\n        } catch (e) {\n          /* no-op */\n        }\n      } else {\n        _this._host.focus();\n      }\n    };\n\n    _this._onItemMouseDown = function (item, ev) {\n      if (item.onMouseDown) {\n        item.onMouseDown(item, ev);\n      }\n    };\n\n    _this._onItemClick = function (item, ev) {\n      _this._onItemClickBase(item, ev, ev.currentTarget);\n    };\n\n    _this._onItemClickBase = function (item, ev, target) {\n      var items = getSubmenuItems(item); // Cancel a async menu item hover timeout action from being taken and instead\n      // just trigger the click event instead.\n\n      _this._cancelSubMenuTimer();\n\n      if (!hasSubmenu(item) && (!items || !items.length)) {\n        // This is an item without a menu. Click it.\n        _this._executeItemClick(item, ev);\n      } else {\n        if (item.key !== _this.state.expandedMenuItemKey) {\n          // This has a collapsed sub menu. Expand it.\n          _this.setState({\n            // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n            // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n            // between a real click event and a keypress event (detail should be the number of mouse clicks).\n            // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n            // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n            // and \"\" for pressing \"Enter\" with Narrator on.\n            expandedByMouseClick: ev.nativeEvent.detail !== 0 || ev.nativeEvent.pointerType === 'mouse'\n          });\n\n          _this._onItemSubMenuExpand(item, target);\n        }\n      }\n\n      ev.stopPropagation();\n      ev.preventDefault();\n    };\n\n    _this._onAnchorClick = function (item, ev) {\n      _this._executeItemClick(item, ev);\n\n      ev.stopPropagation();\n    };\n\n    _this._executeItemClick = function (item, ev) {\n      if (item.disabled || item.isDisabled) {\n        return;\n      }\n\n      var dismiss = false;\n\n      if (item.onClick) {\n        dismiss = !!item.onClick(ev, item);\n      } else if (_this.props.onItemClick) {\n        dismiss = !!_this.props.onItemClick(ev, item);\n      }\n\n      (dismiss || !ev.defaultPrevented) && _this.dismiss(ev, true);\n    };\n\n    _this._onItemKeyDown = function (item, ev) {\n      var openKey = getRTL() ? KeyCodes.left : KeyCodes.right;\n\n      if (!item.disabled && (ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {\n        _this.setState({\n          expandedByMouseClick: false\n        });\n\n        _this._onItemSubMenuExpand(item, ev.currentTarget);\n\n        ev.preventDefault();\n      }\n    }; // Cancel a async menu item hover timeout action from being taken and instead\n    // do new upcoming behavior\n\n\n    _this._cancelSubMenuTimer = function () {\n      if (_this._enterTimerId !== undefined) {\n        _this._async.clearTimeout(_this._enterTimerId);\n\n        _this._enterTimerId = undefined;\n      }\n    };\n\n    _this._onItemSubMenuExpand = function (item, target) {\n      if (_this.state.expandedMenuItemKey !== item.key) {\n        if (_this.state.expandedMenuItemKey) {\n          _this._onSubMenuDismiss();\n        } // Focus the target to ensure when we close it, we're focusing on the correct element.\n\n\n        target.focus();\n\n        _this.setState({\n          expandedMenuItemKey: item.key,\n          submenuTarget: target\n        });\n      }\n    };\n    /**\n     * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n     * after the component is unmounted. The _mounted property is added to prevent\n     * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n     * code.\n     */\n\n\n    _this._onSubMenuDismiss = function (ev, dismissAll) {\n      if (dismissAll) {\n        _this.dismiss(ev, dismissAll);\n      } else if (_this._mounted) {\n        _this.setState({\n          dismissedMenuItemKey: _this.state.expandedMenuItemKey,\n          expandedMenuItemKey: undefined,\n          submenuTarget: undefined\n        });\n      }\n    };\n\n    _this._getSubMenuId = function (item) {\n      var subMenuId = _this.state.subMenuId;\n\n      if (item.subMenuProps && item.subMenuProps.id) {\n        subMenuId = item.subMenuProps.id;\n      }\n\n      return subMenuId;\n    };\n\n    _this._onPointerAndTouchEvent = function (ev) {\n      _this._cancelSubMenuTimer();\n    };\n\n    _this.state = {\n      contextualMenuItems: undefined,\n      subMenuId: getId('ContextualMenu')\n    };\n\n    _this._warnDeprecations({\n      getMenuClassNames: 'styles'\n    });\n\n    _this._isFocusingPreviousElement = false;\n    _this._isScrollIdle = true;\n    _this._shouldUpdateFocusOnMouseEvent = !_this.props.delayUpdateFocusOnHover;\n    _this._gotMouseMove = false;\n    return _this;\n  }\n\n  ContextualMenuBase.prototype.shouldComponentUpdate = function (newProps, newState) {\n    if (this.props.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return false;\n    }\n\n    return !shallowCompare(this.props, newProps) || !shallowCompare(this.state, newState);\n  }; // tslint:disable-next-line function-name\n\n\n  ContextualMenuBase.prototype.UNSAFE_componentWillUpdate = function (newProps) {\n    if (newProps.target !== this.props.target) {\n      var newTarget = newProps.target;\n\n      this._setTargetWindowAndElement(newTarget);\n    }\n\n    if (newProps.hidden !== this.props.hidden) {\n      if (newProps.hidden) {\n        this._onMenuClosed();\n      } else {\n        this._onMenuOpened();\n\n        this._previousActiveElement = this._targetWindow ? this._targetWindow.document.activeElement : null;\n      }\n    }\n\n    if (newProps.delayUpdateFocusOnHover !== this.props.delayUpdateFocusOnHover) {\n      // update shouldUpdateFocusOnMouseEvent to follow what was passed in\n      this._shouldUpdateFocusOnMouseEvent = !newProps.delayUpdateFocusOnHover; // If shouldUpdateFocusOnMouseEvent is false, we need to reset gotMouseMove to false\n\n      this._gotMouseMove = this._shouldUpdateFocusOnMouseEvent && this._gotMouseMove;\n    }\n  }; // Invoked once, both on the client and server, immediately before the initial rendering occurs.\n  // tslint:disable-next-line function-name\n\n\n  ContextualMenuBase.prototype.UNSAFE_componentWillMount = function () {\n    var target = this.props.target;\n\n    this._setTargetWindowAndElement(target);\n\n    if (!this.props.hidden) {\n      this._previousActiveElement = this._targetWindow ? this._targetWindow.document.activeElement : null;\n    }\n  }; // Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.\n\n\n  ContextualMenuBase.prototype.componentDidMount = function () {\n    if (!this.props.hidden) {\n      this._onMenuOpened();\n    }\n\n    this._mounted = true;\n  }; // Invoked immediately before a component is unmounted from the DOM.\n\n\n  ContextualMenuBase.prototype.componentWillUnmount = function () {\n    this._tryFocusPreviousActiveElement();\n\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._events.dispose();\n\n    this._async.dispose();\n\n    this._mounted = false;\n  };\n\n  ContextualMenuBase.prototype.render = function () {\n    var _this = this;\n\n    var isBeakVisible = this.props.isBeakVisible;\n    var _a = this.props,\n        items = _a.items,\n        labelElementId = _a.labelElementId,\n        id = _a.id,\n        className = _a.className,\n        beakWidth = _a.beakWidth,\n        directionalHint = _a.directionalHint,\n        directionalHintForRTL = _a.directionalHintForRTL,\n        alignTargetEdge = _a.alignTargetEdge,\n        gapSpace = _a.gapSpace,\n        coverTarget = _a.coverTarget,\n        ariaLabel = _a.ariaLabel,\n        doNotLayer = _a.doNotLayer,\n        target = _a.target,\n        bounds = _a.bounds,\n        useTargetWidth = _a.useTargetWidth,\n        useTargetAsMinWidth = _a.useTargetAsMinWidth,\n        directionalHintFixed = _a.directionalHintFixed,\n        shouldFocusOnMount = _a.shouldFocusOnMount,\n        shouldFocusOnContainer = _a.shouldFocusOnContainer,\n        title = _a.title,\n        styles = _a.styles,\n        theme = _a.theme,\n        calloutProps = _a.calloutProps,\n        _b = _a.onRenderSubMenu,\n        onRenderSubMenu = _b === void 0 ? this._onRenderSubMenu : _b,\n        _c = _a.onRenderMenuList,\n        onRenderMenuList = _c === void 0 ? this._onRenderMenuList : _c,\n        focusZoneProps = _a.focusZoneProps,\n        getMenuClassNames = _a.getMenuClassNames;\n    this._classNames = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames(styles, {\n      theme: theme,\n      className: className\n    });\n    var hasIcons = itemsHaveIcons(items);\n\n    function itemsHaveIcons(contextualMenuItems) {\n      for (var _i = 0, contextualMenuItems_1 = contextualMenuItems; _i < contextualMenuItems_1.length; _i++) {\n        var item = contextualMenuItems_1[_i];\n\n        if (!!item.iconProps) {\n          return true;\n        }\n\n        if (item.itemType === ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    this._adjustedFocusZoneProps = tslib_1.__assign({}, focusZoneProps, {\n      direction: this._getFocusZoneDirection()\n    });\n    var hasCheckmarks = canAnyMenuItemsCheck(items);\n    var submenuProps = this.state.expandedMenuItemKey && this.props.hidden !== true ? this._getSubmenuProps() : null;\n    isBeakVisible = isBeakVisible === undefined ? this.props.responsiveMode <= ResponsiveMode.medium : isBeakVisible;\n    /**\n     * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n     */\n\n    var contextMenuStyle;\n    var targetAsHtmlElement = this._target;\n\n    if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n      var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n      var targetWidth = targetBoundingRect.width - 2\n      /* Accounts for 1px border */\n      ;\n\n      if (useTargetWidth) {\n        contextMenuStyle = {\n          width: targetWidth\n        };\n      } else if (useTargetAsMinWidth) {\n        contextMenuStyle = {\n          minWidth: targetWidth\n        };\n      }\n    } // The menu should only return if items were provided, if no items were provided then it should not appear.\n\n\n    if (items && items.length > 0) {\n      var totalItemCount = 0;\n\n      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n        var item = items_1[_i];\n\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          totalItemCount += itemCount;\n        }\n      }\n\n      var calloutStyles = !getMenuClassNames && this._classNames.subComponentStyles ? this._classNames.subComponentStyles.callout : undefined;\n      return React.createElement(Callout, tslib_1.__assign({\n        styles: calloutStyles\n      }, calloutProps, {\n        target: target,\n        isBeakVisible: isBeakVisible,\n        beakWidth: beakWidth,\n        directionalHint: directionalHint,\n        directionalHintForRTL: directionalHintForRTL,\n        gapSpace: gapSpace,\n        coverTarget: coverTarget,\n        doNotLayer: doNotLayer,\n        className: css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className),\n        setInitialFocus: shouldFocusOnMount,\n        onDismiss: this.props.onDismiss,\n        onScroll: this._onScroll,\n        bounds: bounds,\n        directionalHintFixed: directionalHintFixed,\n        alignTargetEdge: alignTargetEdge,\n        hidden: this.props.hidden\n      }), React.createElement(\"div\", {\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": labelElementId,\n        style: contextMenuStyle,\n        ref: function (host) {\n          return _this._host = host;\n        },\n        id: id,\n        className: this._classNames.container,\n        tabIndex: shouldFocusOnContainer ? 0 : -1,\n        onKeyDown: this._onMenuKeyDown,\n        onKeyUp: this._onKeyUp,\n        onFocusCapture: this._onMenuFocusCapture\n      }, title && React.createElement(\"div\", {\n        className: this._classNames.title\n      }, \" \", title, \" \"), items && items.length ? React.createElement(FocusZone, tslib_1.__assign({}, this._adjustedFocusZoneProps, {\n        className: this._classNames.root,\n        isCircularNavigation: true,\n        handleTabKey: FocusZoneTabbableElements.all\n      }), onRenderMenuList({\n        items: items,\n        totalItemCount: totalItemCount,\n        hasCheckmarks: hasCheckmarks,\n        hasIcons: hasIcons\n      }, this._onRenderMenuList)) : null, submenuProps && onRenderSubMenu(submenuProps, this._onRenderSubMenu)));\n    } else {\n      return null;\n    }\n  };\n\n  ContextualMenuBase.prototype._onMenuOpened = function () {\n    this._events.on(this._targetWindow, 'resize', this.dismiss);\n\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n    this.props.onMenuOpened && this.props.onMenuOpened(this.props);\n  };\n\n  ContextualMenuBase.prototype._onMenuClosed = function () {\n    this._events.off(this._targetWindow, 'resize', this.dismiss);\n\n    this._tryFocusPreviousActiveElement();\n\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover; // We need to dismiss any submenu related state properties,\n    // so that when the menu is shown again, the submenu is collapsed\n\n    this.setState({\n      expandedByMouseClick: undefined,\n      dismissedMenuItemKey: undefined,\n      expandedMenuItemKey: undefined,\n      submenuTarget: undefined\n    });\n  };\n\n  ContextualMenuBase.prototype._tryFocusPreviousActiveElement = function () {\n    var _this = this;\n\n    if (this._isFocusingPreviousElement && this._previousActiveElement) {\n      // This slight delay is required so that we can unwind the stack, const react try to mess with focus, and then\n      // apply the correct focus. Without the setTimeout, we end up focusing the correct thing, and then React wants\n      // to reset the focus back to the thing it thinks should have been focused.\n      // Note: Cannot be replaced by this._async.setTimout because those will be removed by the time this is called.\n      setTimeout(function () {\n        _this._previousActiveElement && _this._previousActiveElement.focus();\n      }, 0);\n    }\n  };\n  /**\n   * Gets the focusZoneDirection by using the arrowDirection if specified,\n   * the direction specificed in the focusZoneProps, or defaults to FocusZoneDirection.vertical\n   */\n\n\n  ContextualMenuBase.prototype._getFocusZoneDirection = function () {\n    var focusZoneProps = this.props.focusZoneProps;\n    return focusZoneProps && focusZoneProps.direction !== undefined ? focusZoneProps.direction : FocusZoneDirection.vertical;\n  };\n\n  ContextualMenuBase.prototype._onRenderSubMenu = function (subMenuProps, defaultRender) {\n    throw Error('ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' + 'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.');\n  };\n\n  ContextualMenuBase.prototype._renderMenuItem = function (item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var renderedItems = [];\n    var iconProps = item.iconProps || {\n      iconName: 'None'\n    };\n    var getItemClassNames = item.getItemClassNames,\n        itemProps = item.itemProps;\n    var styles = itemProps ? itemProps.styles : undefined; // We only send a dividerClassName when the item to be rendered is a divider. For all other cases, the default divider style is used.\n\n    var dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n    var subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : '';\n    var itemClassNames; // IContextualMenuItem#getItemClassNames for backwards compatibility\n    // otherwise uses mergeStyles for class names.\n\n    if (getItemClassNames) {\n      itemClassNames = getItemClassNames(this.props.theme, isItemDisabled(item), this.state.expandedMenuItemKey === item.key, !!getIsChecked(item), !!item.href, iconProps.iconName !== 'None', item.className, dividerClassName, iconProps.className, subMenuIconClassName, item.primaryDisabled);\n    } else {\n      var itemStyleProps = {\n        theme: this.props.theme,\n        disabled: isItemDisabled(item),\n        expanded: this.state.expandedMenuItemKey === item.key,\n        checked: !!getIsChecked(item),\n        isAnchorLink: !!item.href,\n        knownIcon: iconProps.iconName !== 'None',\n        itemClassName: item.className,\n        dividerClassName: dividerClassName,\n        iconClassName: iconProps.className,\n        subMenuClassName: subMenuIconClassName,\n        primaryDisabled: item.primaryDisabled\n      };\n      var menuItemStyles = this._classNames.subComponentStyles ? this._classNames.subComponentStyles.menuItem : undefined; // We need to generate default styles then override if styles are provided\n      // since the ContextualMenu currently handles item classNames.\n\n      itemClassNames = mergeStyleSets(getContextualMenuItemClassNames(getItemStyles, itemStyleProps), getContextualMenuItemClassNames(menuItemStyles, itemStyleProps), getContextualMenuItemClassNames(styles, itemStyleProps));\n    }\n\n    if (item.text === '-' || item.name === '-') {\n      item.itemType = ContextualMenuItemType.Divider;\n    }\n\n    switch (item.itemType) {\n      case ContextualMenuItemType.Divider:\n        renderedItems.push(this._renderSeparator(index, itemClassNames));\n        break;\n\n      case ContextualMenuItemType.Header:\n        renderedItems.push(this._renderSeparator(index, itemClassNames));\n\n        var headerItem = this._renderHeaderMenuItem(item, itemClassNames, index, hasCheckmarks, hasIcons);\n\n        renderedItems.push(this._renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n        break;\n\n      case ContextualMenuItemType.Section:\n        renderedItems.push(this._renderSectionItem(item, itemClassNames, index, hasCheckmarks, hasIcons));\n        break;\n\n      default:\n        var menuItem = this._renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n\n        renderedItems.push(this._renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n        break;\n    }\n\n    return renderedItems;\n  };\n\n  ContextualMenuBase.prototype._renderSectionItem = function (sectionItem, menuClassNames, index, hasCheckmarks, hasIcons) {\n    var _this = this;\n\n    var sectionProps = sectionItem.sectionProps;\n\n    if (!sectionProps) {\n      return;\n    }\n\n    var headerItem;\n\n    if (sectionProps.title) {\n      var headerContextualMenuItem = {\n        key: \"section-\" + sectionProps.title + \"-title\",\n        itemType: ContextualMenuItemType.Header,\n        text: sectionProps.title\n      };\n      headerItem = this._renderHeaderMenuItem(headerContextualMenuItem, menuClassNames, index, hasCheckmarks, hasIcons);\n    }\n\n    if (sectionProps.items && sectionProps.items.length > 0) {\n      return React.createElement(\"li\", {\n        role: \"presentation\",\n        key: sectionProps.key || sectionItem.key || \"section-\" + index\n      }, React.createElement(\"div\", {\n        role: \"group\"\n      }, React.createElement(\"ul\", {\n        className: this._classNames.list\n      }, sectionProps.topDivider && this._renderSeparator(index, menuClassNames, true, true), headerItem && this._renderListItem(headerItem, sectionItem.key || index, menuClassNames, sectionItem.title), sectionProps.items.map(function (contextualMenuItem, itemsIndex) {\n        return _this._renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, sectionProps.items.length, hasCheckmarks, hasIcons);\n      }), sectionProps.bottomDivider && this._renderSeparator(index, menuClassNames, false, true))));\n    }\n  };\n\n  ContextualMenuBase.prototype._renderListItem = function (content, key, classNames, title) {\n    return React.createElement(\"li\", {\n      role: \"presentation\",\n      title: title,\n      key: key,\n      className: classNames.item\n    }, content);\n  };\n\n  ContextualMenuBase.prototype._renderSeparator = function (index, classNames, top, fromSection) {\n    if (fromSection || index > 0) {\n      return React.createElement(\"li\", {\n        role: \"separator\",\n        key: 'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom'),\n        className: classNames.divider,\n        \"aria-hidden\": \"true\"\n      });\n    }\n\n    return null;\n  };\n\n  ContextualMenuBase.prototype._renderNormalItem = function (item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    if (item.onRender) {\n      return item.onRender(tslib_1.__assign({\n        'aria-posinset': focusableElementIndex + 1,\n        'aria-setsize': totalItemCount\n      }, item), this.dismiss);\n    }\n\n    if (item.href) {\n      return this._renderAnchorMenuItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    }\n\n    if (item.split && hasSubmenu(item)) {\n      return this._renderSplitButton(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    }\n\n    return this._renderButtonItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n  };\n\n  ContextualMenuBase.prototype._renderHeaderMenuItem = function (item, classNames, index, hasCheckmarks, hasIcons) {\n    var _a = this.props.contextualMenuItemAs,\n        ChildrenRenderer = _a === void 0 ? ContextualMenuItem : _a;\n    var itemProps = item.itemProps;\n    var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);\n    return React.createElement(\"div\", tslib_1.__assign({\n      className: this._classNames.header\n    }, divHtmlProperties, {\n      style: item.style\n    }), React.createElement(ChildrenRenderer, tslib_1.__assign({\n      item: item,\n      classNames: classNames,\n      index: index,\n      onCheckmarkClick: hasCheckmarks ? this._onItemClick : undefined,\n      hasIcons: hasIcons\n    }, itemProps)));\n  };\n\n  ContextualMenuBase.prototype._renderAnchorMenuItem = function (item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuAnchor, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onAnchorClick,\n      onItemKeyDown: this._onItemKeyDown,\n      getSubMenuId: this._getSubMenuId,\n      expandedMenuItemKey: expandedMenuItemKey,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss\n    });\n  };\n\n  ContextualMenuBase.prototype._renderButtonItem = function (item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuButton, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onItemClick,\n      onItemClickBase: this._onItemClickBase,\n      onItemKeyDown: this._onItemKeyDown,\n      getSubMenuId: this._getSubMenuId,\n      expandedMenuItemKey: expandedMenuItemKey,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss\n    });\n  };\n\n  ContextualMenuBase.prototype._renderSplitButton = function (item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuSplitButton, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onItemClick,\n      onItemClickBase: this._onItemClickBase,\n      onItemKeyDown: this._onItemKeyDown,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss,\n      expandedMenuItemKey: expandedMenuItemKey,\n      onTap: this._onPointerAndTouchEvent\n    });\n  };\n  /**\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n   */\n\n\n  ContextualMenuBase.prototype._isAltOrMeta = function (ev) {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  };\n\n  ContextualMenuBase.prototype._shouldIgnoreMouseEvent = function () {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  };\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n\n\n  ContextualMenuBase.prototype._updateFocusOnMouseEvent = function (item, ev, target) {\n    var _this = this;\n\n    var targetElement = target ? target : ev.currentTarget;\n    var _a = this.props.subMenuHoverDelay,\n        timeoutDuration = _a === void 0 ? NavigationIdleDelay : _a;\n\n    if (item.key === this.state.expandedMenuItemKey) {\n      return;\n    }\n\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n\n      this._enterTimerId = undefined;\n    } // If the menu is not expanded we can update focus without any delay\n\n\n    if (this.state.expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    } // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n\n\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      this._enterTimerId = this._async.setTimeout(function () {\n        targetElement.focus();\n\n        _this.setState({\n          expandedByMouseClick: true\n        });\n\n        _this._onItemSubMenuExpand(item, targetElement);\n\n        _this._enterTimerId = undefined;\n      }, timeoutDuration);\n    } else {\n      this._enterTimerId = this._async.setTimeout(function () {\n        _this._onSubMenuDismiss(ev);\n\n        targetElement.focus();\n        _this._enterTimerId = undefined;\n      }, timeoutDuration);\n    }\n  };\n\n  ContextualMenuBase.prototype._getSubmenuProps = function () {\n    var _a = this.state,\n        submenuTarget = _a.submenuTarget,\n        expandedMenuItemKey = _a.expandedMenuItemKey;\n\n    var item = this._findItemByKey(expandedMenuItemKey);\n\n    var submenuProps = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item),\n        target: submenuTarget,\n        onDismiss: this._onSubMenuDismiss,\n        isSubMenu: true,\n        id: this.state.subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer: this.state.expandedByMouseClick,\n        directionalHint: getRTL() ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className: this.props.className,\n        gapSpace: 0,\n        isBeakVisible: false\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n    }\n\n    return submenuProps;\n  };\n\n  ContextualMenuBase.prototype._findItemByKey = function (key) {\n    var items = this.props.items;\n    return this._findItemByKeyFromItems(key, items);\n  };\n  /**\n   * Returns the item that mathes a given key if any.\n   * @param key - The key of the item to match\n   * @param items - The items to look for the key\n   */\n\n\n  ContextualMenuBase.prototype._findItemByKeyFromItems = function (key, items) {\n    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {\n      var item = items_2[_i];\n\n      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n        var match = this._findItemByKeyFromItems(key, item.sectionProps.items);\n\n        if (match) {\n          return match;\n        }\n      } else if (item.key && item.key === key) {\n        return item;\n      }\n    }\n  };\n\n  ContextualMenuBase.prototype._setTargetWindowAndElement = function (target) {\n    if (target) {\n      if (typeof target === 'string') {\n        var currentDoc = getDocument();\n        this._target = currentDoc ? currentDoc.querySelector(target) : null;\n        this._targetWindow = getWindow();\n      } else if (target.stopPropagation) {\n        this._targetWindow = getWindow(target.toElement);\n        this._target = target;\n      } else if (target.x !== undefined && target.y !== undefined) {\n        this._targetWindow = getWindow();\n        this._target = target;\n      } else if (target.current !== undefined) {\n        this._target = target.current;\n        this._targetWindow = getWindow(this._target);\n      } else {\n        var targetElement = target;\n        this._targetWindow = getWindow(targetElement);\n        this._target = target;\n      }\n    } else {\n      this._targetWindow = getWindow();\n    }\n  }; // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\n\n\n  ContextualMenuBase.defaultProps = {\n    items: [],\n    shouldFocusOnMount: true,\n    gapSpace: 0,\n    directionalHint: DirectionalHint.bottomAutoEdge,\n    beakWidth: 16\n  };\n  ContextualMenuBase = tslib_1.__decorate([withResponsiveMode], ContextualMenuBase);\n  return ContextualMenuBase;\n}(BaseComponent);\n\nexport { ContextualMenuBase };","map":{"version":3,"sources":["components/ContextualMenu/ContextualMenu.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  IContextualMenuProps,\n  IContextualMenuItem,\n  ContextualMenuItemType,\n  IContextualMenuListProps,\n  IContextualMenuStyleProps,\n  IContextualMenuStyles\n} from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, IFocusZoneProps, FocusZoneTabbableElements } from '../../FocusZone';\nimport { IMenuItemClassNames, IContextualMenuClassNames } from './ContextualMenu.classNames';\nimport { divProperties, getNativeProps, shallowCompare } from '../../Utilities';\n\nimport {\n  assign,\n  BaseComponent,\n  classNamesFunction,\n  css,\n  getDocument,\n  getFirstFocusable,\n  getId,\n  getLastFocusable,\n  getRTL,\n  getWindow,\n  IRenderFunction,\n  IPoint,\n  KeyCodes,\n  shouldWrapFocus,\n  IStyleFunctionOrObject,\n  isIOS,\n  isMac\n} from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { Callout, ICalloutContentStyleProps, ICalloutContentStyles, Target } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport { ContextualMenuSplitButton, ContextualMenuButton, ContextualMenuAnchor } from './ContextualMenuItemWrapper/index';\nimport { IProcessedStyleSet, mergeStyleSets } from '../../Styling';\nimport { IContextualMenuItemStyleProps, IContextualMenuItemStyles } from './ContextualMenuItem.types';\n\nimport { getItemStyles } from './ContextualMenu.classNames';\n\nconst getClassNames = classNamesFunction<IContextualMenuStyleProps, IContextualMenuStyles>({\n  disableCaching: true\n});\nconst getContextualMenuItemClassNames = classNamesFunction<IContextualMenuItemStyleProps, IContextualMenuItemStyles>({\n  disableCaching: true\n});\n\nexport interface IContextualMenuState {\n  expandedMenuItemKey?: string;\n  /** True if the menu was expanded by mouse click OR hover (as opposed to by keyboard) */\n  expandedByMouseClick?: boolean;\n  dismissedMenuItemKey?: string;\n  contextualMenuItems?: IContextualMenuItem[];\n  contextualMenuTarget?: Element;\n  submenuTarget?: Element;\n  positions?: any;\n  slideDirectionalClassName?: string;\n  subMenuId?: string;\n  submenuDirection?: DirectionalHint;\n}\n\nexport function getSubmenuItems(item: IContextualMenuItem): IContextualMenuItem[] | undefined {\n  return item.subMenuProps ? item.subMenuProps.items : item.items;\n}\n\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\nexport function canAnyMenuItemsCheck(items: IContextualMenuItem[]): boolean {\n  return items.some(item => {\n    if (item.canCheck) {\n      return true;\n    }\n\n    // If the item is a section, check if any of the items in the section can check.\n    if (item.sectionProps && item.sectionProps.items.some(submenuItem => submenuItem.canCheck === true)) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nconst NavigationIdleDelay = 250 /* ms */;\n\n@withResponsiveMode\nexport class ContextualMenuBase extends BaseComponent<IContextualMenuProps, IContextualMenuState> {\n  // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\n  public static defaultProps: IContextualMenuProps = {\n    items: [],\n    shouldFocusOnMount: true,\n    gapSpace: 0,\n    directionalHint: DirectionalHint.bottomAutoEdge,\n    beakWidth: 16\n  };\n\n  private _host: HTMLElement;\n  private _previousActiveElement: HTMLElement | null;\n  private _isFocusingPreviousElement: boolean;\n  private _enterTimerId: number | undefined;\n  private _targetWindow: Window;\n  private _target: Element | MouseEvent | IPoint | null;\n  private _isScrollIdle: boolean;\n  private _scrollIdleTimeoutId: number | undefined;\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n  private _lastKeyDownWasAltOrMeta: boolean | undefined;\n  private _shouldUpdateFocusOnMouseEvent: boolean;\n  private _gotMouseMove: boolean;\n  private _mounted = false;\n\n  private _adjustedFocusZoneProps: IFocusZoneProps;\n\n  private _classNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames;\n\n  constructor(props: IContextualMenuProps) {\n    super(props);\n\n    this.state = {\n      contextualMenuItems: undefined,\n      subMenuId: getId('ContextualMenu')\n    };\n\n    this._warnDeprecations({\n      getMenuClassNames: 'styles'\n    });\n\n    this._isFocusingPreviousElement = false;\n    this._isScrollIdle = true;\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n  }\n\n  public dismiss = (ev?: any, dismissAll?: boolean) => {\n    const { onDismiss } = this.props;\n\n    if (onDismiss) {\n      onDismiss(ev, dismissAll);\n    }\n  };\n\n  public shouldComponentUpdate(newProps: IContextualMenuProps, newState: IContextualMenuState): boolean {\n    if (this.props.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return false;\n    }\n\n    return !shallowCompare(this.props, newProps) || !shallowCompare(this.state, newState);\n  }\n\n  // tslint:disable-next-line function-name\n  public UNSAFE_componentWillUpdate(newProps: IContextualMenuProps): void {\n    if (newProps.target !== this.props.target) {\n      const newTarget = newProps.target;\n      this._setTargetWindowAndElement(newTarget!);\n    }\n    if (newProps.hidden !== this.props.hidden) {\n      if (newProps.hidden) {\n        this._onMenuClosed();\n      } else {\n        this._onMenuOpened();\n        this._previousActiveElement = this._targetWindow ? (this._targetWindow.document.activeElement as HTMLElement) : null;\n      }\n    }\n    if (newProps.delayUpdateFocusOnHover !== this.props.delayUpdateFocusOnHover) {\n      // update shouldUpdateFocusOnMouseEvent to follow what was passed in\n      this._shouldUpdateFocusOnMouseEvent = !newProps.delayUpdateFocusOnHover;\n\n      // If shouldUpdateFocusOnMouseEvent is false, we need to reset gotMouseMove to false\n      this._gotMouseMove = this._shouldUpdateFocusOnMouseEvent && this._gotMouseMove;\n    }\n  }\n\n  // Invoked once, both on the client and server, immediately before the initial rendering occurs.\n  // tslint:disable-next-line function-name\n  public UNSAFE_componentWillMount() {\n    const target = this.props.target;\n    this._setTargetWindowAndElement(target!);\n    if (!this.props.hidden) {\n      this._previousActiveElement = this._targetWindow ? (this._targetWindow.document.activeElement as HTMLElement) : null;\n    }\n  }\n\n  // Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.\n  public componentDidMount(): void {\n    if (!this.props.hidden) {\n      this._onMenuOpened();\n    }\n\n    this._mounted = true;\n  }\n\n  // Invoked immediately before a component is unmounted from the DOM.\n  public componentWillUnmount() {\n    this._tryFocusPreviousActiveElement();\n\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._events.dispose();\n    this._async.dispose();\n    this._mounted = false;\n  }\n\n  public render(): JSX.Element | null {\n    let { isBeakVisible } = this.props;\n\n    const {\n      items,\n      labelElementId,\n      id,\n      className,\n      beakWidth,\n      directionalHint,\n      directionalHintForRTL,\n      alignTargetEdge,\n      gapSpace,\n      coverTarget,\n      ariaLabel,\n      doNotLayer,\n      target,\n      bounds,\n      useTargetWidth,\n      useTargetAsMinWidth,\n      directionalHintFixed,\n      shouldFocusOnMount,\n      shouldFocusOnContainer,\n      title,\n      styles,\n      theme,\n      calloutProps,\n      onRenderSubMenu = this._onRenderSubMenu,\n      onRenderMenuList = this._onRenderMenuList,\n      focusZoneProps,\n      getMenuClassNames\n    } = this.props;\n\n    this._classNames = getMenuClassNames\n      ? getMenuClassNames(theme!, className)\n      : getClassNames(styles, {\n          theme: theme!,\n          className: className\n        });\n\n    const hasIcons = itemsHaveIcons(items);\n\n    function itemsHaveIcons(contextualMenuItems: IContextualMenuItem[]): boolean {\n      for (const item of contextualMenuItems) {\n        if (!!item.iconProps) {\n          return true;\n        }\n\n        if (item.itemType === ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    this._adjustedFocusZoneProps = { ...focusZoneProps, direction: this._getFocusZoneDirection() };\n\n    const hasCheckmarks = canAnyMenuItemsCheck(items);\n    const submenuProps = this.state.expandedMenuItemKey && this.props.hidden !== true ? this._getSubmenuProps() : null;\n\n    isBeakVisible = isBeakVisible === undefined ? this.props.responsiveMode! <= ResponsiveMode.medium : isBeakVisible;\n    /**\n     * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n     */\n    let contextMenuStyle;\n    const targetAsHtmlElement = this._target as HTMLElement;\n    if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n      const targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n      const targetWidth = targetBoundingRect.width - 2 /* Accounts for 1px border */;\n\n      if (useTargetWidth) {\n        contextMenuStyle = {\n          width: targetWidth\n        };\n      } else if (useTargetAsMinWidth) {\n        contextMenuStyle = {\n          minWidth: targetWidth\n        };\n      }\n    }\n\n    // The menu should only return if items were provided, if no items were provided then it should not appear.\n    if (items && items.length > 0) {\n      let totalItemCount = 0;\n      for (const item of items) {\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          const itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          totalItemCount += itemCount;\n        }\n      }\n\n      const calloutStyles =\n        !getMenuClassNames && this._classNames.subComponentStyles\n          ? (this._classNames.subComponentStyles.callout as IStyleFunctionOrObject<ICalloutContentStyleProps, ICalloutContentStyles>)\n          : undefined;\n\n      return (\n        <Callout\n          styles={calloutStyles}\n          {...calloutProps}\n          target={target}\n          isBeakVisible={isBeakVisible}\n          beakWidth={beakWidth}\n          directionalHint={directionalHint}\n          directionalHintForRTL={directionalHintForRTL}\n          gapSpace={gapSpace}\n          coverTarget={coverTarget}\n          doNotLayer={doNotLayer}\n          className={css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className)}\n          setInitialFocus={shouldFocusOnMount}\n          onDismiss={this.props.onDismiss}\n          onScroll={this._onScroll}\n          bounds={bounds}\n          directionalHintFixed={directionalHintFixed}\n          alignTargetEdge={alignTargetEdge}\n          hidden={this.props.hidden}\n        >\n          <div\n            aria-label={ariaLabel}\n            aria-labelledby={labelElementId}\n            style={contextMenuStyle}\n            ref={(host: HTMLDivElement) => (this._host = host)}\n            id={id}\n            className={this._classNames.container}\n            tabIndex={shouldFocusOnContainer ? 0 : -1}\n            onKeyDown={this._onMenuKeyDown}\n            onKeyUp={this._onKeyUp}\n            onFocusCapture={this._onMenuFocusCapture}\n          >\n            {title && <div className={this._classNames.title}> {title} </div>}\n            {items && items.length ? (\n              <FocusZone\n                {...this._adjustedFocusZoneProps}\n                className={this._classNames.root}\n                isCircularNavigation={true}\n                handleTabKey={FocusZoneTabbableElements.all}\n              >\n                {onRenderMenuList(\n                  {\n                    items,\n                    totalItemCount,\n                    hasCheckmarks,\n                    hasIcons\n                  },\n                  this._onRenderMenuList\n                )}\n              </FocusZone>\n            ) : null}\n            {submenuProps && onRenderSubMenu(submenuProps, this._onRenderSubMenu)}\n          </div>\n        </Callout>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  private _onMenuOpened() {\n    this._events.on(this._targetWindow, 'resize', this.dismiss);\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n    this.props.onMenuOpened && this.props.onMenuOpened(this.props);\n  }\n\n  private _onMenuClosed() {\n    this._events.off(this._targetWindow, 'resize', this.dismiss);\n    this._tryFocusPreviousActiveElement();\n\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n\n    // We need to dismiss any submenu related state properties,\n    // so that when the menu is shown again, the submenu is collapsed\n    this.setState({\n      expandedByMouseClick: undefined,\n      dismissedMenuItemKey: undefined,\n      expandedMenuItemKey: undefined,\n      submenuTarget: undefined\n    });\n  }\n\n  private _tryFocusPreviousActiveElement() {\n    if (this._isFocusingPreviousElement && this._previousActiveElement) {\n      // This slight delay is required so that we can unwind the stack, const react try to mess with focus, and then\n      // apply the correct focus. Without the setTimeout, we end up focusing the correct thing, and then React wants\n      // to reset the focus back to the thing it thinks should have been focused.\n      // Note: Cannot be replaced by this._async.setTimout because those will be removed by the time this is called.\n      setTimeout(() => {\n        this._previousActiveElement && this._previousActiveElement!.focus();\n      }, 0);\n    }\n  }\n\n  /**\n   * Gets the focusZoneDirection by using the arrowDirection if specified,\n   * the direction specificed in the focusZoneProps, or defaults to FocusZoneDirection.vertical\n   */\n  private _getFocusZoneDirection() {\n    const { focusZoneProps } = this.props;\n    return focusZoneProps && focusZoneProps.direction !== undefined ? focusZoneProps.direction : FocusZoneDirection.vertical;\n  }\n\n  private _onRenderSubMenu(subMenuProps: IContextualMenuProps, defaultRender?: IRenderFunction<IContextualMenuProps>): JSX.Element {\n    throw Error(\n      'ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' +\n        'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.'\n    );\n  }\n\n  private _onRenderMenuList = (\n    menuListProps: IContextualMenuListProps,\n    defaultRender?: IRenderFunction<IContextualMenuListProps>\n  ): JSX.Element => {\n    let indexCorrection = 0;\n    return (\n      <ul className={this._classNames.list} onKeyDown={this._onKeyDown} onKeyUp={this._onKeyUp} role=\"menu\">\n        {menuListProps.items.map((item, index) => {\n          const menuItem = this._renderMenuItem(\n            item,\n            index,\n            indexCorrection,\n            menuListProps.totalItemCount,\n            menuListProps.hasCheckmarks,\n            menuListProps.hasIcons\n          );\n          if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n            const indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n            indexCorrection += indexIncrease;\n          }\n          return menuItem;\n        })}\n      </ul>\n    );\n  };\n\n  private _renderMenuItem(\n    item: IContextualMenuItem,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean\n  ): React.ReactNode {\n    const renderedItems: React.ReactNode[] = [];\n    const iconProps = item.iconProps || { iconName: 'None' };\n    const { getItemClassNames, itemProps } = item;\n    const styles = itemProps ? itemProps.styles : undefined;\n\n    // We only send a dividerClassName when the item to be rendered is a divider. For all other cases, the default divider style is used.\n    const dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n    const subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : '';\n\n    let itemClassNames: IMenuItemClassNames;\n\n    // IContextualMenuItem#getItemClassNames for backwards compatibility\n    // otherwise uses mergeStyles for class names.\n    if (getItemClassNames) {\n      itemClassNames = getItemClassNames(\n        this.props.theme!,\n        isItemDisabled(item),\n        this.state.expandedMenuItemKey === item.key,\n        !!getIsChecked(item),\n        !!item.href,\n        iconProps.iconName !== 'None',\n        item.className,\n        dividerClassName,\n        iconProps.className,\n        subMenuIconClassName,\n        item.primaryDisabled\n      );\n    } else {\n      const itemStyleProps: IContextualMenuItemStyleProps = {\n        theme: this.props.theme!,\n        disabled: isItemDisabled(item),\n        expanded: this.state.expandedMenuItemKey === item.key,\n        checked: !!getIsChecked(item),\n        isAnchorLink: !!item.href,\n        knownIcon: iconProps.iconName !== 'None',\n        itemClassName: item.className,\n        dividerClassName,\n        iconClassName: iconProps.className,\n        subMenuClassName: subMenuIconClassName,\n        primaryDisabled: item.primaryDisabled\n      };\n\n      const menuItemStyles = this._classNames.subComponentStyles\n        ? (this._classNames.subComponentStyles.menuItem as IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles>)\n        : undefined;\n\n      // We need to generate default styles then override if styles are provided\n      // since the ContextualMenu currently handles item classNames.\n      itemClassNames = mergeStyleSets(\n        getContextualMenuItemClassNames(getItemStyles, itemStyleProps),\n        getContextualMenuItemClassNames(menuItemStyles, itemStyleProps),\n        getContextualMenuItemClassNames(styles, itemStyleProps)\n      );\n    }\n\n    if (item.text === '-' || item.name === '-') {\n      item.itemType = ContextualMenuItemType.Divider;\n    }\n    switch (item.itemType) {\n      case ContextualMenuItemType.Divider:\n        renderedItems.push(this._renderSeparator(index, itemClassNames));\n        break;\n      case ContextualMenuItemType.Header:\n        renderedItems.push(this._renderSeparator(index, itemClassNames));\n        const headerItem = this._renderHeaderMenuItem(item, itemClassNames, index, hasCheckmarks, hasIcons);\n        renderedItems.push(this._renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n        break;\n      case ContextualMenuItemType.Section:\n        renderedItems.push(this._renderSectionItem(item, itemClassNames, index, hasCheckmarks, hasIcons));\n        break;\n      default:\n        const menuItem = this._renderNormalItem(\n          item,\n          itemClassNames,\n          index,\n          focusableElementIndex,\n          totalItemCount,\n          hasCheckmarks,\n          hasIcons\n        );\n        renderedItems.push(this._renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n        break;\n    }\n\n    return renderedItems;\n  }\n\n  private _renderSectionItem(\n    sectionItem: IContextualMenuItem,\n    menuClassNames: IMenuItemClassNames,\n    index: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean\n  ) {\n    const sectionProps = sectionItem.sectionProps;\n    if (!sectionProps) {\n      return;\n    }\n\n    let headerItem;\n    if (sectionProps.title) {\n      const headerContextualMenuItem: IContextualMenuItem = {\n        key: `section-${sectionProps.title}-title`,\n        itemType: ContextualMenuItemType.Header,\n        text: sectionProps.title\n      };\n      headerItem = this._renderHeaderMenuItem(headerContextualMenuItem, menuClassNames, index, hasCheckmarks, hasIcons);\n    }\n\n    if (sectionProps.items && sectionProps.items.length > 0) {\n      return (\n        <li role=\"presentation\" key={sectionProps.key || sectionItem.key || `section-${index}`}>\n          <div role=\"group\">\n            <ul className={this._classNames.list}>\n              {sectionProps.topDivider && this._renderSeparator(index, menuClassNames, true, true)}\n              {headerItem && this._renderListItem(headerItem, sectionItem.key || index, menuClassNames, sectionItem.title)}\n              {sectionProps.items.map((contextualMenuItem, itemsIndex) =>\n                this._renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, sectionProps.items.length, hasCheckmarks, hasIcons)\n              )}\n              {sectionProps.bottomDivider && this._renderSeparator(index, menuClassNames, false, true)}\n            </ul>\n          </div>\n        </li>\n      );\n    }\n  }\n\n  private _renderListItem(content: React.ReactNode, key: string | number, classNames: IMenuItemClassNames, title?: string) {\n    return (\n      <li role=\"presentation\" title={title} key={key} className={classNames.item}>\n        {content}\n      </li>\n    );\n  }\n\n  private _renderSeparator(index: number, classNames: IMenuItemClassNames, top?: boolean, fromSection?: boolean): React.ReactNode {\n    if (fromSection || index > 0) {\n      return (\n        <li\n          role=\"separator\"\n          key={'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom')}\n          className={classNames.divider}\n          aria-hidden=\"true\"\n        />\n      );\n    }\n    return null;\n  }\n\n  private _renderNormalItem(\n    item: IContextualMenuItem,\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean\n  ): React.ReactNode {\n    if (item.onRender) {\n      return item.onRender({ 'aria-posinset': focusableElementIndex + 1, 'aria-setsize': totalItemCount, ...item }, this.dismiss);\n    }\n    if (item.href) {\n      return this._renderAnchorMenuItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    }\n\n    if (item.split && hasSubmenu(item)) {\n      return this._renderSplitButton(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    }\n\n    return this._renderButtonItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n  }\n\n  private _renderHeaderMenuItem(\n    item: IContextualMenuItem,\n    classNames: IMenuItemClassNames,\n    index: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean\n  ): React.ReactNode {\n    const { contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem } = this.props;\n    const { itemProps } = item;\n    const divHtmlProperties = itemProps && getNativeProps<React.HTMLAttributes<HTMLDivElement>>(itemProps, divProperties);\n    return (\n      <div className={this._classNames.header} {...divHtmlProperties} style={item.style}>\n        <ChildrenRenderer\n          item={item}\n          classNames={classNames}\n          index={index}\n          onCheckmarkClick={hasCheckmarks ? this._onItemClick : undefined}\n          hasIcons={hasIcons}\n          {...itemProps}\n        />\n      </div>\n    );\n  }\n\n  private _renderAnchorMenuItem(\n    item: IContextualMenuItem,\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean\n  ): React.ReactNode {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n    return (\n      <ContextualMenuAnchor\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onAnchorClick}\n        onItemKeyDown={this._onItemKeyDown}\n        getSubMenuId={this._getSubMenuId}\n        expandedMenuItemKey={expandedMenuItemKey}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n      />\n    );\n  }\n\n  private _renderButtonItem(\n    item: IContextualMenuItem,\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks?: boolean,\n    hasIcons?: boolean\n  ) {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n\n    return (\n      <ContextualMenuButton\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onItemClick}\n        onItemClickBase={this._onItemClickBase}\n        onItemKeyDown={this._onItemKeyDown}\n        getSubMenuId={this._getSubMenuId}\n        expandedMenuItemKey={expandedMenuItemKey}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n      />\n    );\n  }\n\n  private _renderSplitButton(\n    item: IContextualMenuItem,\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks?: boolean,\n    hasIcons?: boolean\n  ): JSX.Element {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n\n    return (\n      <ContextualMenuSplitButton\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onItemClick}\n        onItemClickBase={this._onItemClickBase}\n        onItemKeyDown={this._onItemKeyDown}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n        expandedMenuItemKey={expandedMenuItemKey}\n        onTap={this._onPointerAndTouchEvent}\n      />\n    );\n  }\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in _shouldHandleKeyUp for reasoning.\n    this._lastKeyDownWasAltOrMeta = this._isAltOrMeta(ev);\n\n    // On Mac, pressing escape dismisses all levels of native context menus\n    const dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n\n    return this._keyHandler(ev, this._shouldHandleKeyDown, dismissAllMenus);\n  };\n\n  private _shouldHandleKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    return ev.which === KeyCodes.escape || this._shouldCloseSubMenu(ev) || (ev.which === KeyCodes.up && (ev.altKey || ev.metaKey));\n  };\n\n  private _onMenuFocusCapture = (ev: React.FocusEvent<HTMLElement>) => {\n    if (this.props.delayUpdateFocusOnHover) {\n      this._shouldUpdateFocusOnMouseEvent = true;\n    }\n  };\n\n  private _onKeyUp = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    return this._keyHandler(ev, this._shouldHandleKeyUp, true /* dismissAllMenus */);\n  };\n\n  /**\n   * We close the menu on key up only if ALL of the following are true:\n   * - Most recent key down was alt or meta (command)\n   * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n   *   expand/collapse the menu)\n   * - We're not on a Mac (or iOS)\n   *\n   * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n   * closing any open context menus. There is not a similar behavior on Macs.\n   */\n  private _shouldHandleKeyUp = (ev: React.KeyboardEvent<HTMLElement>) => {\n    const keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);\n    this._lastKeyDownWasAltOrMeta = false;\n    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n  };\n\n  /**\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n   */\n  private _isAltOrMeta(ev: React.KeyboardEvent<HTMLElement>): boolean {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  }\n\n  /**\n   * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n   * if so, stops event propagation and dismisses menu(s).\n   * @param ev - The keyboard event.\n   * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n   * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n   * Only does anything if `shouldHandleKey` returns true.\n   * @returns Whether the event was handled.\n   */\n  private _keyHandler = (\n    ev: React.KeyboardEvent<HTMLElement>,\n    shouldHandleKey: (ev: React.KeyboardEvent<HTMLElement>) => boolean,\n    dismissAllMenus?: boolean\n  ): boolean => {\n    let handled = false;\n\n    if (shouldHandleKey(ev)) {\n      this._isFocusingPreviousElement = true;\n      ev.preventDefault();\n      ev.stopPropagation();\n      this.dismiss(ev, dismissAllMenus);\n      handled = true;\n    }\n\n    return handled;\n  };\n\n  /**\n   * Checks if the submenu should be closed\n   */\n  private _shouldCloseSubMenu = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    const submenuCloseKey = getRTL() ? KeyCodes.right : KeyCodes.left;\n\n    if (ev.which !== submenuCloseKey || !this.props.isSubMenu) {\n      return false;\n    }\n\n    return (\n      this._adjustedFocusZoneProps.direction === FocusZoneDirection.vertical ||\n      (!!this._adjustedFocusZoneProps.checkForNoWrap && !shouldWrapFocus(ev.target as HTMLElement, 'data-no-horizontal-wrap'))\n    );\n  };\n\n  private _onMenuKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    // Mark as handled if onKeyDown returns true (for handling collapse cases)\n    // or if we are attempting to expand a submenu\n    const handled = this._onKeyDown(ev);\n\n    if (handled || !this._host) {\n      return;\n    }\n\n    // If we have a modifier key being pressed, we do not want to move focus.\n    // Otherwise, handle up and down keys.\n    const hasModifier = !!(ev.altKey || ev.metaKey);\n    const isUp = ev.which === KeyCodes.up;\n    const isDown = ev.which === KeyCodes.down;\n    if (!hasModifier && (isUp || isDown)) {\n      const elementToFocus = isUp\n        ? getLastFocusable(this._host, this._host.lastChild as HTMLElement, true)\n        : getFirstFocusable(this._host, this._host.firstChild as HTMLElement, true);\n\n      if (elementToFocus) {\n        elementToFocus.focus();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n  private _onScroll = (): void => {\n    if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {\n      this._async.clearTimeout(this._scrollIdleTimeoutId);\n      this._scrollIdleTimeoutId = undefined;\n    } else {\n      this._isScrollIdle = false;\n    }\n\n    this._scrollIdleTimeoutId = this._async.setTimeout(() => {\n      this._isScrollIdle = true;\n    }, NavigationIdleDelay);\n  };\n\n  private _onItemMouseEnterBase = (item: any, ev: React.MouseEvent<HTMLElement>, target?: HTMLElement): void => {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    this._updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  private _onItemMouseMoveBase = (item: any, ev: React.MouseEvent<HTMLElement>, target: HTMLElement): void => {\n    const targetElement = ev.currentTarget as HTMLElement;\n\n    // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n    if (this._shouldUpdateFocusOnMouseEvent) {\n      this._gotMouseMove = true;\n    } else {\n      return;\n    }\n\n    if (\n      !this._isScrollIdle ||\n      this._enterTimerId !== undefined ||\n      targetElement === (this._targetWindow.document.activeElement as HTMLElement)\n    ) {\n      return;\n    }\n\n    this._updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  private _shouldIgnoreMouseEvent(): boolean {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  }\n\n  private _onMouseItemLeave = (item: any, ev: React.MouseEvent<HTMLElement>): void => {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n\n    if (this.state.expandedMenuItemKey !== undefined) {\n      return;\n    }\n\n    /**\n     * IE11 focus() method forces parents to scroll to top of element.\n     * Edge and IE expose a setActive() function for focusable divs that\n     * sets the page focus but does not scroll the parent element.\n     */\n    if ((this._host as any).setActive) {\n      try {\n        (this._host as any).setActive();\n      } catch (e) {\n        /* no-op */\n      }\n    } else {\n      this._host.focus();\n    }\n  };\n\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n  private _updateFocusOnMouseEvent(item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>, target?: HTMLElement) {\n    const targetElement = target ? target : (ev.currentTarget as HTMLElement);\n    const { subMenuHoverDelay: timeoutDuration = NavigationIdleDelay } = this.props;\n\n    if (item.key === this.state.expandedMenuItemKey) {\n      return;\n    }\n\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n\n    // If the menu is not expanded we can update focus without any delay\n    if (this.state.expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    }\n\n    // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      this._enterTimerId = this._async.setTimeout(() => {\n        targetElement.focus();\n        this.setState({\n          expandedByMouseClick: true\n        });\n        this._onItemSubMenuExpand(item, targetElement);\n        this._enterTimerId = undefined;\n      }, timeoutDuration);\n    } else {\n      this._enterTimerId = this._async.setTimeout(() => {\n        this._onSubMenuDismiss(ev);\n        targetElement.focus();\n        this._enterTimerId = undefined;\n      }, timeoutDuration);\n    }\n  }\n\n  private _onItemMouseDown = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>): void => {\n    if (item.onMouseDown) {\n      item.onMouseDown(item, ev);\n    }\n  };\n\n  private _onItemClick = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n    this._onItemClickBase(item, ev, ev.currentTarget as HTMLElement);\n  };\n\n  private _onItemClickBase = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    target: HTMLElement\n  ): void => {\n    const items = getSubmenuItems(item);\n\n    // Cancel a async menu item hover timeout action from being taken and instead\n    // just trigger the click event instead.\n    this._cancelSubMenuTimer();\n\n    if (!hasSubmenu(item) && (!items || !items.length)) {\n      // This is an item without a menu. Click it.\n      this._executeItemClick(item, ev);\n    } else {\n      if (item.key !== this.state.expandedMenuItemKey) {\n        // This has a collapsed sub menu. Expand it.\n        this.setState({\n          // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n          // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n          // between a real click event and a keypress event (detail should be the number of mouse clicks).\n          // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n          // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n          // and \"\" for pressing \"Enter\" with Narrator on.\n          expandedByMouseClick: ev.nativeEvent.detail !== 0 || (ev.nativeEvent as PointerEvent).pointerType === 'mouse'\n        });\n        this._onItemSubMenuExpand(item, target);\n      }\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  private _onAnchorClick = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>) => {\n    this._executeItemClick(item, ev);\n    ev.stopPropagation();\n  };\n\n  private _executeItemClick = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n    if (item.disabled || item.isDisabled) {\n      return;\n    }\n\n    let dismiss = false;\n    if (item.onClick) {\n      dismiss = !!item.onClick(ev, item);\n    } else if (this.props.onItemClick) {\n      dismiss = !!this.props.onItemClick(ev, item);\n    }\n\n    (dismiss || !ev.defaultPrevented) && this.dismiss(ev, true);\n  };\n\n  private _onItemKeyDown = (item: any, ev: React.KeyboardEvent<HTMLElement>): void => {\n    const openKey = getRTL() ? KeyCodes.left : KeyCodes.right;\n\n    if (\n      !item.disabled &&\n      (ev.which === openKey || ev.which === KeyCodes.enter || (ev.which === KeyCodes.down && (ev.altKey || ev.metaKey)))\n    ) {\n      this.setState({\n        expandedByMouseClick: false\n      });\n      this._onItemSubMenuExpand(item, ev.currentTarget as HTMLElement);\n      ev.preventDefault();\n    }\n  };\n\n  // Cancel a async menu item hover timeout action from being taken and instead\n  // do new upcoming behavior\n  private _cancelSubMenuTimer = () => {\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n  };\n\n  private _onItemSubMenuExpand = (item: IContextualMenuItem, target: HTMLElement): void => {\n    if (this.state.expandedMenuItemKey !== item.key) {\n      if (this.state.expandedMenuItemKey) {\n        this._onSubMenuDismiss();\n      }\n\n      // Focus the target to ensure when we close it, we're focusing on the correct element.\n      target.focus();\n      this.setState({\n        expandedMenuItemKey: item.key,\n        submenuTarget: target\n      });\n    }\n  };\n\n  private _getSubmenuProps() {\n    const { submenuTarget, expandedMenuItemKey } = this.state;\n    const item = this._findItemByKey(expandedMenuItemKey!);\n    let submenuProps: IContextualMenuProps | null = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item)!,\n        target: submenuTarget,\n        onDismiss: this._onSubMenuDismiss,\n        isSubMenu: true,\n        id: this.state.subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer: this.state.expandedByMouseClick,\n        directionalHint: getRTL() ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className: this.props.className,\n        gapSpace: 0,\n        isBeakVisible: false\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n    }\n    return submenuProps;\n  }\n\n  private _findItemByKey(key: string): IContextualMenuItem | undefined {\n    const { items } = this.props;\n    return this._findItemByKeyFromItems(key, items);\n  }\n\n  /**\n   * Returns the item that mathes a given key if any.\n   * @param key - The key of the item to match\n   * @param items - The items to look for the key\n   */\n  private _findItemByKeyFromItems(key: string, items: IContextualMenuItem[]): IContextualMenuItem | undefined {\n    for (const item of items) {\n      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n        const match = this._findItemByKeyFromItems(key, item.sectionProps.items);\n        if (match) {\n          return match;\n        }\n      } else if (item.key && item.key === key) {\n        return item;\n      }\n    }\n  }\n\n  /**\n   * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n   * after the component is unmounted. The _mounted property is added to prevent\n   * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n   * code.\n   */\n  private _onSubMenuDismiss = (ev?: any, dismissAll?: boolean): void => {\n    if (dismissAll) {\n      this.dismiss(ev, dismissAll);\n    } else if (this._mounted) {\n      this.setState({\n        dismissedMenuItemKey: this.state.expandedMenuItemKey,\n        expandedMenuItemKey: undefined,\n        submenuTarget: undefined\n      });\n    }\n  };\n\n  private _setTargetWindowAndElement(target: Target): void {\n    if (target) {\n      if (typeof target === 'string') {\n        const currentDoc: Document = getDocument()!;\n        this._target = currentDoc ? (currentDoc.querySelector(target) as Element) : null;\n        this._targetWindow = getWindow()!;\n      } else if ((target as MouseEvent).stopPropagation) {\n        this._targetWindow = getWindow((target as MouseEvent).toElement as HTMLElement)!;\n        this._target = target as MouseEvent;\n      } else if ((target as IPoint).x !== undefined && (target as IPoint).y !== undefined) {\n        this._targetWindow = getWindow()!;\n        this._target = target as IPoint;\n      } else if ((target as React.RefObject<Element>).current !== undefined) {\n        this._target = (target as React.RefObject<Element>).current;\n        this._targetWindow = getWindow(this._target)!;\n      } else {\n        const targetElement: Element = target as Element;\n        this._targetWindow = getWindow(targetElement)!;\n        this._target = target as Element;\n      }\n    } else {\n      this._targetWindow = getWindow()!;\n    }\n  }\n\n  private _getSubMenuId = (item: IContextualMenuItem): string | undefined => {\n    let { subMenuId } = this.state;\n\n    if (item.subMenuProps && item.subMenuProps.id) {\n      subMenuId = item.subMenuProps.id;\n    }\n\n    return subMenuId;\n  };\n\n  private _onPointerAndTouchEvent = (ev: React.TouchEvent<HTMLElement> | PointerEvent) => {\n    this._cancelSubMenuTimer();\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}