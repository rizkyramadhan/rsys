{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _a;\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar React = require(\"react\");\n\nvar PositioningContainer_styles_1 = require(\"./PositioningContainer.styles\");\n\nvar Layer_1 = require(\"../../../Layer\"); // Utilites/Helpers\n\n\nvar DirectionalHint_1 = require(\"../../../common/DirectionalHint\");\n\nvar Utilities_1 = require(\"../../../Utilities\");\n\nvar positioning_1 = require(\"../../../utilities/positioning\");\n\nvar Styling_1 = require(\"../../../Styling\");\n\nvar OFF_SCREEN_STYLE = {\n  opacity: 0\n}; // In order for some of the max height logic to work\n// properly we need to set the border.\n// The value is abitrary.\n\nvar BORDER_WIDTH = 1;\nvar SLIDE_ANIMATIONS = (_a = {}, _a[positioning_1.RectangleEdge.top] = 'slideUpIn20', _a[positioning_1.RectangleEdge.bottom] = 'slideDownIn20', _a[positioning_1.RectangleEdge.left] = 'slideLeftIn20', _a[positioning_1.RectangleEdge.right] = 'slideRightIn20', _a);\n\nvar PositioningContainer =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(PositioningContainer, _super);\n\n  function PositioningContainer(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * The primary positioned div.\n     */\n\n\n    _this._positionedHost = React.createRef(); // @TODO rename to reflect the name of this class\n\n    _this._contentHost = React.createRef();\n    /**\n     * Deprecated, use `onResize` instead.\n     * @deprecated Use `onResize` instead.\n     */\n\n    _this.dismiss = function (ev) {\n      _this.onResize(ev);\n    };\n\n    _this.onResize = function (ev) {\n      var onDismiss = _this.props.onDismiss;\n\n      if (onDismiss) {\n        onDismiss(ev);\n      } else {\n        _this._updateAsyncPosition();\n      }\n    };\n\n    _this._setInitialFocus = function () {\n      if (_this._contentHost.current && _this.props.setInitialFocus && !_this._didSetInitialFocus && _this.state.positions) {\n        _this._didSetInitialFocus = true;\n        Utilities_1.focusFirstChild(_this._contentHost.current);\n      }\n    };\n\n    _this._onComponentDidMount = function () {\n      // This is added so the positioningContainer will dismiss when the window is scrolled\n      // but not when something inside the positioningContainer is scrolled. The delay seems\n      // to be required to avoid React firing an async focus event in IE from\n      // the target changing focus quickly prior to rendering the positioningContainer.\n      _this._async.setTimeout(function () {\n        _this._events.on(_this._targetWindow, 'scroll', _this._async.throttle(_this._dismissOnScroll, 10), true);\n\n        _this._events.on(_this._targetWindow, 'resize', _this._async.throttle(_this.onResize, 10), true);\n\n        _this._events.on(_this._targetWindow.document.body, 'focus', _this._dismissOnLostFocus, true);\n\n        _this._events.on(_this._targetWindow.document.body, 'click', _this._dismissOnLostFocus, true);\n      }, 0);\n\n      if (_this.props.onLayerMounted) {\n        _this.props.onLayerMounted();\n      }\n\n      _this._updateAsyncPosition();\n\n      _this._setHeightOffsetEveryFrame();\n    };\n\n    _this._didSetInitialFocus = false;\n    _this.state = {\n      positions: undefined,\n      heightOffset: 0\n    };\n    _this._positionAttempts = 0;\n    return _this;\n  } // tslint:disable-next-line function-name\n\n\n  PositioningContainer.prototype.UNSAFE_componentWillMount = function () {\n    this._setTargetWindowAndElement(this._getTarget());\n  };\n\n  PositioningContainer.prototype.componentDidMount = function () {\n    this._onComponentDidMount();\n  };\n\n  PositioningContainer.prototype.componentDidUpdate = function () {\n    this._setInitialFocus();\n\n    this._updateAsyncPosition();\n  }; // tslint:disable-next-line function-name\n\n\n  PositioningContainer.prototype.UNSAFE_componentWillUpdate = function (newProps) {\n    // If the target element changed, find the new one. If we are tracking\n    // target with class name, always find element because we do not know if\n    // fabric has rendered a new element and disposed the old element.\n    var newTarget = this._getTarget(newProps);\n\n    var oldTarget = this._getTarget();\n\n    if (newTarget !== oldTarget || typeof newTarget === 'string' || newTarget instanceof String) {\n      this._maxHeight = undefined;\n\n      this._setTargetWindowAndElement(newTarget);\n    }\n\n    if (newProps.offsetFromTarget !== this.props.offsetFromTarget) {\n      this._maxHeight = undefined;\n    }\n\n    if (newProps.finalHeight !== this.props.finalHeight) {\n      this._setHeightOffsetEveryFrame();\n    }\n  };\n\n  PositioningContainer.prototype.render = function () {\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!this._targetWindow) {\n      return null;\n    }\n\n    var _a = this.props,\n        className = _a.className,\n        positioningContainerWidth = _a.positioningContainerWidth,\n        positioningContainerMaxHeight = _a.positioningContainerMaxHeight,\n        children = _a.children;\n    var positions = this.state.positions;\n    var styles = PositioningContainer_styles_1.getClassNames();\n    var directionalClassName = positions && positions.targetEdge ? Styling_1.AnimationClassNames[SLIDE_ANIMATIONS[positions.targetEdge]] : '';\n    var getContentMaxHeight = this._getMaxHeight() + this.state.heightOffset;\n    var contentMaxHeight = positioningContainerMaxHeight && positioningContainerMaxHeight > getContentMaxHeight ? getContentMaxHeight : positioningContainerMaxHeight;\n    var content = React.createElement(\"div\", {\n      ref: this._positionedHost,\n      className: Utilities_1.css('ms-PositioningContainer', styles.container)\n    }, React.createElement(\"div\", {\n      className: Styling_1.mergeStyles('ms-PositioningContainer-layerHost', styles.root, className, directionalClassName, !!positioningContainerWidth && {\n        width: positioningContainerWidth\n      }),\n      // tslint:disable-next-line:jsx-ban-props\n      style: positions ? positions.elementPosition : OFF_SCREEN_STYLE,\n      tabIndex: -1,\n      // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n      ref: this._contentHost\n    }, children, // @TODO apply to the content container\n    contentMaxHeight));\n    return this.props.doNotLayer ? content : React.createElement(Layer_1.Layer, null, content);\n  };\n\n  PositioningContainer.prototype._dismissOnScroll = function (ev) {\n    var preventDismissOnScroll = this.props.preventDismissOnScroll;\n\n    if (this.state.positions && !preventDismissOnScroll) {\n      this._dismissOnLostFocus(ev);\n    }\n  };\n\n  PositioningContainer.prototype._dismissOnLostFocus = function (ev) {\n    var target = ev.target;\n    var clickedOutsideCallout = this._positionedHost.current && !Utilities_1.elementContains(this._positionedHost.current, target);\n\n    if (!this._target && clickedOutsideCallout || ev.target !== this._targetWindow && clickedOutsideCallout && (this._target.stopPropagation || !this._target || target !== this._target && !Utilities_1.elementContains(this._target, target))) {\n      this.onResize(ev);\n    }\n  };\n\n  PositioningContainer.prototype._updateAsyncPosition = function () {\n    var _this = this;\n\n    this._async.requestAnimationFrame(function () {\n      return _this._updatePosition();\n    });\n  };\n\n  PositioningContainer.prototype._updatePosition = function () {\n    var positions = this.state.positions;\n    var _a = this.props,\n        offsetFromTarget = _a.offsetFromTarget,\n        onPositioned = _a.onPositioned;\n    var hostElement = this._positionedHost.current;\n    var positioningContainerElement = this._contentHost.current;\n\n    if (hostElement && positioningContainerElement) {\n      var currentProps = void 0;\n      currentProps = Utilities_1.assign(currentProps, this.props);\n      currentProps.bounds = this._getBounds();\n      currentProps.target = this._target;\n\n      if (document.body.contains(currentProps.target)) {\n        currentProps.gapSpace = offsetFromTarget;\n        var newPositions_1 = positioning_1.positionElement(currentProps, hostElement, positioningContainerElement); // Set the new position only when the positions are not exists or one of the new positioningContainer positions are different.\n        // The position should not change if the position is within 2 decimal places.\n\n        if (!positions && newPositions_1 || positions && newPositions_1 && !this._arePositionsEqual(positions, newPositions_1) && this._positionAttempts < 5) {\n          // We should not reposition the positioningContainer more than a few times, if it is then the content is likely resizing\n          // and we should stop trying to reposition to prevent a stack overflow.\n          this._positionAttempts++;\n          this.setState({\n            positions: newPositions_1\n          }, function () {\n            if (onPositioned) {\n              onPositioned(newPositions_1);\n            }\n          });\n        } else {\n          this._positionAttempts = 0;\n\n          if (onPositioned) {\n            onPositioned(newPositions_1);\n          }\n        }\n      } else if (positions !== undefined) {\n        this.setState({\n          positions: undefined\n        });\n      }\n    }\n  };\n\n  PositioningContainer.prototype._getBounds = function () {\n    if (!this._positioningBounds) {\n      var currentBounds = this.props.bounds;\n\n      if (!currentBounds) {\n        currentBounds = {\n          top: 0 + this.props.minPagePadding,\n          left: 0 + this.props.minPagePadding,\n          right: this._targetWindow.innerWidth - this.props.minPagePadding,\n          bottom: this._targetWindow.innerHeight - this.props.minPagePadding,\n          width: this._targetWindow.innerWidth - this.props.minPagePadding * 2,\n          height: this._targetWindow.innerHeight - this.props.minPagePadding * 2\n        };\n      }\n\n      this._positioningBounds = currentBounds;\n    }\n\n    return this._positioningBounds;\n  };\n  /**\n   * Return the maximum height the container can grow to\n   * without going out of the specified bounds\n   */\n\n\n  PositioningContainer.prototype._getMaxHeight = function () {\n    var _a = this.props,\n        directionalHintFixed = _a.directionalHintFixed,\n        offsetFromTarget = _a.offsetFromTarget,\n        directionalHint = _a.directionalHint;\n\n    if (!this._maxHeight) {\n      if (directionalHintFixed && this._target) {\n        var gapSpace = offsetFromTarget ? offsetFromTarget : 0;\n        this._maxHeight = positioning_1.getMaxHeight(this._target, directionalHint, gapSpace, this._getBounds());\n      } else {\n        this._maxHeight = this._getBounds().height - BORDER_WIDTH * 2;\n      }\n    }\n\n    return this._maxHeight;\n  };\n\n  PositioningContainer.prototype._arePositionsEqual = function (positions, newPosition) {\n    return this._comparePositions(positions.elementPosition, newPosition.elementPosition);\n  };\n\n  PositioningContainer.prototype._comparePositions = function (oldPositions, newPositions) {\n    for (var key in newPositions) {\n      // This needs to be checked here and below because there is a linting error if for in does not immediately have an if statement\n      if (newPositions.hasOwnProperty(key)) {\n        var oldPositionEdge = oldPositions[key];\n        var newPositionEdge = newPositions[key];\n\n        if (oldPositionEdge && newPositionEdge) {\n          if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  PositioningContainer.prototype._setTargetWindowAndElement = function (target) {\n    if (target) {\n      if (typeof target === 'string') {\n        var currentDoc = Utilities_1.getDocument();\n        this._target = currentDoc ? currentDoc.querySelector(target) : null;\n        this._targetWindow = Utilities_1.getWindow();\n      } else if (target.stopPropagation) {\n        this._targetWindow = Utilities_1.getWindow(target.toElement);\n        this._target = target;\n      } else if (target.x !== undefined && target.y !== undefined) {\n        this._targetWindow = Utilities_1.getWindow();\n        this._target = target;\n      } else {\n        var targetElement = target;\n        this._targetWindow = Utilities_1.getWindow(targetElement);\n        this._target = target;\n      }\n    } else {\n      this._targetWindow = Utilities_1.getWindow();\n    }\n  };\n  /**\n   * Animates the height if finalHeight was given.\n   */\n\n\n  PositioningContainer.prototype._setHeightOffsetEveryFrame = function () {\n    var _this = this;\n\n    if (this._contentHost && this.props.finalHeight) {\n      this._setHeightOffsetTimer = this._async.requestAnimationFrame(function () {\n        if (!_this._contentHost.current) {\n          return;\n        }\n\n        var positioningContainerMainElem = _this._contentHost.current.lastChild;\n        var cardScrollHeight = positioningContainerMainElem.scrollHeight;\n        var cardCurrHeight = positioningContainerMainElem.offsetHeight;\n        var scrollDiff = cardScrollHeight - cardCurrHeight;\n\n        _this.setState({\n          heightOffset: _this.state.heightOffset + scrollDiff\n        });\n\n        if (positioningContainerMainElem.offsetHeight < _this.props.finalHeight) {\n          _this._setHeightOffsetEveryFrame();\n        } else {\n          _this._async.cancelAnimationFrame(_this._setHeightOffsetTimer);\n        }\n      });\n    }\n  };\n\n  PositioningContainer.prototype._getTarget = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    var target = props.target;\n    return target;\n  };\n\n  PositioningContainer.defaultProps = {\n    preventDismissOnScroll: false,\n    offsetFromTarget: 0,\n    minPagePadding: 8,\n    directionalHint: DirectionalHint_1.DirectionalHint.bottomAutoEdge\n  };\n  return PositioningContainer;\n}(Utilities_1.BaseComponent);\n\nexports.PositioningContainer = PositioningContainer;","map":{"version":3,"sources":["components/Coachmark/PositioningContainer/PositioningContainer.tsx"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAA,KAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AAEA,IAAA,6BAAA,GAAA,OAAA,CAAA,+BAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,gBAAA,CAAA,C,CAEA;;;AACA,IAAA,iBAAA,GAAA,OAAA,CAAA,iCAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAYA,IAAA,aAAA,GAAA,OAAA,CAAA,gCAAA,CAAA;;AAEA,IAAA,SAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AAEA,IAAM,gBAAgB,GAAG;AAAE,EAAA,OAAO,EAAE;AAAX,CAAzB,C,CAEA;AACA;AACA;;AACA,IAAM,YAAY,GAAG,CAArB;AACA,IAAM,gBAAgB,IAAA,EAAA,GAAA,EAAA,EACpB,EAAA,CAAC,aAAA,CAAA,aAAA,CAAc,GAAf,CAAA,GAAqB,aADD,EAEpB,EAAA,CAAC,aAAA,CAAA,aAAA,CAAc,MAAf,CAAA,GAAwB,eAFJ,EAGpB,EAAA,CAAC,aAAA,CAAA,aAAA,CAAc,IAAf,CAAA,GAAsB,eAHF,EAIpB,EAAA,CAAC,aAAA,CAAA,aAAA,CAAc,KAAf,CAAA,GAAuB,gBAJH,EAKrB,EALqB,CAAtB;;AAoBA,IAAA,oBAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA0C,EAAA,OAAA,CAAA,SAAA,CAAA,oBAAA,EAAA,MAAA;;AAwCxC,WAAA,oBAAA,CAAY,KAAZ,EAA6C;AAA7C,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAN,KAAY,IADd;AA7BA;;;;;AAGQ,IAAA,KAAA,CAAA,eAAA,GAAkB,KAAK,CAAC,SAAN,EAAlB,CA0BqC,CAxB7C;;AACQ,IAAA,KAAA,CAAA,YAAA,GAAe,KAAK,CAAC,SAAN,EAAf;AAmHR;;;;;AAIO,IAAA,KAAA,CAAA,OAAA,GAAU,UAAC,EAAD,EAA8E;AAC7F,MAAA,KAAI,CAAC,QAAL,CAAc,EAAd;AACD,KAFM;;AAIA,IAAA,KAAA,CAAA,QAAA,GAAW,UAAC,EAAD,EAA8E;AACtF,UAAA,SAAA,GAAA,KAAA,CAAA,KAAA,CAAA,SAAA;;AACR,UAAI,SAAJ,EAAe;AACb,QAAA,SAAS,CAAC,EAAD,CAAT;AACD,OAFD,MAEO;AACL,QAAA,KAAI,CAAC,oBAAL;AACD;AACF,KAPM;;AA+BG,IAAA,KAAA,CAAA,gBAAA,GAAmB,YAAA;AAC3B,UAAI,KAAI,CAAC,YAAL,CAAkB,OAAlB,IAA6B,KAAI,CAAC,KAAL,CAAW,eAAxC,IAA2D,CAAC,KAAI,CAAC,mBAAjE,IAAwF,KAAI,CAAC,KAAL,CAAW,SAAvG,EAAkH;AAChH,QAAA,KAAI,CAAC,mBAAL,GAA2B,IAA3B;AACA,QAAA,WAAA,CAAA,eAAA,CAAgB,KAAI,CAAC,YAAL,CAAkB,OAAlC;AACD;AACF,KALS;;AAOA,IAAA,KAAA,CAAA,oBAAA,GAAuB,YAAA;AAC/B;AACA;AACA;AACA;AACA,MAAA,KAAI,CAAC,MAAL,CAAY,UAAZ,CAAuB,YAAA;AACrB,QAAA,KAAI,CAAC,OAAL,CAAa,EAAb,CAAgB,KAAI,CAAC,aAArB,EAAoC,QAApC,EAA8C,KAAI,CAAC,MAAL,CAAY,QAAZ,CAAqB,KAAI,CAAC,gBAA1B,EAA4C,EAA5C,CAA9C,EAA+F,IAA/F;;AACA,QAAA,KAAI,CAAC,OAAL,CAAa,EAAb,CAAgB,KAAI,CAAC,aAArB,EAAoC,QAApC,EAA8C,KAAI,CAAC,MAAL,CAAY,QAAZ,CAAqB,KAAI,CAAC,QAA1B,EAAoC,EAApC,CAA9C,EAAuF,IAAvF;;AACA,QAAA,KAAI,CAAC,OAAL,CAAa,EAAb,CAAgB,KAAI,CAAC,aAAL,CAAmB,QAAnB,CAA4B,IAA5C,EAAkD,OAAlD,EAA2D,KAAI,CAAC,mBAAhE,EAAqF,IAArF;;AACA,QAAA,KAAI,CAAC,OAAL,CAAa,EAAb,CAAgB,KAAI,CAAC,aAAL,CAAmB,QAAnB,CAA4B,IAA5C,EAAkD,OAAlD,EAA2D,KAAI,CAAC,mBAAhE,EAAqF,IAArF;AACD,OALD,EAKG,CALH;;AAOA,UAAI,KAAI,CAAC,KAAL,CAAW,cAAf,EAA+B;AAC7B,QAAA,KAAI,CAAC,KAAL,CAAW,cAAX;AACD;;AAED,MAAA,KAAI,CAAC,oBAAL;;AACA,MAAA,KAAI,CAAC,0BAAL;AACD,KAlBS;;AAxIR,IAAA,KAAI,CAAC,mBAAL,GAA2B,KAA3B;AACA,IAAA,KAAI,CAAC,KAAL,GAAa;AACX,MAAA,SAAS,EAAE,SADA;AAEX,MAAA,YAAY,EAAE;AAFH,KAAb;AAIA,IAAA,KAAI,CAAC,iBAAL,GAAyB,CAAzB;;AACD,GAhDH,CAkDE;;;AACO,EAAA,oBAAA,CAAA,SAAA,CAAA,yBAAA,GAAP,YAAA;AACE,SAAK,0BAAL,CAAgC,KAAK,UAAL,EAAhC;AACD,GAFM;;AAIA,EAAA,oBAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,YAAA;AACE,SAAK,oBAAL;AACD,GAFM;;AAIA,EAAA,oBAAA,CAAA,SAAA,CAAA,kBAAA,GAAP,YAAA;AACE,SAAK,gBAAL;;AACA,SAAK,oBAAL;AACD,GAHM,CA3DT,CAgEE;;;AACO,EAAA,oBAAA,CAAA,SAAA,CAAA,0BAAA,GAAP,UAAkC,QAAlC,EAAsE;AACpE;AACA;AACA;AACA,QAAM,SAAS,GAAG,KAAK,UAAL,CAAgB,QAAhB,CAAlB;;AACA,QAAM,SAAS,GAAG,KAAK,UAAL,EAAlB;;AACA,QAAI,SAAS,KAAK,SAAd,IAA2B,OAAO,SAAP,KAAqB,QAAhD,IAA4D,SAAS,YAAY,MAArF,EAA6F;AAC3F,WAAK,UAAL,GAAkB,SAAlB;;AACA,WAAK,0BAAL,CAAgC,SAAhC;AACD;;AAED,QAAI,QAAQ,CAAC,gBAAT,KAA8B,KAAK,KAAL,CAAW,gBAA7C,EAA+D;AAC7D,WAAK,UAAL,GAAkB,SAAlB;AACD;;AAED,QAAI,QAAQ,CAAC,WAAT,KAAyB,KAAK,KAAL,CAAW,WAAxC,EAAqD;AACnD,WAAK,0BAAL;AACD;AACF,GAlBM;;AAoBA,EAAA,oBAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACE;AACA,QAAI,CAAC,KAAK,aAAV,EAAyB;AACvB,aAAO,IAAP;AACD;;AAEK,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,SAAA,GAAA,EAAA,CAAA,SAAF;AAAA,QAAa,yBAAA,GAAA,EAAA,CAAA,yBAAb;AAAA,QAAwC,6BAAA,GAAA,EAAA,CAAA,6BAAxC;AAAA,QAAuE,QAAA,GAAA,EAAA,CAAA,QAAvE;AACE,QAAA,SAAA,GAAA,KAAA,KAAA,CAAA,SAAA;AAER,QAAM,MAAM,GAAG,6BAAA,CAAA,aAAA,EAAf;AAEA,QAAM,oBAAoB,GACxB,SAAS,IAAI,SAAS,CAAC,UAAvB,GAAqC,SAAA,CAAA,mBAAA,CAA4B,gBAAgB,CAAC,SAAS,CAAC,UAAX,CAA5C,CAArC,GAA2G,EAD7G;AAGA,QAAM,mBAAmB,GAAW,KAAK,aAAL,KAAuB,KAAK,KAAL,CAAW,YAAtE;AACA,QAAM,gBAAgB,GACpB,6BAA8B,IAAI,6BAA8B,GAAG,mBAAnE,GACI,mBADJ,GAEI,6BAHN;AAIA,QAAM,OAAO,GACX,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAK,MAAA,GAAG,EAAE,KAAK,eAAf;AAAgC,MAAA,SAAS,EAAE,WAAA,CAAA,GAAA,CAAI,yBAAJ,EAA+B,MAAM,CAAC,SAAtC;AAA3C,KAAA,EACE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AACE,MAAA,SAAS,EAAE,SAAA,CAAA,WAAA,CACT,mCADS,EAET,MAAM,CAAC,IAFE,EAGT,SAHS,EAIT,oBAJS,EAKT,CAAC,CAAC,yBAAF,IAA+B;AAAE,QAAA,KAAK,EAAE;AAAT,OALtB,CADb;AAQE;AACA,MAAA,KAAK,EAAE,SAAS,GAAG,SAAS,CAAC,eAAb,GAA+B,gBATjD;AAUE,MAAA,QAAQ,EAAE,CAAC,CAVb;AAWE;AACA,MAAA,GAAG,EAAE,KAAK;AAZZ,KAAA,EAcG,QAdH,EAgBI;AACA,IAAA,gBAjBJ,CADF,CADF;AAyBA,WAAO,KAAK,KAAL,CAAW,UAAX,GAAwB,OAAxB,GAAkC,KAAA,CAAA,aAAA,CAAC,OAAA,CAAA,KAAD,EAAM,IAAN,EAAQ,OAAR,CAAzC;AACD,GA7CM;;AAgEG,EAAA,oBAAA,CAAA,SAAA,CAAA,gBAAA,GAAV,UAA2B,EAA3B,EAAoC;AAC1B,QAAA,sBAAA,GAAA,KAAA,KAAA,CAAA,sBAAA;;AACR,QAAI,KAAK,KAAL,CAAW,SAAX,IAAwB,CAAC,sBAA7B,EAAqD;AACnD,WAAK,mBAAL,CAAyB,EAAzB;AACD;AACF,GALS;;AAOA,EAAA,oBAAA,CAAA,SAAA,CAAA,mBAAA,GAAV,UAA8B,EAA9B,EAAuC;AACrC,QAAM,MAAM,GAAG,EAAE,CAAC,MAAlB;AACA,QAAM,qBAAqB,GAAG,KAAK,eAAL,CAAqB,OAArB,IAAgC,CAAC,WAAA,CAAA,eAAA,CAAgB,KAAK,eAAL,CAAqB,OAArC,EAA8C,MAA9C,CAA/D;;AAEA,QACG,CAAC,KAAK,OAAN,IAAiB,qBAAlB,IACC,EAAE,CAAC,MAAH,KAAc,KAAK,aAAnB,IACC,qBADD,KAEG,KAAK,OAAL,CAA4B,eAA5B,IACC,CAAC,KAAK,OAAN,IAAkB,MAAM,KAAK,KAAK,OAAhB,IAA2B,CAAC,WAAA,CAAA,eAAA,CAAgB,KAAK,OAArB,EAA6C,MAA7C,CAHlD,CAFH,EAME;AACA,WAAK,QAAL,CAAc,EAAd;AACD;AACF,GAbS;;AA0CF,EAAA,oBAAA,CAAA,SAAA,CAAA,oBAAA,GAAR,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACE,SAAK,MAAL,CAAY,qBAAZ,CAAkC,YAAA;AAAM,aAAA,KAAI,CAAJ,eAAA,EAAA;AAAsB,KAA9D;AACD,GAFO;;AAIA,EAAA,oBAAA,CAAA,SAAA,CAAA,eAAA,GAAR,YAAA;AACU,QAAA,SAAA,GAAA,KAAA,KAAA,CAAA,SAAA;AACF,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,gBAAA,GAAA,EAAA,CAAA,gBAAF;AAAA,QAAoB,YAAA,GAAA,EAAA,CAAA,YAApB;AAEN,QAAM,WAAW,GAAG,KAAK,eAAL,CAAqB,OAAzC;AACA,QAAM,2BAA2B,GAAG,KAAK,YAAL,CAAkB,OAAtD;;AAEA,QAAI,WAAW,IAAI,2BAAnB,EAAgD;AAC9C,UAAI,YAAY,GAAA,KAAA,CAAhB;AACA,MAAA,YAAY,GAAG,WAAA,CAAA,MAAA,CAAO,YAAP,EAAqB,KAAK,KAA1B,CAAf;AACA,MAAA,YAAa,CAAC,MAAd,GAAuB,KAAK,UAAL,EAAvB;AACA,MAAA,YAAa,CAAC,MAAd,GAAuB,KAAK,OAA5B;;AACA,UAAI,QAAQ,CAAC,IAAT,CAAc,QAAd,CAAuB,YAAa,CAAC,MAArC,CAAJ,EAA0D;AACxD,QAAA,YAAa,CAAC,QAAd,GAAyB,gBAAzB;AACA,YAAM,cAAY,GAAoB,aAAA,CAAA,eAAA,CAAgB,YAAhB,EAA+B,WAA/B,EAA4C,2BAA5C,CAAtC,CAFwD,CAGxD;AACA;;AACA,YACG,CAAC,SAAD,IAAc,cAAf,IACC,SAAS,IAAI,cAAb,IAA6B,CAAC,KAAK,kBAAL,CAAwB,SAAxB,EAAmC,cAAnC,CAA9B,IAAkF,KAAK,iBAAL,GAAyB,CAF9G,EAGE;AACA;AACA;AACA,eAAK,iBAAL;AACA,eAAK,QAAL,CACE;AACE,YAAA,SAAS,EAAE;AADb,WADF,EAIE,YAAA;AACE,gBAAI,YAAJ,EAAkB;AAChB,cAAA,YAAY,CAAC,cAAD,CAAZ;AACD;AACF,WARH;AAUD,SAjBD,MAiBO;AACL,eAAK,iBAAL,GAAyB,CAAzB;;AACA,cAAI,YAAJ,EAAkB;AAChB,YAAA,YAAY,CAAC,cAAD,CAAZ;AACD;AACF;AACF,OA5BD,MA4BO,IAAI,SAAS,KAAK,SAAlB,EAA6B;AAClC,aAAK,QAAL,CAAc;AACZ,UAAA,SAAS,EAAE;AADC,SAAd;AAGD;AACF;AACF,GA9CO;;AAgDA,EAAA,oBAAA,CAAA,SAAA,CAAA,UAAA,GAAR,YAAA;AACE,QAAI,CAAC,KAAK,kBAAV,EAA8B;AAC5B,UAAI,aAAa,GAAG,KAAK,KAAL,CAAW,MAA/B;;AAEA,UAAI,CAAC,aAAL,EAAoB;AAClB,QAAA,aAAa,GAAG;AACd,UAAA,GAAG,EAAE,IAAI,KAAK,KAAL,CAAW,cADN;AAEd,UAAA,IAAI,EAAE,IAAI,KAAK,KAAL,CAAW,cAFP;AAGd,UAAA,KAAK,EAAE,KAAK,aAAL,CAAmB,UAAnB,GAAgC,KAAK,KAAL,CAAW,cAHpC;AAId,UAAA,MAAM,EAAE,KAAK,aAAL,CAAmB,WAAnB,GAAiC,KAAK,KAAL,CAAW,cAJtC;AAKd,UAAA,KAAK,EAAE,KAAK,aAAL,CAAmB,UAAnB,GAAgC,KAAK,KAAL,CAAW,cAAX,GAA6B,CALtD;AAMd,UAAA,MAAM,EAAE,KAAK,aAAL,CAAmB,WAAnB,GAAiC,KAAK,KAAL,CAAW,cAAX,GAA6B;AANxD,SAAhB;AAQD;;AACD,WAAK,kBAAL,GAA0B,aAA1B;AACD;;AACD,WAAO,KAAK,kBAAZ;AACD,GAjBO;AAmBR;;;;;;AAIQ,EAAA,oBAAA,CAAA,SAAA,CAAA,aAAA,GAAR,YAAA;AACQ,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,oBAAA,GAAA,EAAA,CAAA,oBAAF;AAAA,QAAwB,gBAAA,GAAA,EAAA,CAAA,gBAAxB;AAAA,QAA0C,eAAA,GAAA,EAAA,CAAA,eAA1C;;AAEN,QAAI,CAAC,KAAK,UAAV,EAAsB;AACpB,UAAI,oBAAoB,IAAI,KAAK,OAAjC,EAA0C;AACxC,YAAM,QAAQ,GAAG,gBAAgB,GAAG,gBAAH,GAAsB,CAAvD;AACA,aAAK,UAAL,GAAkB,aAAA,CAAA,YAAA,CAAa,KAAK,OAAlB,EAA2B,eAA3B,EAA6C,QAA7C,EAAuD,KAAK,UAAL,EAAvD,CAAlB;AACD,OAHD,MAGO;AACL,aAAK,UAAL,GAAkB,KAAK,UAAL,GAAkB,MAAlB,GAA4B,YAAY,GAAG,CAA7D;AACD;AACF;;AACD,WAAO,KAAK,UAAZ;AACD,GAZO;;AAcA,EAAA,oBAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,SAA3B,EAAuD,WAAvD,EAAmF;AACjF,WAAO,KAAK,iBAAL,CAAuB,SAAS,CAAC,eAAjC,EAAkD,WAAW,CAAC,eAA9D,CAAP;AACD,GAFO;;AAIA,EAAA,oBAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UAA0B,YAA1B,EAAmD,YAAnD,EAA0E;AACxE,SAAK,IAAM,GAAX,IAAkB,YAAlB,EAAgC;AAC9B;AACA,UAAI,YAAY,CAAC,cAAb,CAA4B,GAA5B,CAAJ,EAAsC;AACpC,YAAM,eAAe,GAAG,YAAY,CAAC,GAAD,CAApC;AACA,YAAM,eAAe,GAAG,YAAY,CAAC,GAAD,CAApC;;AAEA,YAAI,eAAe,IAAI,eAAvB,EAAwC;AACtC,cAAI,eAAe,CAAC,OAAhB,CAAwB,CAAxB,MAA+B,eAAe,CAAC,OAAhB,CAAwB,CAAxB,CAAnC,EAA+D;AAC7D,mBAAO,KAAP;AACD;AACF;AACF;AACF;;AACD,WAAO,IAAP;AACD,GAfO;;AAiBA,EAAA,oBAAA,CAAA,SAAA,CAAA,0BAAA,GAAR,UAAmC,MAAnC,EAA4F;AAC1F,QAAI,MAAJ,EAAY;AACV,UAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,YAAM,UAAU,GAAa,WAAA,CAAA,WAAA,EAA7B;AACA,aAAK,OAAL,GAAe,UAAU,GAAI,UAAU,CAAC,aAAX,CAAyB,MAAzB,CAAJ,GAAuD,IAAhF;AACA,aAAK,aAAL,GAAqB,WAAA,CAAA,SAAA,EAArB;AACD,OAJD,MAIO,IAAK,MAAqB,CAAC,eAA3B,EAA4C;AACjD,aAAK,aAAL,GAAqB,WAAA,CAAA,SAAA,CAAW,MAAqB,CAAC,SAAjC,CAArB;AACA,aAAK,OAAL,GAAe,MAAf;AACD,OAHM,MAGA,IAAK,MAAiB,CAAC,CAAlB,KAAwB,SAAxB,IAAsC,MAAiB,CAAC,CAAlB,KAAwB,SAAnE,EAA8E;AACnF,aAAK,aAAL,GAAqB,WAAA,CAAA,SAAA,EAArB;AACA,aAAK,OAAL,GAAe,MAAf;AACD,OAHM,MAGA;AACL,YAAM,aAAa,GAAgB,MAAnC;AACA,aAAK,aAAL,GAAqB,WAAA,CAAA,SAAA,CAAU,aAAV,CAArB;AACA,aAAK,OAAL,GAAe,MAAf;AACD;AACF,KAhBD,MAgBO;AACL,WAAK,aAAL,GAAqB,WAAA,CAAA,SAAA,EAArB;AACD;AACF,GApBO;AAsBR;;;;;AAGQ,EAAA,oBAAA,CAAA,SAAA,CAAA,0BAAA,GAAR,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA;;AACE,QAAI,KAAK,YAAL,IAAqB,KAAK,KAAL,CAAW,WAApC,EAAiD;AAC/C,WAAK,qBAAL,GAA6B,KAAK,MAAL,CAAY,qBAAZ,CAAkC,YAAA;AAC7D,YAAI,CAAC,KAAI,CAAC,YAAL,CAAkB,OAAvB,EAAgC;AAC9B;AACD;;AAED,YAAM,4BAA4B,GAAG,KAAI,CAAC,YAAL,CAAkB,OAAlB,CAA0B,SAA/D;AACA,YAAM,gBAAgB,GAAW,4BAA4B,CAAC,YAA9D;AACA,YAAM,cAAc,GAAW,4BAA4B,CAAC,YAA5D;AACA,YAAM,UAAU,GAAW,gBAAgB,GAAG,cAA9C;;AAEA,QAAA,KAAI,CAAC,QAAL,CAAc;AACZ,UAAA,YAAY,EAAE,KAAI,CAAC,KAAL,CAAW,YAAX,GAA2B;AAD7B,SAAd;;AAIA,YAAI,4BAA4B,CAAC,YAA7B,GAA4C,KAAI,CAAC,KAAL,CAAW,WAA3D,EAAyE;AACvE,UAAA,KAAI,CAAC,0BAAL;AACD,SAFD,MAEO;AACL,UAAA,KAAI,CAAC,MAAL,CAAY,oBAAZ,CAAiC,KAAI,CAAC,qBAAtC;AACD;AACF,OAnB4B,CAA7B;AAoBD;AACF,GAvBO;;AAyBA,EAAA,oBAAA,CAAA,SAAA,CAAA,UAAA,GAAR,UAAmB,KAAnB,EAAiE;AAA9C,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAoC,KAAK,KAAzC;AAA8C;;AACvD,QAAA,MAAA,GAAA,KAAA,CAAA,MAAA;AACR,WAAO,MAAP;AACD,GAHO;;AApWM,EAAA,oBAAA,CAAA,YAAA,GAA2C;AACvD,IAAA,sBAAsB,EAAE,KAD+B;AAEvD,IAAA,gBAAgB,EAAE,CAFqC;AAGvD,IAAA,cAAc,EAAE,CAHuC;AAIvD,IAAA,eAAe,EAAE,iBAAA,CAAA,eAAA,CAAgB;AAJsB,GAA3C;AAwWhB,SAAA,oBAAA;AAAC,CA1WD,CAA0C,WAAA,CAAA,aAA1C,CAAA;;AAAa,OAAA,CAAA,oBAAA,GAAA,oBAAA","sourcesContent":["import * as React from 'react';\nimport { IPositioningContainerProps } from './PositioningContainer.types';\nimport { getClassNames } from './PositioningContainer.styles';\nimport { Layer } from '../../../Layer';\n\n// Utilites/Helpers\nimport { DirectionalHint } from '../../../common/DirectionalHint';\nimport {\n  BaseComponent,\n  IPoint,\n  IRectangle,\n  assign,\n  css,\n  elementContains,\n  focusFirstChild,\n  getWindow,\n  getDocument\n} from '../../../Utilities';\n\nimport { getMaxHeight, positionElement, IPositionedData, IPositionProps, IPosition, RectangleEdge } from '../../../utilities/positioning';\n\nimport { AnimationClassNames, mergeStyles } from '../../../Styling';\n\nconst OFF_SCREEN_STYLE = { opacity: 0 };\n\n// In order for some of the max height logic to work\n// properly we need to set the border.\n// The value is abitrary.\nconst BORDER_WIDTH = 1;\nconst SLIDE_ANIMATIONS: { [key: number]: string } = {\n  [RectangleEdge.top]: 'slideUpIn20',\n  [RectangleEdge.bottom]: 'slideDownIn20',\n  [RectangleEdge.left]: 'slideLeftIn20',\n  [RectangleEdge.right]: 'slideRightIn20'\n};\n\nexport interface IPositioningContainerState {\n  /**\n   * Current set of calcualted positions for the outermost parent container.\n   */\n  positions?: IPositionedData;\n\n  /**\n   * Tracks the current height offset and updates during\n   * the height animation when props.finalHeight is specified.\n   */\n  heightOffset?: number;\n}\n\nexport class PositioningContainer extends BaseComponent<IPositioningContainerProps, IPositioningContainerState>\n  implements PositioningContainer {\n  public static defaultProps: IPositioningContainerProps = {\n    preventDismissOnScroll: false,\n    offsetFromTarget: 0,\n    minPagePadding: 8,\n    directionalHint: DirectionalHint.bottomAutoEdge\n  };\n\n  private _didSetInitialFocus: boolean;\n\n  /**\n   * The primary positioned div.\n   */\n  private _positionedHost = React.createRef<HTMLDivElement>();\n\n  // @TODO rename to reflect the name of this class\n  private _contentHost = React.createRef<HTMLDivElement>();\n\n  /**\n   * Stores an instance of Window, used to check\n   * for server side rendering and if focus was lost.\n   */\n  private _targetWindow: Window;\n\n  /**\n   * The bounds used when determing if and where the\n   * PositioningContainer should be placed.\n   */\n  private _positioningBounds: IRectangle;\n\n  /**\n   * The maximum height the PositioningContainer can grow to\n   * without going being the window or target bounds\n   */\n  private _maxHeight: number | undefined;\n  private _positionAttempts: number;\n  private _target: HTMLElement | MouseEvent | IPoint | null;\n  private _setHeightOffsetTimer: number;\n\n  constructor(props: IPositioningContainerProps) {\n    super(props);\n    this._didSetInitialFocus = false;\n    this.state = {\n      positions: undefined,\n      heightOffset: 0\n    };\n    this._positionAttempts = 0;\n  }\n\n  // tslint:disable-next-line function-name\n  public UNSAFE_componentWillMount(): void {\n    this._setTargetWindowAndElement(this._getTarget());\n  }\n\n  public componentDidMount(): void {\n    this._onComponentDidMount();\n  }\n\n  public componentDidUpdate(): void {\n    this._setInitialFocus();\n    this._updateAsyncPosition();\n  }\n\n  // tslint:disable-next-line function-name\n  public UNSAFE_componentWillUpdate(newProps: IPositioningContainerProps): void {\n    // If the target element changed, find the new one. If we are tracking\n    // target with class name, always find element because we do not know if\n    // fabric has rendered a new element and disposed the old element.\n    const newTarget = this._getTarget(newProps);\n    const oldTarget = this._getTarget();\n    if (newTarget !== oldTarget || typeof newTarget === 'string' || newTarget instanceof String) {\n      this._maxHeight = undefined;\n      this._setTargetWindowAndElement(newTarget!);\n    }\n\n    if (newProps.offsetFromTarget !== this.props.offsetFromTarget) {\n      this._maxHeight = undefined;\n    }\n\n    if (newProps.finalHeight !== this.props.finalHeight) {\n      this._setHeightOffsetEveryFrame();\n    }\n  }\n\n  public render(): JSX.Element | null {\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!this._targetWindow) {\n      return null;\n    }\n\n    const { className, positioningContainerWidth, positioningContainerMaxHeight, children } = this.props;\n    const { positions } = this.state;\n\n    const styles = getClassNames();\n\n    const directionalClassName =\n      positions && positions.targetEdge ? (AnimationClassNames as any)[SLIDE_ANIMATIONS[positions.targetEdge]] : '';\n\n    const getContentMaxHeight: number = this._getMaxHeight() + this.state.heightOffset!;\n    const contentMaxHeight: number =\n      positioningContainerMaxHeight! && positioningContainerMaxHeight! > getContentMaxHeight\n        ? getContentMaxHeight\n        : positioningContainerMaxHeight!;\n    const content = (\n      <div ref={this._positionedHost} className={css('ms-PositioningContainer', styles.container)}>\n        <div\n          className={mergeStyles(\n            'ms-PositioningContainer-layerHost',\n            styles.root,\n            className,\n            directionalClassName,\n            !!positioningContainerWidth && { width: positioningContainerWidth }\n          )}\n          // tslint:disable-next-line:jsx-ban-props\n          style={positions ? positions.elementPosition : OFF_SCREEN_STYLE}\n          tabIndex={-1} // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n          // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n          ref={this._contentHost}\n        >\n          {children}\n          {\n            // @TODO apply to the content container\n            contentMaxHeight\n          }\n        </div>\n      </div>\n    );\n\n    return this.props.doNotLayer ? content : <Layer>{content}</Layer>;\n  }\n\n  /**\n   * Deprecated, use `onResize` instead.\n   * @deprecated Use `onResize` instead.\n   */\n  public dismiss = (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n    this.onResize(ev);\n  };\n\n  public onResize = (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n    const { onDismiss } = this.props;\n    if (onDismiss) {\n      onDismiss(ev);\n    } else {\n      this._updateAsyncPosition();\n    }\n  };\n\n  protected _dismissOnScroll(ev: Event): void {\n    const { preventDismissOnScroll } = this.props;\n    if (this.state.positions && !preventDismissOnScroll) {\n      this._dismissOnLostFocus(ev);\n    }\n  }\n\n  protected _dismissOnLostFocus(ev: Event): void {\n    const target = ev.target as HTMLElement;\n    const clickedOutsideCallout = this._positionedHost.current && !elementContains(this._positionedHost.current, target);\n\n    if (\n      (!this._target && clickedOutsideCallout) ||\n      (ev.target !== this._targetWindow &&\n        clickedOutsideCallout &&\n        ((this._target as MouseEvent).stopPropagation ||\n          (!this._target || (target !== this._target && !elementContains(this._target as HTMLElement, target)))))\n    ) {\n      this.onResize(ev);\n    }\n  }\n\n  protected _setInitialFocus = (): void => {\n    if (this._contentHost.current && this.props.setInitialFocus && !this._didSetInitialFocus && this.state.positions) {\n      this._didSetInitialFocus = true;\n      focusFirstChild(this._contentHost.current);\n    }\n  };\n\n  protected _onComponentDidMount = (): void => {\n    // This is added so the positioningContainer will dismiss when the window is scrolled\n    // but not when something inside the positioningContainer is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the positioningContainer.\n    this._async.setTimeout(() => {\n      this._events.on(this._targetWindow, 'scroll', this._async.throttle(this._dismissOnScroll, 10), true);\n      this._events.on(this._targetWindow, 'resize', this._async.throttle(this.onResize, 10), true);\n      this._events.on(this._targetWindow.document.body, 'focus', this._dismissOnLostFocus, true);\n      this._events.on(this._targetWindow.document.body, 'click', this._dismissOnLostFocus, true);\n    }, 0);\n\n    if (this.props.onLayerMounted) {\n      this.props.onLayerMounted();\n    }\n\n    this._updateAsyncPosition();\n    this._setHeightOffsetEveryFrame();\n  };\n\n  private _updateAsyncPosition(): void {\n    this._async.requestAnimationFrame(() => this._updatePosition());\n  }\n\n  private _updatePosition(): void {\n    const { positions } = this.state;\n    const { offsetFromTarget, onPositioned } = this.props;\n\n    const hostElement = this._positionedHost.current;\n    const positioningContainerElement = this._contentHost.current;\n\n    if (hostElement && positioningContainerElement) {\n      let currentProps: IPositionProps | undefined;\n      currentProps = assign(currentProps, this.props);\n      currentProps!.bounds = this._getBounds();\n      currentProps!.target = this._target!;\n      if (document.body.contains(currentProps!.target as Node)) {\n        currentProps!.gapSpace = offsetFromTarget;\n        const newPositions: IPositionedData = positionElement(currentProps!, hostElement, positioningContainerElement);\n        // Set the new position only when the positions are not exists or one of the new positioningContainer positions are different.\n        // The position should not change if the position is within 2 decimal places.\n        if (\n          (!positions && newPositions) ||\n          (positions && newPositions && !this._arePositionsEqual(positions, newPositions) && this._positionAttempts < 5)\n        ) {\n          // We should not reposition the positioningContainer more than a few times, if it is then the content is likely resizing\n          // and we should stop trying to reposition to prevent a stack overflow.\n          this._positionAttempts++;\n          this.setState(\n            {\n              positions: newPositions\n            },\n            () => {\n              if (onPositioned) {\n                onPositioned(newPositions);\n              }\n            }\n          );\n        } else {\n          this._positionAttempts = 0;\n          if (onPositioned) {\n            onPositioned(newPositions);\n          }\n        }\n      } else if (positions !== undefined) {\n        this.setState({\n          positions: undefined\n        });\n      }\n    }\n  }\n\n  private _getBounds(): IRectangle {\n    if (!this._positioningBounds) {\n      let currentBounds = this.props.bounds;\n\n      if (!currentBounds) {\n        currentBounds = {\n          top: 0 + this.props.minPagePadding!,\n          left: 0 + this.props.minPagePadding!,\n          right: this._targetWindow.innerWidth - this.props.minPagePadding!,\n          bottom: this._targetWindow.innerHeight - this.props.minPagePadding!,\n          width: this._targetWindow.innerWidth - this.props.minPagePadding! * 2,\n          height: this._targetWindow.innerHeight - this.props.minPagePadding! * 2\n        };\n      }\n      this._positioningBounds = currentBounds;\n    }\n    return this._positioningBounds;\n  }\n\n  /**\n   * Return the maximum height the container can grow to\n   * without going out of the specified bounds\n   */\n  private _getMaxHeight(): number {\n    const { directionalHintFixed, offsetFromTarget, directionalHint } = this.props;\n\n    if (!this._maxHeight) {\n      if (directionalHintFixed && this._target) {\n        const gapSpace = offsetFromTarget ? offsetFromTarget : 0;\n        this._maxHeight = getMaxHeight(this._target, directionalHint!, gapSpace, this._getBounds());\n      } else {\n        this._maxHeight = this._getBounds().height! - BORDER_WIDTH * 2;\n      }\n    }\n    return this._maxHeight!;\n  }\n\n  private _arePositionsEqual(positions: IPositionedData, newPosition: IPositionedData): boolean {\n    return this._comparePositions(positions.elementPosition, newPosition.elementPosition);\n  }\n\n  private _comparePositions(oldPositions: IPosition, newPositions: IPosition): boolean {\n    for (const key in newPositions) {\n      // This needs to be checked here and below because there is a linting error if for in does not immediately have an if statement\n      if (newPositions.hasOwnProperty(key)) {\n        const oldPositionEdge = oldPositions[key];\n        const newPositionEdge = newPositions[key];\n\n        if (oldPositionEdge && newPositionEdge) {\n          if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  private _setTargetWindowAndElement(target: HTMLElement | string | MouseEvent | IPoint | null): void {\n    if (target) {\n      if (typeof target === 'string') {\n        const currentDoc: Document = getDocument()!;\n        this._target = currentDoc ? (currentDoc.querySelector(target) as HTMLElement) : null;\n        this._targetWindow = getWindow()!;\n      } else if ((target as MouseEvent).stopPropagation) {\n        this._targetWindow = getWindow((target as MouseEvent).toElement as HTMLElement)!;\n        this._target = target;\n      } else if ((target as IPoint).x !== undefined && (target as IPoint).y !== undefined) {\n        this._targetWindow = getWindow()!;\n        this._target = target;\n      } else {\n        const targetElement: HTMLElement = target as HTMLElement;\n        this._targetWindow = getWindow(targetElement)!;\n        this._target = target;\n      }\n    } else {\n      this._targetWindow = getWindow()!;\n    }\n  }\n\n  /**\n   * Animates the height if finalHeight was given.\n   */\n  private _setHeightOffsetEveryFrame(): void {\n    if (this._contentHost && this.props.finalHeight) {\n      this._setHeightOffsetTimer = this._async.requestAnimationFrame(() => {\n        if (!this._contentHost.current) {\n          return;\n        }\n\n        const positioningContainerMainElem = this._contentHost.current.lastChild as HTMLElement;\n        const cardScrollHeight: number = positioningContainerMainElem.scrollHeight;\n        const cardCurrHeight: number = positioningContainerMainElem.offsetHeight;\n        const scrollDiff: number = cardScrollHeight - cardCurrHeight;\n\n        this.setState({\n          heightOffset: this.state.heightOffset! + scrollDiff\n        });\n\n        if (positioningContainerMainElem.offsetHeight < this.props.finalHeight!) {\n          this._setHeightOffsetEveryFrame();\n        } else {\n          this._async.cancelAnimationFrame(this._setHeightOffsetTimer);\n        }\n      });\n    }\n  }\n\n  private _getTarget(props: IPositioningContainerProps = this.props): HTMLElement | string | MouseEvent | IPoint | null {\n    const { target } = props;\n    return target!;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"script"}