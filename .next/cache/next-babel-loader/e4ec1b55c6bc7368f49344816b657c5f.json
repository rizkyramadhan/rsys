{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { Fabric } from '../../Fabric';\nimport { classNamesFunction, customizable, getDocument, setPortalAttribute, setVirtualParent, warnDeprecations } from '../../Utilities';\nimport { registerLayer, getDefaultTarget, unregisterLayer } from './Layer.notification';\nvar getClassNames = classNamesFunction();\n\nvar LayerBase =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(LayerBase, _super);\n\n  function LayerBase(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * rootElement wrapper for setting virtual parent as soon as root element ref is available.\n     */\n\n\n    _this._handleRootElementRef = function (ref) {\n      _this._rootElement = ref;\n\n      if (ref) {\n        // TODO: Calling _setVirtualParent in this ref wrapper SHOULD allow us to remove\n        //    other calls to _setVirtualParent throughout this class. However,\n        //    as this is an immediate fix for a P0 issue the existing _setVirtualParent\n        //    calls are left for now to minimize potential regression.\n        _this._setVirtualParent();\n      }\n    };\n    /**\n     * Helper to stop events from bubbling up out of Layer.\n     */\n\n\n    _this._filterEvent = function (ev) {\n      // We should just be able to check ev.bubble here and only stop events that are bubbling up. However, even though mouseenter and\n      //    mouseleave do NOT bubble up, they are showing up as bubbling. Therefore we stop events based on event name rather than ev.bubble.\n      if (ev.eventPhase === Event.BUBBLING_PHASE && ev.type !== 'mouseenter' && ev.type !== 'mouseleave') {\n        ev.stopPropagation();\n      }\n    };\n\n    _this.state = {\n      hasMounted: false\n    };\n\n    if (process.env.NODE_ENV !== 'production') {\n      warnDeprecations('Layer', props, {\n        onLayerMounted: 'onLayerDidMount'\n      });\n    }\n\n    if (_this.props.hostId) {\n      registerLayer(_this.props.hostId, _this);\n    }\n\n    return _this;\n  } // tslint:disable-next-line function-name\n\n\n  LayerBase.prototype.UNSAFE_componentWillMount = function () {\n    this._layerElement = this._getLayerElement();\n  }; // tslint:disable-next-line function-name\n\n\n  LayerBase.prototype.UNSAFE_componentWillUpdate = function () {\n    if (!this._layerElement) {\n      this._layerElement = this._getLayerElement();\n    }\n  };\n\n  LayerBase.prototype.componentDidMount = function () {\n    // We can safely set state immediately because the ref wrapper will make sure the virtual\n    //    parent has been set before componentDidMount is called.\n    this.setState({\n      hasMounted: true\n    });\n\n    this._setVirtualParent();\n\n    var _a = this.props,\n        onLayerDidMount = _a.onLayerDidMount,\n        onLayerMounted = _a.onLayerMounted;\n\n    if (onLayerMounted) {\n      onLayerMounted();\n    }\n\n    if (onLayerDidMount) {\n      onLayerDidMount();\n    }\n  };\n\n  LayerBase.prototype.componentWillUnmount = function () {\n    this._removeLayerElement();\n\n    var _a = this.props,\n        onLayerWillUnmount = _a.onLayerWillUnmount,\n        hostId = _a.hostId;\n\n    if (onLayerWillUnmount) {\n      onLayerWillUnmount();\n    }\n\n    if (hostId) {\n      unregisterLayer(hostId, this);\n    }\n  };\n\n  LayerBase.prototype.componentDidUpdate = function () {\n    this._setVirtualParent();\n  };\n\n  LayerBase.prototype.render = function () {\n    var classNames = this._getClassNames();\n\n    var eventBubblingEnabled = this.props.eventBubblingEnabled;\n    var hasMounted = this.state.hasMounted;\n    return React.createElement(\"span\", {\n      className: \"ms-layer\",\n      ref: this._handleRootElementRef\n    }, this._layerElement && hasMounted && ReactDOM.createPortal(eventBubblingEnabled ? React.createElement(Fabric, {\n      className: classNames.content\n    }, this.props.children) : React.createElement(Fabric, {\n      className: classNames.content,\n      onClick: this._filterEvent,\n      onContextMenu: this._filterEvent,\n      onDoubleClick: this._filterEvent,\n      onDrag: this._filterEvent,\n      onDragEnd: this._filterEvent,\n      onDragEnter: this._filterEvent,\n      onDragExit: this._filterEvent,\n      onDragLeave: this._filterEvent,\n      onDragOver: this._filterEvent,\n      onDragStart: this._filterEvent,\n      onDrop: this._filterEvent,\n      onMouseDown: this._filterEvent,\n      onMouseEnter: this._filterEvent,\n      onMouseLeave: this._filterEvent,\n      onMouseMove: this._filterEvent,\n      onMouseOver: this._filterEvent,\n      onMouseOut: this._filterEvent,\n      onMouseUp: this._filterEvent,\n      onKeyDown: this._filterEvent,\n      onKeyPress: this._filterEvent,\n      onKeyUp: this._filterEvent,\n      onFocus: this._filterEvent,\n      onBlur: this._filterEvent,\n      onChange: this._filterEvent,\n      onInput: this._filterEvent,\n      onInvalid: this._filterEvent,\n      onSubmit: this._filterEvent\n    }, this.props.children), this._layerElement));\n  };\n\n  LayerBase.prototype._getClassNames = function () {\n    var _a = this.props,\n        className = _a.className,\n        styles = _a.styles,\n        theme = _a.theme;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      isNotHost: !this.props.hostId\n    });\n    return classNames;\n  };\n\n  LayerBase.prototype._setVirtualParent = function () {\n    if (this._rootElement && this._layerElement) {\n      setVirtualParent(this._layerElement, this._rootElement);\n    }\n  };\n\n  LayerBase.prototype._getLayerElement = function () {\n    var host = this._getHost();\n\n    var classNames = this._getClassNames();\n\n    if (host !== this._host) {\n      this._removeLayerElement();\n    }\n\n    if (host) {\n      this._host = host;\n\n      if (!this._layerElement) {\n        var doc = getDocument();\n\n        if (!doc) {\n          return;\n        }\n\n        this._layerElement = doc.createElement('div');\n        this._layerElement.className = classNames.root;\n        setPortalAttribute(this._layerElement);\n        this.props.insertFirst ? host.insertBefore(this._layerElement, host.firstChild) : host.appendChild(this._layerElement);\n      }\n    }\n\n    return this._layerElement;\n  };\n\n  LayerBase.prototype._removeLayerElement = function () {\n    if (this._layerElement) {\n      this.props.onLayerWillUnmount();\n      var parentNode = this._layerElement.parentNode;\n\n      if (parentNode) {\n        parentNode.removeChild(this._layerElement);\n      }\n\n      this._layerElement = undefined;\n    }\n  };\n\n  LayerBase.prototype._getHost = function () {\n    var hostId = this.props.hostId;\n    var doc = getDocument();\n\n    if (!doc) {\n      return undefined;\n    }\n\n    if (hostId) {\n      return doc.getElementById(hostId);\n    } else {\n      var defaultHostSelector = getDefaultTarget();\n      return defaultHostSelector ? doc.querySelector(defaultHostSelector) : doc.body;\n    }\n  };\n\n  LayerBase.defaultProps = {\n    onLayerDidMount: function onLayerDidMount() {\n      return undefined;\n    },\n    onLayerWillUnmount: function onLayerWillUnmount() {\n      return undefined;\n    }\n  };\n  LayerBase = tslib_1.__decorate([customizable('Layer', ['theme', 'hostId'])], LayerBase);\n  return LayerBase;\n}(React.Component);\n\nexport { LayerBase };","map":{"version":3,"sources":["components/Layer/Layer.base.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,OAAO,KAAK,QAAZ,MAA0B,WAA1B;AAEA,SAAS,MAAT,QAAuB,cAAvB;AAEA,SAAS,kBAAT,EAA6B,YAA7B,EAA2C,WAA3C,EAAwD,kBAAxD,EAA4E,gBAA5E,EAA8F,gBAA9F,QAAsH,iBAAtH;AACA,SAAS,aAAT,EAAwB,gBAAxB,EAA0C,eAA1C,QAAiE,sBAAjE;AAMA,IAAM,aAAa,GAAG,kBAAkB,EAAxC;;AAGA,IAAA,SAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA+B,EAAA,OAAA,CAAA,SAAA,CAAA,SAAA,EAAA,MAAA;;AAU7B,WAAA,SAAA,CAAY,KAAZ,EAA8B;AAA9B,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAN,KAAY,IADd;AAoHA;;;;;AAGQ,IAAA,KAAA,CAAA,qBAAA,GAAwB,UAAC,GAAD,EAAqB;AACnD,MAAA,KAAI,CAAC,YAAL,GAAoB,GAApB;;AACA,UAAI,GAAJ,EAAS;AACP;AACA;AACA;AACA;AACA,QAAA,KAAI,CAAC,iBAAL;AACD;AACF,KATO;AAWR;;;;;AAGQ,IAAA,KAAA,CAAA,YAAA,GAAe,UAAC,EAAD,EAAsC;AAC3D;AACA;AACA,UAAI,EAAE,CAAC,UAAH,KAAkB,KAAK,CAAC,cAAxB,IAA0C,EAAE,CAAC,IAAH,KAAY,YAAtD,IAAsE,EAAE,CAAC,IAAH,KAAY,YAAtF,EAAoG;AAClG,QAAA,EAAE,CAAC,eAAH;AACD;AACF,KANO;;AAlIN,IAAA,KAAI,CAAC,KAAL,GAAa;AACX,MAAA,UAAU,EAAE;AADD,KAAb;;AAIA,QAAI,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,MAAA,gBAAgB,CAAC,OAAD,EAAU,KAAV,EAAiB;AAC/B,QAAA,cAAc,EAAE;AADe,OAAjB,CAAhB;AAGD;;AAED,QAAI,KAAI,CAAC,KAAL,CAAW,MAAf,EAAuB;AACrB,MAAA,aAAa,CAAC,KAAI,CAAC,KAAL,CAAW,MAAZ,EAAoB,KAApB,CAAb;AACD;;;AACF,GA1BH,CA4BE;;;AACO,EAAA,SAAA,CAAA,SAAA,CAAA,yBAAA,GAAP,YAAA;AACE,SAAK,aAAL,GAAqB,KAAK,gBAAL,EAArB;AACD,GAFM,CA7BT,CAiCE;;;AACO,EAAA,SAAA,CAAA,SAAA,CAAA,0BAAA,GAAP,YAAA;AACE,QAAI,CAAC,KAAK,aAAV,EAAyB;AACvB,WAAK,aAAL,GAAqB,KAAK,gBAAL,EAArB;AACD;AACF,GAJM;;AAMA,EAAA,SAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,YAAA;AACE;AACA;AACA,SAAK,QAAL,CAAc;AAAE,MAAA,UAAU,EAAE;AAAd,KAAd;;AAEA,SAAK,iBAAL;;AAEM,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,eAAA,GAAA,EAAA,CAAA,eAAF;AAAA,QAAmB,cAAA,GAAA,EAAA,CAAA,cAAnB;;AACN,QAAI,cAAJ,EAAoB;AAClB,MAAA,cAAc;AACf;;AAED,QAAI,eAAJ,EAAqB;AACnB,MAAA,eAAe;AAChB;AACF,GAfM;;AAiBA,EAAA,SAAA,CAAA,SAAA,CAAA,oBAAA,GAAP,YAAA;AACE,SAAK,mBAAL;;AAEM,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,kBAAA,GAAA,EAAA,CAAA,kBAAF;AAAA,QAAsB,MAAA,GAAA,EAAA,CAAA,MAAtB;;AACN,QAAI,kBAAJ,EAAwB;AACtB,MAAA,kBAAkB;AACnB;;AAED,QAAI,MAAJ,EAAY;AACV,MAAA,eAAe,CAAC,MAAD,EAAS,IAAT,CAAf;AACD;AACF,GAXM;;AAaA,EAAA,SAAA,CAAA,SAAA,CAAA,kBAAA,GAAP,YAAA;AACE,SAAK,iBAAL;AACD,GAFM;;AAIA,EAAA,SAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACE,QAAM,UAAU,GAAG,KAAK,cAAL,EAAnB;;AACQ,QAAA,oBAAA,GAAA,KAAA,KAAA,CAAA,oBAAA;AACA,QAAA,UAAA,GAAA,KAAA,KAAA,CAAA,UAAA;AAER,WACE,KAAA,CAAA,aAAA,CAAA,MAAA,EAAA;AAAM,MAAA,SAAS,EAAC,UAAhB;AAA2B,MAAA,GAAG,EAAE,KAAK;AAArC,KAAA,EACG,KAAK,aAAL,IACC,UADD,IAEC,QAAQ,CAAC,YAAT,CACE,oBAAoB,GAClB,KAAA,CAAA,aAAA,CAAC,MAAD,EAAO;AAAC,MAAA,SAAS,EAAE,UAAU,CAAC;AAAvB,KAAP,EAAwC,KAAK,KAAL,CAAW,QAAnD,CADkB,GAGlB,KAAA,CAAA,aAAA,CAAC,MAAD,EAAO;AACL,MAAA,SAAS,EAAE,UAAU,CAAC,OADjB;AAEL,MAAA,OAAO,EAAE,KAAK,YAFT;AAGL,MAAA,aAAa,EAAE,KAAK,YAHf;AAIL,MAAA,aAAa,EAAE,KAAK,YAJf;AAKL,MAAA,MAAM,EAAE,KAAK,YALR;AAML,MAAA,SAAS,EAAE,KAAK,YANX;AAOL,MAAA,WAAW,EAAE,KAAK,YAPb;AAQL,MAAA,UAAU,EAAE,KAAK,YARZ;AASL,MAAA,WAAW,EAAE,KAAK,YATb;AAUL,MAAA,UAAU,EAAE,KAAK,YAVZ;AAWL,MAAA,WAAW,EAAE,KAAK,YAXb;AAYL,MAAA,MAAM,EAAE,KAAK,YAZR;AAaL,MAAA,WAAW,EAAE,KAAK,YAbb;AAcL,MAAA,YAAY,EAAE,KAAK,YAdd;AAeL,MAAA,YAAY,EAAE,KAAK,YAfd;AAgBL,MAAA,WAAW,EAAE,KAAK,YAhBb;AAiBL,MAAA,WAAW,EAAE,KAAK,YAjBb;AAkBL,MAAA,UAAU,EAAE,KAAK,YAlBZ;AAmBL,MAAA,SAAS,EAAE,KAAK,YAnBX;AAoBL,MAAA,SAAS,EAAE,KAAK,YApBX;AAqBL,MAAA,UAAU,EAAE,KAAK,YArBZ;AAsBL,MAAA,OAAO,EAAE,KAAK,YAtBT;AAuBL,MAAA,OAAO,EAAE,KAAK,YAvBT;AAwBL,MAAA,MAAM,EAAE,KAAK,YAxBR;AAyBL,MAAA,QAAQ,EAAE,KAAK,YAzBV;AA0BL,MAAA,OAAO,EAAE,KAAK,YA1BT;AA2BL,MAAA,SAAS,EAAE,KAAK,YA3BX;AA4BL,MAAA,QAAQ,EAAE,KAAK;AA5BV,KAAP,EA8BG,KAAK,KAAL,CAAW,QA9Bd,CAJJ,EAqCE,KAAK,aArCP,CAHJ,CADF;AA6CD,GAlDM;;AA6EC,EAAA,SAAA,CAAA,SAAA,CAAA,cAAA,GAAR,YAAA;AACQ,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,SAAA,GAAA,EAAA,CAAA,SAAF;AAAA,QAAa,MAAA,GAAA,EAAA,CAAA,MAAb;AAAA,QAAqB,KAAA,GAAA,EAAA,CAAA,KAArB;AACN,QAAM,UAAU,GAAG,aAAa,CAAC,MAAD,EAAU;AACxC,MAAA,KAAK,EAAE,KADiC;AAExC,MAAA,SAAS,EAAA,SAF+B;AAGxC,MAAA,SAAS,EAAE,CAAC,KAAK,KAAL,CAAW;AAHiB,KAAV,CAAhC;AAMA,WAAO,UAAP;AACD,GATO;;AAWA,EAAA,SAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,YAAA;AACE,QAAI,KAAK,YAAL,IAAqB,KAAK,aAA9B,EAA6C;AAC3C,MAAA,gBAAgB,CAAC,KAAK,aAAN,EAAqB,KAAK,YAA1B,CAAhB;AACD;AACF,GAJO;;AAMA,EAAA,SAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,YAAA;AACE,QAAM,IAAI,GAAG,KAAK,QAAL,EAAb;;AAEA,QAAM,UAAU,GAAG,KAAK,cAAL,EAAnB;;AAEA,QAAI,IAAI,KAAK,KAAK,KAAlB,EAAyB;AACvB,WAAK,mBAAL;AACD;;AAED,QAAI,IAAJ,EAAU;AACR,WAAK,KAAL,GAAa,IAAb;;AAEA,UAAI,CAAC,KAAK,aAAV,EAAyB;AACvB,YAAM,GAAG,GAAG,WAAW,EAAvB;;AACA,YAAI,CAAC,GAAL,EAAU;AACR;AACD;;AAED,aAAK,aAAL,GAAqB,GAAG,CAAC,aAAJ,CAAkB,KAAlB,CAArB;AACA,aAAK,aAAL,CAAmB,SAAnB,GAA+B,UAAU,CAAC,IAA1C;AACA,QAAA,kBAAkB,CAAC,KAAK,aAAN,CAAlB;AAEA,aAAK,KAAL,CAAW,WAAX,GAAyB,IAAI,CAAC,YAAL,CAAkB,KAAK,aAAvB,EAAsC,IAAI,CAAC,UAA3C,CAAzB,GAAkF,IAAI,CAAC,WAAL,CAAiB,KAAK,aAAtB,CAAlF;AACD;AACF;;AAED,WAAO,KAAK,aAAZ;AACD,GA3BO;;AA6BA,EAAA,SAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,YAAA;AACE,QAAI,KAAK,aAAT,EAAwB;AACtB,WAAK,KAAL,CAAW,kBAAX;AAEA,UAAM,UAAU,GAAG,KAAK,aAAL,CAAmB,UAAtC;;AACA,UAAI,UAAJ,EAAgB;AACd,QAAA,UAAU,CAAC,WAAX,CAAuB,KAAK,aAA5B;AACD;;AACD,WAAK,aAAL,GAAqB,SAArB;AACD;AACF,GAVO;;AAYA,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,GAAR,YAAA;AACU,QAAA,MAAA,GAAA,KAAA,KAAA,CAAA,MAAA;AAER,QAAM,GAAG,GAAG,WAAW,EAAvB;;AACA,QAAI,CAAC,GAAL,EAAU;AACR,aAAO,SAAP;AACD;;AAED,QAAI,MAAJ,EAAY;AACV,aAAO,GAAG,CAAC,cAAJ,CAAmB,MAAnB,CAAP;AACD,KAFD,MAEO;AACL,UAAM,mBAAmB,GAAG,gBAAgB,EAA5C;AACA,aAAO,mBAAmB,GAAI,GAAG,CAAC,aAAJ,CAAkB,mBAAlB,CAAJ,GAAsD,GAAG,CAAC,IAApF;AACD;AACF,GAdO;;AAhNM,EAAA,SAAA,CAAA,YAAA,GAA4B;AACxC,IAAA,eAAe,EAAE,2BAAA;AAAM,aAAA,SAAA;AAAS,KADQ;AAExC,IAAA,kBAAkB,EAAE,8BAAA;AAAM,aAAA,SAAA;AAAS;AAFK,GAA5B;AADH,EAAA,SAAS,GAAA,OAAA,CAAA,UAAA,CAAA,CADrB,YAAY,CAAC,OAAD,EAAU,CAAC,OAAD,EAAU,QAAV,CAAV,CACS,CAAA,EAAT,SAAS,CAAT;AAgOb,SAAA,SAAA;AAAC,CAhOD,CAA+B,KAAK,CAAC,SAArC,CAAA;;SAAa,S","sourcesContent":["import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\n\nimport { Fabric } from '../../Fabric';\nimport { ILayerProps, ILayerStyleProps, ILayerStyles } from './Layer.types';\nimport { classNamesFunction, customizable, getDocument, setPortalAttribute, setVirtualParent, warnDeprecations } from '../../Utilities';\nimport { registerLayer, getDefaultTarget, unregisterLayer } from './Layer.notification';\n\nexport type ILayerBaseState = {\n  hasMounted: boolean;\n};\n\nconst getClassNames = classNamesFunction<ILayerStyleProps, ILayerStyles>();\n\n@customizable('Layer', ['theme', 'hostId'])\nexport class LayerBase extends React.Component<ILayerProps, ILayerBaseState> {\n  public static defaultProps: ILayerProps = {\n    onLayerDidMount: () => undefined,\n    onLayerWillUnmount: () => undefined\n  };\n\n  private _host: Node;\n  private _layerElement: HTMLElement | undefined;\n  private _rootElement: HTMLSpanElement | undefined;\n\n  constructor(props: ILayerProps) {\n    super(props);\n\n    this.state = {\n      hasMounted: false\n    };\n\n    if (process.env.NODE_ENV !== 'production') {\n      warnDeprecations('Layer', props, {\n        onLayerMounted: 'onLayerDidMount'\n      });\n    }\n\n    if (this.props.hostId) {\n      registerLayer(this.props.hostId, this);\n    }\n  }\n\n  // tslint:disable-next-line function-name\n  public UNSAFE_componentWillMount(): void {\n    this._layerElement = this._getLayerElement();\n  }\n\n  // tslint:disable-next-line function-name\n  public UNSAFE_componentWillUpdate(): void {\n    if (!this._layerElement) {\n      this._layerElement = this._getLayerElement();\n    }\n  }\n\n  public componentDidMount(): void {\n    // We can safely set state immediately because the ref wrapper will make sure the virtual\n    //    parent has been set before componentDidMount is called.\n    this.setState({ hasMounted: true });\n\n    this._setVirtualParent();\n\n    const { onLayerDidMount, onLayerMounted } = this.props;\n    if (onLayerMounted) {\n      onLayerMounted();\n    }\n\n    if (onLayerDidMount) {\n      onLayerDidMount();\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._removeLayerElement();\n\n    const { onLayerWillUnmount, hostId } = this.props;\n    if (onLayerWillUnmount) {\n      onLayerWillUnmount();\n    }\n\n    if (hostId) {\n      unregisterLayer(hostId, this);\n    }\n  }\n\n  public componentDidUpdate(): void {\n    this._setVirtualParent();\n  }\n\n  public render(): React.ReactNode {\n    const classNames = this._getClassNames();\n    const { eventBubblingEnabled } = this.props;\n    const { hasMounted } = this.state;\n\n    return (\n      <span className=\"ms-layer\" ref={this._handleRootElementRef}>\n        {this._layerElement &&\n          hasMounted &&\n          ReactDOM.createPortal(\n            eventBubblingEnabled ? (\n              <Fabric className={classNames.content}>{this.props.children}</Fabric>\n            ) : (\n              <Fabric\n                className={classNames.content}\n                onClick={this._filterEvent}\n                onContextMenu={this._filterEvent}\n                onDoubleClick={this._filterEvent}\n                onDrag={this._filterEvent}\n                onDragEnd={this._filterEvent}\n                onDragEnter={this._filterEvent}\n                onDragExit={this._filterEvent}\n                onDragLeave={this._filterEvent}\n                onDragOver={this._filterEvent}\n                onDragStart={this._filterEvent}\n                onDrop={this._filterEvent}\n                onMouseDown={this._filterEvent}\n                onMouseEnter={this._filterEvent}\n                onMouseLeave={this._filterEvent}\n                onMouseMove={this._filterEvent}\n                onMouseOver={this._filterEvent}\n                onMouseOut={this._filterEvent}\n                onMouseUp={this._filterEvent}\n                onKeyDown={this._filterEvent}\n                onKeyPress={this._filterEvent}\n                onKeyUp={this._filterEvent}\n                onFocus={this._filterEvent}\n                onBlur={this._filterEvent}\n                onChange={this._filterEvent}\n                onInput={this._filterEvent}\n                onInvalid={this._filterEvent}\n                onSubmit={this._filterEvent}\n              >\n                {this.props.children}\n              </Fabric>\n            ),\n            this._layerElement\n          )}\n      </span>\n    );\n  }\n\n  /**\n   * rootElement wrapper for setting virtual parent as soon as root element ref is available.\n   */\n  private _handleRootElementRef = (ref: HTMLSpanElement): void => {\n    this._rootElement = ref;\n    if (ref) {\n      // TODO: Calling _setVirtualParent in this ref wrapper SHOULD allow us to remove\n      //    other calls to _setVirtualParent throughout this class. However,\n      //    as this is an immediate fix for a P0 issue the existing _setVirtualParent\n      //    calls are left for now to minimize potential regression.\n      this._setVirtualParent();\n    }\n  };\n\n  /**\n   * Helper to stop events from bubbling up out of Layer.\n   */\n  private _filterEvent = (ev: React.SyntheticEvent<HTMLElement>): void => {\n    // We should just be able to check ev.bubble here and only stop events that are bubbling up. However, even though mouseenter and\n    //    mouseleave do NOT bubble up, they are showing up as bubbling. Therefore we stop events based on event name rather than ev.bubble.\n    if (ev.eventPhase === Event.BUBBLING_PHASE && ev.type !== 'mouseenter' && ev.type !== 'mouseleave') {\n      ev.stopPropagation();\n    }\n  };\n\n  private _getClassNames() {\n    const { className, styles, theme } = this.props;\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      isNotHost: !this.props.hostId\n    });\n\n    return classNames;\n  }\n\n  private _setVirtualParent() {\n    if (this._rootElement && this._layerElement) {\n      setVirtualParent(this._layerElement, this._rootElement);\n    }\n  }\n\n  private _getLayerElement(): HTMLElement | undefined {\n    const host = this._getHost();\n\n    const classNames = this._getClassNames();\n\n    if (host !== this._host) {\n      this._removeLayerElement();\n    }\n\n    if (host) {\n      this._host = host;\n\n      if (!this._layerElement) {\n        const doc = getDocument();\n        if (!doc) {\n          return;\n        }\n\n        this._layerElement = doc.createElement('div');\n        this._layerElement.className = classNames.root!;\n        setPortalAttribute(this._layerElement);\n\n        this.props.insertFirst ? host.insertBefore(this._layerElement, host.firstChild) : host.appendChild(this._layerElement);\n      }\n    }\n\n    return this._layerElement;\n  }\n\n  private _removeLayerElement(): void {\n    if (this._layerElement) {\n      this.props.onLayerWillUnmount!();\n\n      const parentNode = this._layerElement.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(this._layerElement);\n      }\n      this._layerElement = undefined;\n    }\n  }\n\n  private _getHost(): Node | undefined {\n    const { hostId } = this.props;\n\n    const doc = getDocument();\n    if (!doc) {\n      return undefined;\n    }\n\n    if (hostId) {\n      return doc.getElementById(hostId) as Node;\n    } else {\n      const defaultHostSelector = getDefaultTarget();\n      return defaultHostSelector ? (doc.querySelector(defaultHostSelector) as Node) : doc.body;\n    }\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}