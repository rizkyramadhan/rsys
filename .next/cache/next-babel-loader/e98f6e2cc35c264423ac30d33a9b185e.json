{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport { initializeComponentRef, initializeFocusRects, warnMutuallyExclusive, Async, getId, KeyCodes, customizable, calculatePrecision, precisionRound, mergeAriaAttributeValues } from '../../Utilities';\nimport { Position } from '../../utilities/positioning';\nimport { getStyles, getArrowButtonStyles } from './SpinButton.styles';\nimport { getClassNames } from './SpinButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nexport var KeyboardSpinDirection;\n\n(function (KeyboardSpinDirection) {\n  KeyboardSpinDirection[KeyboardSpinDirection[\"down\"] = -1] = \"down\";\n  KeyboardSpinDirection[KeyboardSpinDirection[\"notSpinning\"] = 0] = \"notSpinning\";\n  KeyboardSpinDirection[KeyboardSpinDirection[\"up\"] = 1] = \"up\";\n})(KeyboardSpinDirection || (KeyboardSpinDirection = {}));\n\nvar SpinButton =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(SpinButton, _super);\n\n  function SpinButton(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._input = React.createRef();\n    _this._initialStepDelay = 400;\n    _this._stepDelay = 75;\n\n    _this._onFocus = function (ev) {\n      // We can't set focus on a non-existing element\n      if (!_this._input.current) {\n        return;\n      }\n\n      if (_this._spinningByMouse || _this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n        _this._stop();\n      }\n\n      _this._input.current.select();\n\n      _this.setState({\n        isFocused: true\n      });\n\n      if (_this.props.onFocus) {\n        _this.props.onFocus(ev);\n      }\n    };\n\n    _this._onBlur = function (ev) {\n      _this._validate(ev);\n\n      _this.setState({\n        isFocused: false\n      });\n\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n    };\n\n    _this._onValidate = function (value, event) {\n      if (_this.props.onValidate) {\n        return _this.props.onValidate(value, event);\n      } else {\n        return _this._defaultOnValidate(value);\n      }\n    };\n\n    _this._calculatePrecision = function (props) {\n      var _a = props.precision,\n          precision = _a === void 0 ? Math.max(calculatePrecision(props.step), 0) : _a;\n      return precision;\n    };\n    /**\n     * Validate function to use if one is not passed in\n     */\n\n\n    _this._defaultOnValidate = function (value) {\n      if (value === null || value.trim().length === 0 || isNaN(Number(value))) {\n        return _this._lastValidValue;\n      }\n\n      var newValue = Math.min(_this.props.max, Math.max(_this.props.min, Number(value)));\n      return String(newValue);\n    };\n\n    _this._onIncrement = function (value) {\n      if (_this.props.onIncrement) {\n        return _this.props.onIncrement(value);\n      } else {\n        return _this._defaultOnIncrement(value);\n      }\n    };\n    /**\n     * Increment function to use if one is not passed in\n     */\n\n\n    _this._defaultOnIncrement = function (value) {\n      var _a = _this.props,\n          max = _a.max,\n          step = _a.step;\n      var newValue = Math.min(Number(value) + Number(step), max);\n      newValue = precisionRound(newValue, _this._precision);\n      return String(newValue);\n    };\n\n    _this._onDecrement = function (value) {\n      if (_this.props.onDecrement) {\n        return _this.props.onDecrement(value);\n      } else {\n        return _this._defaultOnDecrement(value);\n      }\n    };\n    /**\n     * Increment function to use if one is not passed in\n     */\n\n\n    _this._defaultOnDecrement = function (value) {\n      var _a = _this.props,\n          min = _a.min,\n          step = _a.step;\n      var newValue = Math.max(Number(value) - Number(step), min);\n      newValue = precisionRound(newValue, _this._precision);\n      return String(newValue);\n    };\n    /**\n     * This is used when validating text entry\n     * in the input (not when changed via the buttons)\n     * @param event - the event that fired\n     */\n\n\n    _this._validate = function (event) {\n      if (_this.state.value !== undefined && _this._valueToValidate !== undefined && _this._valueToValidate !== _this._lastValidValue) {\n        var newValue = _this._onValidate(_this._valueToValidate, event);\n\n        if (newValue) {\n          _this._lastValidValue = newValue;\n          _this._valueToValidate = undefined;\n\n          _this.setState({\n            value: newValue\n          });\n        }\n      }\n    };\n    /**\n     * The method is needed to ensure we are updating the actual input value.\n     * without this our value will never change (and validation will not have the correct number)\n     * @param event - the event that was fired\n     */\n\n\n    _this._onInputChange = function (event) {\n      var element = event.target;\n      var value = element.value;\n      _this._valueToValidate = value;\n\n      _this.setState({\n        value: value\n      });\n    };\n    /**\n     * Update the value with the given stepFunction\n     * @param shouldSpin - should we fire off another updateValue when we are done here? This should be true\n     * when spinning in response to a mouseDown\n     * @param stepFunction - function to use to step by\n     */\n\n\n    _this._updateValue = function (shouldSpin, stepDelay, stepFunction) {\n      var newValue = stepFunction(_this.state.value);\n\n      if (newValue) {\n        _this._lastValidValue = newValue;\n\n        _this.setState({\n          value: newValue\n        });\n      }\n\n      if (_this._spinningByMouse !== shouldSpin) {\n        _this._spinningByMouse = shouldSpin;\n      }\n\n      if (shouldSpin) {\n        _this._currentStepFunctionHandle = _this._async.setTimeout(function () {\n          _this._updateValue(shouldSpin, _this._stepDelay, stepFunction);\n        }, stepDelay);\n      }\n    };\n    /**\n     * Stop spinning (clear any currently pending update and set spinning to false)\n     */\n\n\n    _this._stop = function () {\n      if (_this._currentStepFunctionHandle >= 0) {\n        _this._async.clearTimeout(_this._currentStepFunctionHandle);\n\n        _this._currentStepFunctionHandle = -1;\n      }\n\n      if (_this._spinningByMouse || _this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n        _this._spinningByMouse = false;\n\n        _this.setState({\n          keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n        });\n      }\n    };\n    /**\n     * Handle keydown on the text field. We need to update\n     * the value when up or down arrow are depressed\n     * @param event - the keyboardEvent that was fired\n     */\n\n\n    _this._handleKeyDown = function (event) {\n      // eat the up and down arrow keys to keep focus in the spinButton\n      // (especially when a spinButton is inside of a FocusZone)\n      if (event.which === KeyCodes.up || event.which === KeyCodes.down || event.which === KeyCodes.enter) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      if (_this.props.disabled) {\n        _this._stop();\n\n        return;\n      }\n\n      var spinDirection = KeyboardSpinDirection.notSpinning;\n\n      switch (event.which) {\n        case KeyCodes.up:\n          spinDirection = KeyboardSpinDirection.up;\n\n          _this._updateValue(false\n          /* shouldSpin */\n          , _this._initialStepDelay, _this._onIncrement);\n\n          break;\n\n        case KeyCodes.down:\n          spinDirection = KeyboardSpinDirection.down;\n\n          _this._updateValue(false\n          /* shouldSpin */\n          , _this._initialStepDelay, _this._onDecrement);\n\n          break;\n\n        case KeyCodes.enter:\n        case KeyCodes.tab:\n          _this._validate(event);\n\n          break;\n\n        case KeyCodes.escape:\n          if (_this.state.value !== _this._lastValidValue) {\n            _this.setState({\n              value: _this._lastValidValue\n            });\n          }\n\n          break;\n\n        default:\n          break;\n      } // style the increment/decrement button to look active\n      // when the corresponding up/down arrow keys trigger a step\n\n\n      if (_this.state.keyboardSpinDirection !== spinDirection) {\n        _this.setState({\n          keyboardSpinDirection: spinDirection\n        });\n      }\n    };\n    /**\n     * Make sure that we have stopped spinning on keyUp\n     * if the up or down arrow fired this event\n     * @param event - keyboard event\n     */\n\n\n    _this._handleKeyUp = function (event) {\n      if (_this.props.disabled || event.which === KeyCodes.up || event.which === KeyCodes.down) {\n        _this._stop();\n\n        return;\n      }\n    };\n\n    _this._onIncrementMouseDown = function () {\n      _this._updateValue(true\n      /* shouldSpin */\n      , _this._initialStepDelay, _this._onIncrement);\n    };\n\n    _this._onDecrementMouseDown = function () {\n      _this._updateValue(true\n      /* shouldSpin */\n      , _this._initialStepDelay, _this._onDecrement);\n    };\n\n    initializeComponentRef(_this);\n    initializeFocusRects();\n    warnMutuallyExclusive('SpinButton', props, {\n      value: 'defaultValue'\n    });\n    var value = props.value || props.defaultValue || String(props.min) || '0';\n    _this._lastValidValue = value; // Ensure that the autocalculated precision is not negative.\n\n    _this._precision = _this._calculatePrecision(_this.props);\n    _this.state = {\n      isFocused: false,\n      value: value,\n      keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n    };\n    _this._async = new Async(_this);\n    _this._currentStepFunctionHandle = -1;\n    _this._labelId = getId('Label');\n    _this._inputId = getId('input');\n    _this._spinningByMouse = false;\n    _this._valueToValidate = undefined;\n    return _this;\n  }\n\n  SpinButton.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n  };\n  /**\n   * Invoked when a component is receiving new props. This method is not called for the initial render.\n   */\n  // tslint:disable-next-line function-name\n\n\n  SpinButton.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    this._lastValidValue = this.state.value;\n    var value = newProps.value ? newProps.value : String(newProps.min);\n\n    if (newProps.defaultValue) {\n      value = String(Math.max(newProps.min, Math.min(newProps.max, Number(newProps.defaultValue))));\n    }\n\n    if (newProps.value !== undefined) {\n      this.setState({\n        value: value\n      });\n    }\n\n    this._precision = this._calculatePrecision(newProps);\n  };\n\n  SpinButton.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        disabled = _a.disabled,\n        label = _a.label,\n        min = _a.min,\n        max = _a.max,\n        labelPosition = _a.labelPosition,\n        iconProps = _a.iconProps,\n        incrementButtonIcon = _a.incrementButtonIcon,\n        incrementButtonAriaLabel = _a.incrementButtonAriaLabel,\n        decrementButtonIcon = _a.decrementButtonIcon,\n        decrementButtonAriaLabel = _a.decrementButtonAriaLabel,\n        title = _a.title,\n        ariaLabel = _a.ariaLabel,\n        ariaDescribedBy = _a.ariaDescribedBy,\n        customStyles = _a.styles,\n        customUpArrowButtonStyles = _a.upArrowButtonStyles,\n        customDownArrowButtonStyles = _a.downArrowButtonStyles,\n        theme = _a.theme,\n        ariaPositionInSet = _a.ariaPositionInSet,\n        ariaSetSize = _a.ariaSetSize,\n        ariaValueNow = _a.ariaValueNow,\n        ariaValueText = _a.ariaValueText,\n        keytipProps = _a.keytipProps,\n        className = _a.className,\n        inputProps = _a.inputProps,\n        iconButtonProps = _a.iconButtonProps;\n    var _b = this.state,\n        isFocused = _b.isFocused,\n        value = _b.value,\n        keyboardSpinDirection = _b.keyboardSpinDirection;\n    var classNames = this.props.getClassNames ? this.props.getClassNames(theme, disabled, isFocused, keyboardSpinDirection, labelPosition, className) : getClassNames(getStyles(theme, customStyles), disabled, isFocused, keyboardSpinDirection, labelPosition, className);\n    return React.createElement(\"div\", {\n      className: classNames.root\n    }, labelPosition !== Position.bottom && React.createElement(\"div\", {\n      className: classNames.labelWrapper\n    }, iconProps && React.createElement(Icon, tslib_1.__assign({}, iconProps, {\n      className: classNames.icon,\n      \"aria-hidden\": \"true\"\n    })), label && React.createElement(Label, {\n      id: this._labelId,\n      htmlFor: this._inputId,\n      className: classNames.label,\n      disabled: disabled\n    }, label)), React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return React.createElement(\"div\", {\n        className: classNames.spinButtonWrapper,\n        title: title && title,\n        \"aria-label\": ariaLabel && ariaLabel,\n        \"aria-posinset\": ariaPositionInSet,\n        \"aria-setsize\": ariaSetSize,\n        \"data-ktp-target\": keytipAttributes['data-ktp-target']\n      }, React.createElement(\"input\", tslib_1.__assign({\n        value: value,\n        id: _this._inputId,\n        onChange: _this._onChange,\n        onInput: _this._onInputChange,\n        className: classNames.input,\n        type: \"text\",\n        autoComplete: \"off\",\n        role: \"spinbutton\",\n        \"aria-labelledby\": label && _this._labelId,\n        \"aria-valuenow\": !isNaN(Number(ariaValueNow)) ? ariaValueNow : !isNaN(Number(value)) ? Number(value) : undefined,\n        \"aria-valuetext\": ariaValueText ? ariaValueText : isNaN(Number(value)) ? value : undefined,\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-describedby\": mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby']),\n        onBlur: _this._onBlur,\n        ref: _this._input,\n        onFocus: _this._onFocus,\n        onKeyDown: _this._handleKeyDown,\n        onKeyUp: _this._handleKeyUp,\n        readOnly: disabled,\n        \"aria-disabled\": disabled,\n        \"data-lpignore\": true,\n        \"data-ktp-execute-target\": keytipAttributes['data-ktp-execute-target']\n      }, inputProps)), React.createElement(\"span\", {\n        className: classNames.arrowBox\n      }, React.createElement(IconButton, tslib_1.__assign({\n        styles: getArrowButtonStyles(theme, true, customUpArrowButtonStyles),\n        className: 'ms-UpButton',\n        checked: keyboardSpinDirection === KeyboardSpinDirection.up,\n        disabled: disabled,\n        iconProps: incrementButtonIcon,\n        onMouseDown: _this._onIncrementMouseDown,\n        onMouseLeave: _this._stop,\n        onMouseUp: _this._stop,\n        tabIndex: -1,\n        ariaLabel: incrementButtonAriaLabel,\n        \"data-is-focusable\": false\n      }, iconButtonProps)), React.createElement(IconButton, tslib_1.__assign({\n        styles: getArrowButtonStyles(theme, false, customDownArrowButtonStyles),\n        className: 'ms-DownButton',\n        checked: keyboardSpinDirection === KeyboardSpinDirection.down,\n        disabled: disabled,\n        iconProps: decrementButtonIcon,\n        onMouseDown: _this._onDecrementMouseDown,\n        onMouseLeave: _this._stop,\n        onMouseUp: _this._stop,\n        tabIndex: -1,\n        ariaLabel: decrementButtonAriaLabel,\n        \"data-is-focusable\": false\n      }, iconButtonProps))));\n    }), labelPosition === Position.bottom && React.createElement(\"div\", {\n      className: classNames.labelWrapper\n    }, iconProps && React.createElement(Icon, {\n      iconName: iconProps.iconName,\n      className: classNames.icon,\n      \"aria-hidden\": \"true\"\n    }), label && React.createElement(Label, {\n      id: this._labelId,\n      htmlFor: this._inputId,\n      className: classNames.label,\n      disabled: disabled\n    }, label)));\n  };\n\n  SpinButton.prototype.focus = function () {\n    if (this._input.current) {\n      this._input.current.focus();\n    }\n  };\n\n  _Object$defineProperty(SpinButton.prototype, \"value\", {\n    /**\n     * Gets the value of the spin button.\n     */\n    get: function get() {\n      return this.props.value === undefined ? this.state.value : this.props.value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SpinButton.prototype._onChange = function () {\n    /**\n     * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n     * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n     * The no-op onChange handler was still needed because React gives console errors if an input\n     * doesn't have onChange.\n     *\n     * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n     * ours or 3rd-party, which simulate entering text in a SpinButton)\n     */\n  };\n\n  SpinButton.defaultProps = {\n    step: 1,\n    min: 0,\n    max: 100,\n    disabled: false,\n    labelPosition: Position.start,\n    label: '',\n    incrementButtonIcon: {\n      iconName: 'ChevronUpSmall'\n    },\n    decrementButtonIcon: {\n      iconName: 'ChevronDownSmall'\n    }\n  };\n  SpinButton = tslib_1.__decorate([customizable('SpinButton', ['theme', 'styles'], true)], SpinButton);\n  return SpinButton;\n}(React.Component);\n\nexport { SpinButton };","map":{"version":3,"sources":["components/SpinButton/SpinButton.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport {\n  initializeComponentRef,\n  initializeFocusRects,\n  warnMutuallyExclusive,\n  Async,\n  getId,\n  KeyCodes,\n  customizable,\n  calculatePrecision,\n  precisionRound,\n  mergeAriaAttributeValues\n} from '../../Utilities';\nimport { ISpinButton, ISpinButtonProps } from './SpinButton.types';\nimport { Position } from '../../utilities/positioning';\nimport { getStyles, getArrowButtonStyles } from './SpinButton.styles';\nimport { getClassNames } from './SpinButton.classNames';\nimport { KeytipData } from '../../KeytipData';\n\nexport enum KeyboardSpinDirection {\n  down = -1,\n  notSpinning = 0,\n  up = 1\n}\n\nexport interface ISpinButtonState {\n  /**\n   * Is true when the control has focus.\n   */\n  isFocused: boolean;\n\n  /**\n   * the value of the spin button\n   */\n  value: string;\n\n  /**\n   * keyboard spin direction, used to style the up or down button\n   * as active when up/down arrow is pressed\n   */\n  keyboardSpinDirection: KeyboardSpinDirection;\n}\n\nexport type DefaultProps = Required<\n  Pick<ISpinButtonProps, 'step' | 'min' | 'max' | 'disabled' | 'labelPosition' | 'label' | 'incrementButtonIcon' | 'decrementButtonIcon'>\n>;\n\n/** Internal only props */\ntype ISpinButtonInternalProps = ISpinButtonProps & DefaultProps;\n\n@customizable('SpinButton', ['theme', 'styles'], true)\nexport class SpinButton extends React.Component<ISpinButtonProps, ISpinButtonState> implements ISpinButton {\n  public static defaultProps: DefaultProps = {\n    step: 1,\n    min: 0,\n    max: 100,\n    disabled: false,\n    labelPosition: Position.start,\n    label: '',\n    incrementButtonIcon: { iconName: 'ChevronUpSmall' },\n    decrementButtonIcon: { iconName: 'ChevronDownSmall' }\n  };\n\n  private _async: Async;\n  private _input = React.createRef<HTMLInputElement>();\n  private _inputId: string;\n  private _labelId: string;\n  private _lastValidValue: string;\n  private _spinningByMouse: boolean;\n  private _valueToValidate: string | undefined; // To avoid duplicate validations/submissions\n  private _precision: number;\n\n  private _currentStepFunctionHandle: number;\n  private _initialStepDelay = 400;\n  private _stepDelay = 75;\n\n  constructor(props: ISpinButtonProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    initializeFocusRects();\n\n    warnMutuallyExclusive('SpinButton', props, {\n      value: 'defaultValue'\n    });\n\n    const value = props.value || props.defaultValue || String(props.min) || '0';\n    this._lastValidValue = value;\n\n    // Ensure that the autocalculated precision is not negative.\n    this._precision = this._calculatePrecision(this.props as ISpinButtonInternalProps);\n\n    this.state = {\n      isFocused: false,\n      value: value,\n      keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n    };\n\n    this._async = new Async(this);\n    this._currentStepFunctionHandle = -1;\n    this._labelId = getId('Label');\n    this._inputId = getId('input');\n    this._spinningByMouse = false;\n    this._valueToValidate = undefined;\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n  }\n\n  /**\n   * Invoked when a component is receiving new props. This method is not called for the initial render.\n   */\n  // tslint:disable-next-line function-name\n  public UNSAFE_componentWillReceiveProps(newProps: ISpinButtonProps): void {\n    this._lastValidValue = this.state.value;\n    let value: string = newProps.value ? newProps.value : String(newProps.min);\n    if (newProps.defaultValue) {\n      value = String(Math.max(newProps.min as number, Math.min(newProps.max as number, Number(newProps.defaultValue))));\n    }\n\n    if (newProps.value !== undefined) {\n      this.setState({\n        value: value\n      });\n    }\n    this._precision = this._calculatePrecision(newProps as ISpinButtonProps & DefaultProps);\n  }\n\n  public render(): JSX.Element {\n    const {\n      disabled,\n      label,\n      min,\n      max,\n      labelPosition,\n      iconProps,\n      incrementButtonIcon,\n      incrementButtonAriaLabel,\n      decrementButtonIcon,\n      decrementButtonAriaLabel,\n      title,\n      ariaLabel,\n      ariaDescribedBy,\n      styles: customStyles,\n      upArrowButtonStyles: customUpArrowButtonStyles,\n      downArrowButtonStyles: customDownArrowButtonStyles,\n      theme,\n      ariaPositionInSet,\n      ariaSetSize,\n      ariaValueNow,\n      ariaValueText,\n      keytipProps,\n      className,\n      inputProps,\n      iconButtonProps\n    } = this.props as ISpinButtonInternalProps;\n\n    const { isFocused, value, keyboardSpinDirection } = this.state;\n\n    const classNames = this.props.getClassNames\n      ? this.props.getClassNames(theme!, disabled, isFocused, keyboardSpinDirection, labelPosition, className)\n      : getClassNames(getStyles(theme!, customStyles), disabled, isFocused, keyboardSpinDirection, labelPosition, className);\n\n    return (\n      <div className={classNames.root}>\n        {labelPosition !== Position.bottom && (\n          <div className={classNames.labelWrapper}>\n            {iconProps && <Icon {...iconProps} className={classNames.icon} aria-hidden=\"true\" />}\n            {label && (\n              <Label id={this._labelId} htmlFor={this._inputId} className={classNames.label} disabled={disabled}>\n                {label}\n              </Label>\n            )}\n          </div>\n        )}\n        <KeytipData keytipProps={keytipProps} disabled={disabled}>\n          {(keytipAttributes: any): JSX.Element => (\n            <div\n              className={classNames.spinButtonWrapper}\n              title={title && title}\n              aria-label={ariaLabel && ariaLabel}\n              aria-posinset={ariaPositionInSet}\n              aria-setsize={ariaSetSize}\n              data-ktp-target={keytipAttributes['data-ktp-target']}\n            >\n              <input\n                value={value}\n                id={this._inputId}\n                onChange={this._onChange}\n                onInput={this._onInputChange}\n                className={classNames.input}\n                type=\"text\"\n                autoComplete=\"off\"\n                role=\"spinbutton\"\n                aria-labelledby={label && this._labelId}\n                aria-valuenow={!isNaN(Number(ariaValueNow)) ? ariaValueNow : !isNaN(Number(value)) ? Number(value) : undefined}\n                aria-valuetext={ariaValueText ? ariaValueText : isNaN(Number(value)) ? value : undefined}\n                aria-valuemin={min}\n                aria-valuemax={max}\n                aria-describedby={mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby'])}\n                onBlur={this._onBlur}\n                ref={this._input}\n                onFocus={this._onFocus}\n                onKeyDown={this._handleKeyDown}\n                onKeyUp={this._handleKeyUp}\n                readOnly={disabled}\n                aria-disabled={disabled}\n                data-lpignore={true}\n                data-ktp-execute-target={keytipAttributes['data-ktp-execute-target']}\n                {...inputProps}\n              />\n              <span className={classNames.arrowBox}>\n                <IconButton\n                  styles={getArrowButtonStyles(theme!, true, customUpArrowButtonStyles)}\n                  className={'ms-UpButton'}\n                  checked={keyboardSpinDirection === KeyboardSpinDirection.up}\n                  disabled={disabled}\n                  iconProps={incrementButtonIcon}\n                  onMouseDown={this._onIncrementMouseDown}\n                  onMouseLeave={this._stop}\n                  onMouseUp={this._stop}\n                  tabIndex={-1}\n                  ariaLabel={incrementButtonAriaLabel}\n                  data-is-focusable={false}\n                  {...iconButtonProps}\n                />\n                <IconButton\n                  styles={getArrowButtonStyles(theme!, false, customDownArrowButtonStyles)}\n                  className={'ms-DownButton'}\n                  checked={keyboardSpinDirection === KeyboardSpinDirection.down}\n                  disabled={disabled}\n                  iconProps={decrementButtonIcon}\n                  onMouseDown={this._onDecrementMouseDown}\n                  onMouseLeave={this._stop}\n                  onMouseUp={this._stop}\n                  tabIndex={-1}\n                  ariaLabel={decrementButtonAriaLabel}\n                  data-is-focusable={false}\n                  {...iconButtonProps}\n                />\n              </span>\n            </div>\n          )}\n        </KeytipData>\n        {labelPosition === Position.bottom && (\n          <div className={classNames.labelWrapper}>\n            {iconProps && <Icon iconName={iconProps.iconName} className={classNames.icon} aria-hidden=\"true\" />}\n            {label && (\n              <Label id={this._labelId} htmlFor={this._inputId} className={classNames.label} disabled={disabled}>\n                {label}\n              </Label>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  public focus(): void {\n    if (this._input.current) {\n      this._input.current.focus();\n    }\n  }\n\n  private _onFocus = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    // We can't set focus on a non-existing element\n    if (!this._input.current) {\n      return;\n    }\n\n    if (this._spinningByMouse || this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      this._stop();\n    }\n\n    this._input.current.select();\n\n    this.setState({ isFocused: true });\n\n    if (this.props.onFocus) {\n      this.props.onFocus(ev);\n    }\n  };\n\n  private _onBlur = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    this._validate(ev);\n    this.setState({ isFocused: false });\n    if (this.props.onBlur) {\n      this.props.onBlur(ev);\n    }\n  };\n\n  /**\n   * Gets the value of the spin button.\n   */\n  public get value(): string | undefined {\n    return this.props.value === undefined ? this.state.value : this.props.value;\n  }\n\n  private _onValidate = (value: string, event?: React.SyntheticEvent<HTMLElement>): string | void => {\n    if (this.props.onValidate) {\n      return this.props.onValidate(value, event);\n    } else {\n      return this._defaultOnValidate(value);\n    }\n  };\n\n  private _calculatePrecision = (props: ISpinButtonProps & DefaultProps) => {\n    const { precision = Math.max(calculatePrecision(props.step), 0) } = props;\n    return precision;\n  };\n\n  /**\n   * Validate function to use if one is not passed in\n   */\n  private _defaultOnValidate = (value: string) => {\n    if (value === null || value.trim().length === 0 || isNaN(Number(value))) {\n      return this._lastValidValue;\n    }\n    const newValue = Math.min(this.props.max as number, Math.max(this.props.min as number, Number(value)));\n    return String(newValue);\n  };\n\n  private _onIncrement = (value: string): string | void => {\n    if (this.props.onIncrement) {\n      return this.props.onIncrement(value);\n    } else {\n      return this._defaultOnIncrement(value);\n    }\n  };\n\n  /**\n   * Increment function to use if one is not passed in\n   */\n  private _defaultOnIncrement = (value: string): string | void => {\n    const { max, step } = this.props as ISpinButtonInternalProps;\n    let newValue: number = Math.min(Number(value) + Number(step), max);\n    newValue = precisionRound(newValue, this._precision);\n    return String(newValue);\n  };\n\n  private _onDecrement = (value: string): string | void => {\n    if (this.props.onDecrement) {\n      return this.props.onDecrement(value);\n    } else {\n      return this._defaultOnDecrement(value);\n    }\n  };\n\n  /**\n   * Increment function to use if one is not passed in\n   */\n  private _defaultOnDecrement = (value: string): string | void => {\n    const { min, step } = this.props as ISpinButtonInternalProps;\n    let newValue: number = Math.max(Number(value) - Number(step), min);\n    newValue = precisionRound(newValue, this._precision);\n    return String(newValue);\n  };\n\n  private _onChange(): void {\n    /**\n     * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n     * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n     * The no-op onChange handler was still needed because React gives console errors if an input\n     * doesn't have onChange.\n     *\n     * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n     * ours or 3rd-party, which simulate entering text in a SpinButton)\n     */\n  }\n\n  /**\n   * This is used when validating text entry\n   * in the input (not when changed via the buttons)\n   * @param event - the event that fired\n   */\n  private _validate = (event: React.FocusEvent<HTMLInputElement> | React.KeyboardEvent<HTMLInputElement>): void => {\n    if (this.state.value !== undefined && this._valueToValidate !== undefined && this._valueToValidate !== this._lastValidValue) {\n      const newValue = this._onValidate!(this._valueToValidate, event);\n      if (newValue) {\n        this._lastValidValue = newValue;\n        this._valueToValidate = undefined;\n        this.setState({ value: newValue });\n      }\n    }\n  };\n\n  /**\n   * The method is needed to ensure we are updating the actual input value.\n   * without this our value will never change (and validation will not have the correct number)\n   * @param event - the event that was fired\n   */\n  private _onInputChange = (event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>): void => {\n    const element: HTMLInputElement = event.target as HTMLInputElement;\n    const value: string = element.value;\n    this._valueToValidate = value;\n    this.setState({\n      value: value\n    });\n  };\n\n  /**\n   * Update the value with the given stepFunction\n   * @param shouldSpin - should we fire off another updateValue when we are done here? This should be true\n   * when spinning in response to a mouseDown\n   * @param stepFunction - function to use to step by\n   */\n  private _updateValue = (shouldSpin: boolean, stepDelay: number, stepFunction: (value: string) => string | void): void => {\n    const newValue: string | void = stepFunction(this.state.value);\n    if (newValue) {\n      this._lastValidValue = newValue;\n      this.setState({ value: newValue });\n    }\n\n    if (this._spinningByMouse !== shouldSpin) {\n      this._spinningByMouse = shouldSpin;\n    }\n\n    if (shouldSpin) {\n      this._currentStepFunctionHandle = this._async.setTimeout(() => {\n        this._updateValue(shouldSpin, this._stepDelay, stepFunction);\n      }, stepDelay);\n    }\n  };\n\n  /**\n   * Stop spinning (clear any currently pending update and set spinning to false)\n   */\n  private _stop = (): void => {\n    if (this._currentStepFunctionHandle >= 0) {\n      this._async.clearTimeout(this._currentStepFunctionHandle);\n      this._currentStepFunctionHandle = -1;\n    }\n\n    if (this._spinningByMouse || this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      this._spinningByMouse = false;\n      this.setState({ keyboardSpinDirection: KeyboardSpinDirection.notSpinning });\n    }\n  };\n\n  /**\n   * Handle keydown on the text field. We need to update\n   * the value when up or down arrow are depressed\n   * @param event - the keyboardEvent that was fired\n   */\n  private _handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>): void => {\n    // eat the up and down arrow keys to keep focus in the spinButton\n    // (especially when a spinButton is inside of a FocusZone)\n    if (event.which === KeyCodes.up || event.which === KeyCodes.down || event.which === KeyCodes.enter) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (this.props.disabled) {\n      this._stop();\n      return;\n    }\n\n    let spinDirection = KeyboardSpinDirection.notSpinning;\n\n    switch (event.which) {\n      case KeyCodes.up:\n        spinDirection = KeyboardSpinDirection.up;\n        this._updateValue(false /* shouldSpin */, this._initialStepDelay, this._onIncrement!);\n        break;\n      case KeyCodes.down:\n        spinDirection = KeyboardSpinDirection.down;\n        this._updateValue(false /* shouldSpin */, this._initialStepDelay, this._onDecrement!);\n        break;\n      case KeyCodes.enter:\n      case KeyCodes.tab:\n        this._validate(event);\n        break;\n      case KeyCodes.escape:\n        if (this.state.value !== this._lastValidValue) {\n          this.setState({ value: this._lastValidValue });\n        }\n        break;\n      default:\n        break;\n    }\n\n    // style the increment/decrement button to look active\n    // when the corresponding up/down arrow keys trigger a step\n    if (this.state.keyboardSpinDirection !== spinDirection) {\n      this.setState({ keyboardSpinDirection: spinDirection });\n    }\n  };\n\n  /**\n   * Make sure that we have stopped spinning on keyUp\n   * if the up or down arrow fired this event\n   * @param event - keyboard event\n   */\n  private _handleKeyUp = (event: React.KeyboardEvent<HTMLElement>): void => {\n    if (this.props.disabled || event.which === KeyCodes.up || event.which === KeyCodes.down) {\n      this._stop();\n      return;\n    }\n  };\n\n  private _onIncrementMouseDown = (): void => {\n    this._updateValue(true /* shouldSpin */, this._initialStepDelay, this._onIncrement!);\n  };\n\n  private _onDecrementMouseDown = (): void => {\n    this._updateValue(true /* shouldSpin */, this._initialStepDelay, this._onDecrement!);\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}